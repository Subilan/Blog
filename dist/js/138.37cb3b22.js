"use strict";(self["webpackChunkblog"]=self["webpackChunkblog"]||[]).push([[138],{2138:function(e,s,a){a.r(s),a.d(s,{default:function(){return i}});var n=a(3396);const o={class:"content"},t=(0,n.uE)('<h1 class="post-title">Vue 前后端分离的正确方式<a class="header-anchor" id="Vue%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E5%BC%8F" href="#Vue%20%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%96%B9%E5%BC%8F">#</a></h1><div class="metabar"><div class="metabar-item">2021/04/04</div><div class="metabar-item">路径</div><div class="metabar-item">约 6 分钟读完</div></div><p>在之前我一直在想 Vue 的前后端分离怎么那么麻烦，让人头大。后来才发现原来我是个小丑，实际上特别简单。本文只是用来记录方法，没有科普的意思，可能此刻的<em>你</em>已经知道了这一切。本文中的<strong>前后端分离</strong>指的是以 Vue 等框架作为前端技术栈，与后端形成分离，通过 XHR 进行交流的粗略概念，并没有深究的必要。</p><h2>先前的方式<a class="header-anchor" id="%E5%85%88%E5%89%8D%E7%9A%84%E6%96%B9%E5%BC%8F" href="#%E5%85%88%E5%89%8D%E7%9A%84%E6%96%B9%E5%BC%8F">#</a></h2><p>一般情况下，后端会位于一个单独的目录里面，里面就是各种各样的 <code>.php</code>、<code>.py</code> 等等。要开始使用，就要想办法让前端能够 post 到他们。然而对于 Vue 来说，打开的 dev server 是仅限于 Vue 的，所有的请求都会给 Vue 自己；而对于后端来说，比如 PHP 的 <code>php -S</code>、Python 的 <code>python -m</code> 或者 flask 的 <code>python ./App.py</code> 等，也都只是开的自己的 dev server，这就让开发过程很难访问到后端。每一个 dev server 会占用一个独立的端口，这就让它们彻底独立了。</p><p>然后，这种确实是从一开始就有解决方式的，那就是借助前端一个叫做代理（这里的代理不是前文的 Proxy）的东西。比如 Vue 里面就是在 <code>vue.config.js</code> 里</p><div class="language-js"><pre class="language-js"><code class="language-js">\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n    <span class="token literal-property property">proxy</span><span class="token operator">:</span> <span class="token string">&quot;http://127.0.0.1:8081&quot;</span>\n<span class="token punctuation">}</span>\n\n</code></pre></div><p>设置好了以后，按照官方文档的说法，会把一切无法识别的请求（也就是那些跟前端没有关系的请求）代理到这个地址，而这个地址就可以直接指向后端服务器的地址，比如 <code>http://127.0.0.1:5000</code> 等。不过这个地方曾经让我无语过很多次，因为实际上你写成 <code>http://localhost:XXXX</code>、<code>http://localhost:XXXX/</code>、<code>http://127.0.0.1:XXXX</code>、<code>http://127.0.0.1:XXXX/</code> 的结果，有的时候是不一样的，还会导致一些类似于 <code>ECONNREFUSED</code> 或者无法代理等迷惑问题。PHP 也是，当执行 <code>php -S</code> 时，后面如果跟的是 <code>.</code>（当前目录）也会引起一些莫名其妙的错误，对于 PHP 来说，<code>localhost</code> 和 <code>127.0.0.1</code> 的效果也并不完全相同。这实在是太坑了，可我也没有时间去了解原理，麻烦懂的大佬给我发个邮件讲讲！</p><p>OK，这是开发阶段，我们解决了，使用起来没有任何问题。然而遇到生产环境就怂了。那么接下来就是一种很 low 的解决方式——子域名。</p><p>很多时候我觉得没必要这么大费周章开个子域名出来挂给后端，然而我又<a href="https://api.sotap.org" class="external-link" target="_blank" rel="noopener noreferrer">这样做了<span class="external-link-icon mdi mdi-launch"></span></a>，想想都后悔。因为这样首先会再费一张 SSL 证书，其次还会多一个配置文件，然后让整个主机配置都变得臃肿（虽然实际上没有这么严重但让我很不爽）。在解决了司马 CORS 以后就能正常使用了，而这跟直接去 post 另一个<em>属于你自己的</em>网站无异。</p><h2>现在的方式<a class="header-anchor" id="%E7%8E%B0%E5%9C%A8%E7%9A%84%E6%96%B9%E5%BC%8F" href="#%E7%8E%B0%E5%9C%A8%E7%9A%84%E6%96%B9%E5%BC%8F">#</a></h2><p>现在我终于知道 <code>.htaccess</code> 能够把我的请求从 Vue 手中解离出来。因为实际上，用子域名就是为了彻底逃脱当前网站里 Vue 对请求的劫持，因为只要开了一个新的站点，那么它就是个全新的根目录，里面的环境也都是全新的了。</p><p>那么该如何解离呢，请看</p><div class="language-xml"><pre class="language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>IfModule</span> <span class="token attr-name">mod_rewrite.c</span><span class="token punctuation">&gt;</span></span>\n  RewriteEngine On\n  RewriteBase /\n  RewriteCond %{REQUEST_URI} !/api/\n  RewriteRule ^index\\.html$ - [L]\n  RewriteCond %{REQUEST_FILENAME} !-f\n  RewriteCond %{REQUEST_FILENAME} !-d\n  RewriteRule . /index.html [L]\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>IfModule</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div><p>哦，原来可以直接在 <code>.htaccess</code> 里面指定一个 <code>RewriteCond</code> 来限制它的重写操作。而且实际上，Vue 对链接的劫持是由 Apache 或 Nginx 帮助完成的，我怎么这么久都没想到呢（啪）！那么在这个地方我们加上的一行 <code>RewriteCond %{REQUEST_URI} !/api/</code> 意思是不让对 <code>/api</code> 目录的请求进行重写。那么这个时候对我们来说唯一的要求就是要让所有的后端请求都发往这个地址。当然处理方法不止这一种，而这一种是最简洁的。其实也有想过把 <code>*.php</code> 取消重写，但是不知道怎么写，这里的正则都太迷惑了，动不动就是个 500。</p><p>接下来就只需要把所有的后端文件都装在这个文件夹里，然后在 <code>build</code> 的时候一起放到 <code>dist</code> 里面（因为 <code>dist</code> 是网站根目录，<code>.htaccess</code> 也在里面）就完了。而这也很简单，在 <code>package.json</code> 里面加上这样一句就可。</p><div class="language-js"><pre class="language-js"><code class="language-js"><span class="token punctuation">{</span>\n    <span class="token comment">//...</span>\n    <span class="token string-property property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token comment">// ...</span>\n        <span class="token string-property property">&quot;build&quot;</span><span class="token operator">:</span> <span class="token string">&quot;... &amp;&amp; cp -r /path/to/api dist&quot;</span> \n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div>',17),p=[t];function c(e,s){return(0,n.wg)(),(0,n.iD)("div",o,p)}var d=a(89);const l={},r=(0,d.Z)(l,[["render",c]]);var i=r}}]);
//# sourceMappingURL=138.37cb3b22.js.map