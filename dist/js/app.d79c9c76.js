(function(){"use strict";var n={343:function(n,e,t){var a=t(9242),i=t(3396),o=(t(560),t(4870)),r=t(7139),s=t(1476),l=t(2483);const c=n=>((0,i.dD)("data-v-62a5a329"),n=n(),(0,i.Cn)(),n),u=c((()=>(0,i._)("span",{class:"mdi mdi-magnify"},null,-1))),d={key:0},p={class:"search-dialog"},m={class:"search-textfield"},f=c((()=>(0,i._)("span",{class:"mdi mdi-magnify"},null,-1))),h={class:"search-result"},g={key:0},b=["onClick"],y={class:"title"},v=["innerHTML"],w={class:"meta"},S={class:"badge"},k={key:1,class:"search-text"},T={key:2,class:"search-text"},x={key:3,class:"search-text"},C={key:0,class:"close-btn-wrapper"};var M=(0,i.aZ)({__name:"SearchBox",setup(n){const e=(0,o.iH)(!1),t=(0,o.iH)(!1),c=(0,o.iH)("none"),M=(0,o.iH)(null),I=(0,o.iH)(""),A=(0,o.iH)([]),D=(0,s.on)(),E=(0,o.iH)(!1),P=(0,l.tv)();let $=0;const O=n=>e=>{clearTimeout($),$=window.setTimeout((()=>e()),n)};function R(){if(0===I.value.trim().length)return void(A.value=[]);const n=D.filter((n=>n.title.toLowerCase().includes(I.value.toLowerCase()))),e=D.filter((n=>n.filecontent.toLowerCase().includes(I.value.toLowerCase()))),t=[...new Set([...n,...e])];A.value=t.map((n=>({title:n.title,filename:n.filename,namespace:n.namespace,nearestText:L(n.filecontent,I.value)}))),E.value=!1}function L(n,e){const t=n.toLowerCase().indexOf(e.toLowerCase()),a=t-50,i=t+e.length+50,o=n.substring(a<0?0:a,i>n.length-1?n.length-1:i);return"..."+o.replace(new RegExp(`(${e})`,"gi"),"<strong>$1</strong>")+"..."}function j(n){"Escape"===n.key&&(e.value=!1)}return(0,i.bv)((()=>{window.addEventListener("keydown",(n=>{n.ctrlKey&&"k"===n.key&&(n.preventDefault(),e.value=!e.value)}))})),(0,i.YP)(e,(n=>{n?(c.value="block",setTimeout((()=>{t.value=!0,(0,s.XY)()}),1)):(t.value=!1,(0,s.K9)(),setTimeout((()=>{c.value="none"}),200))})),(0,i.YP)(t,(n=>{n?(window.addEventListener("keydown",j),null!==M.value&&M.value.focus()):(window.removeEventListener("keydown",j),I.value="",A.value=[])})),(n,l)=>((0,i.wg)(),(0,i.iD)(i.HY,null,[(0,i._)("div",{onClick:l[0]||(l[0]=n=>e.value=!e.value),class:"search-box"},[u,(0,o.SU)(s.t6)()?((0,i.wg)(),(0,i.iD)("span",d,"搜索 (Ctrl+K)")):(0,i.kq)("",!0)]),(0,i._)("div",{onClick:l[3]||(l[3]=(0,a.iM)((n=>e.value=!1),["self"])),class:(0,r.C_)(["cover",{active:t.value}]),style:(0,r.j5)({display:c.value})},[(0,i._)("div",p,[(0,i._)("div",m,[f,(0,i.wy)((0,i._)("input",{ref_key:"searchInput",ref:M,"onUpdate:modelValue":l[1]||(l[1]=n=>I.value=n),placeholder:"搜索文章标题、内容",class:"search-input",type:"text",onKeydown:l[2]||(l[2]=n=>{O(400)((()=>{E.value=!0,R()}))})},null,544),[[a.nr,I.value]])]),(0,i._)("div",h,[A.value.length>0?((0,i.wg)(),(0,i.iD)("div",g,[((0,i.wg)(!0),(0,i.iD)(i.HY,null,(0,i.Ko)(A.value,((n,t)=>((0,i.wg)(),(0,i.iD)("div",{onClick:t=>{e.value=!1,(0,o.SU)(P).push("post"===n.namespace?`/posts/${n.filename}`:`/${n.filename}`)},class:"result",tabindex:"0"},[(0,i._)("div",y,(0,r.zw)(n.title),1),(0,i._)("div",{class:"content",innerHTML:n.nearestText},null,8,v),(0,i._)("div",w,[(0,i._)("div",S,(0,r.zw)(n.namespace),1),(0,i.Uk)(" "+(0,r.zw)(n.filename)+".md ",1)])],8,b)))),256))])):0===I.value.trim().length?((0,i.wg)(),(0,i.iD)("div",k," 键入以搜索 ")):E.value?((0,i.wg)(),(0,i.iD)("div",T," 加载中... ")):((0,i.wg)(),(0,i.iD)("div",x," 没有与搜索条件匹配的项 "))])])],6),(0,i.Wm)(a.uT,{name:"flowup"},{default:(0,i.w5)((()=>[t.value&&!(0,o.SU)(s.t6)()?((0,i.wg)(),(0,i.iD)("div",C,[(0,i._)("div",{class:"close-btn",onClick:l[4]||(l[4]=n=>e.value=!1)}," 关闭 ")])):(0,i.kq)("",!0)])),_:1})],64))}}),I=t(89);const A=(0,I.Z)(M,[["__scopeId","data-v-62a5a329"]]);var D=A;const E=n=>((0,i.dD)("data-v-0669fa10"),n=n(),(0,i.Cn)(),n),P={class:"navbar"},$=E((()=>(0,i._)("div",{class:"nav-spacer",style:{flex:"1"}},null,-1))),O={key:2,class:"page-list"},R=["onClick"],L={key:0,class:"sidebar"},j=E((()=>(0,i._)("div",{class:"sidebar-title"}," 切换页面 ",-1))),B=E((()=>(0,i._)("span",{class:"mdi mdi-home"},null,-1))),_=["onClick"],V=E((()=>(0,i._)("span",{class:"mdi mdi-github"},null,-1)));var H=(0,i.aZ)({__name:"Navbar",setup(n){const e=(0,s.UQ)(),t=(0,l.tv)(),c=(0,l.yj)(),u=(0,o.iH)(!1);function d(n){const e={"联系":"mdi-account-plus","公钥":"mdi-key-chain-variant","关于":"mdi-information-outline","友链":"mdi-home-group"};return e[n]}return(0,i.YP)((()=>u.value),(n=>{n?(0,s.XY)():(0,s.K9)()})),(n,l)=>((0,i.wg)(),(0,i.iD)(i.HY,null,[(0,i._)("nav",P,[(0,i._)("div",{onClick:l[0]||(l[0]=n=>u.value=!u.value),class:"mdi mdi-menu menu-btn"}),(0,i._)("div",{class:"page-title",onClick:l[1]||(l[1]=n=>(0,o.SU)(t).push("/"))}," Subilan's Blog "),(0,o.SU)(s.t6)()?((0,i.wg)(),(0,i.j4)(D,{key:0})):(0,i.kq)("",!0),$,(0,o.SU)(s.t6)()?(0,i.kq)("",!0):((0,i.wg)(),(0,i.j4)(D,{key:1})),(0,o.SU)(s.t6)()?((0,i.wg)(),(0,i.iD)("div",O,[(0,i._)("div",{class:(0,r.C_)(["page",{active:"/"===(0,o.SU)(c).path}]),onClick:l[2]||(l[2]=e=>n.$router.push("/"))},"首页",2),((0,i.wg)(!0),(0,i.iD)(i.HY,null,(0,i.Ko)((0,o.SU)(e),(n=>((0,i.wg)(),(0,i.iD)("div",{class:(0,r.C_)(["page",{active:(0,o.SU)(c).path===`/${n.filename}`}]),onClick:e=>(0,o.SU)(t).push(`/${n.filename}`)},(0,r.zw)(n.title),11,R)))),256)),(0,i._)("div",{class:"page",onClick:l[3]||(l[3]=n=>(0,o.SU)(s.Ah)("https://github.com/Subilan/subilan.github.io"))}," GitHub ")])):(0,i.kq)("",!0)]),(0,i._)("div",{class:(0,r.C_)(["sidebar-cover",{active:u.value}]),onClick:l[4]||(l[4]=(0,a.iM)((n=>u.value=!1),["self"]))},null,2),(0,i.Wm)(a.uT,{name:"slide"},{default:(0,i.w5)((()=>[u.value?((0,i.wg)(),(0,i.iD)("div",L,[j,(0,i._)("div",{class:"sidebar-items",onClick:l[7]||(l[7]=n=>u.value=!1)},[(0,i._)("div",{class:(0,r.C_)(["sidebar-item",{active:"/"===(0,o.SU)(c).path}]),onClick:l[5]||(l[5]=e=>n.$router.push("/"))},[B,(0,i.Uk)("首页 ")],2),((0,i.wg)(!0),(0,i.iD)(i.HY,null,(0,i.Ko)((0,o.SU)(e),(n=>((0,i.wg)(),(0,i.iD)("div",{class:(0,r.C_)(["sidebar-item",{active:(0,o.SU)(c).path===`/${n.filename}`}]),onClick:e=>(0,o.SU)(t).push(`/${n.filename}`)},[(0,i._)("span",{class:(0,r.C_)(["mdi",d(n.title)])},null,2),(0,i.Uk)((0,r.zw)(n.title),1)],10,_)))),256)),(0,i._)("div",{class:"sidebar-item",onClick:l[6]||(l[6]=n=>(0,o.SU)(s.Ah)("https://github.com/Subilan/subilan.github.io"))},[V,(0,i.Uk)("GitHub ")])])])):(0,i.kq)("",!0)])),_:1})],64))}});const N=(0,I.Z)(H,[["__scopeId","data-v-0669fa10"]]);var U=N;const q=n=>((0,i.dD)("data-v-58c06174"),n=n(),(0,i.Cn)(),n),F=q((()=>(0,i._)("div",{class:"footer-text"},[(0,i._)("div",{class:"copyright"},"© 2019-2024 Subilan ✨"),(0,i._)("div",{class:"built"},"Built with Vue 3 & markdown-it")],-1))),W=[F];function G(n,e){return(0,i.wg)(),(0,i.iD)("footer",null,W)}const z={},J=(0,I.Z)(z,[["render",G],["__scopeId","data-v-58c06174"]]);var K=J;const Q={class:"container"};var Y=(0,i.aZ)({__name:"App",setup(n){return(n,e)=>{const t=(0,i.up)("router-view");return(0,i.wg)(),(0,i.iD)(i.HY,null,[(0,i.Wm)(U),(0,i._)("div",Q,[(0,i.Wm)(t)]),(0,i.Wm)(K)],64)}}});const X=Y;var Z=X;const nn=[{name:"page",path:"/",component:()=>t.e(127).then(t.bind(t,6127)),children:[{name:"about",path:"/About",component:()=>t.e(55).then(t.bind(t,55)),meta:{filename:"About",title:"关于",uuid:"76de1484-e3ae-55cc-86aa-e30a285baf31",isStandalone:!0}},{name:"blogroll",path:"/Blogroll",component:()=>t.e(370).then(t.bind(t,5370)),meta:{filename:"Blogroll",title:"友链",uuid:"c9ea49df-64df-5325-b76c-0a8cbfc9a275",isStandalone:!0}},{name:"contact",path:"/Contact",component:()=>t.e(816).then(t.bind(t,3816)),meta:{filename:"Contact",title:"联系",uuid:"e612ac32-c268-59bc-b1ba-e0b342dda95b",isStandalone:!0}},{name:"pgp",path:"/PGP",component:()=>t.e(63).then(t.bind(t,6063)),meta:{filename:"PGP",title:"公钥",uuid:"7b231c22-cce7-5469-93a2-de8695c76080",isStandalone:!0}}]},{name:"posts",path:"/posts",component:()=>t.e(983).then(t.bind(t,5983)),children:[{name:"post-2020-recall",path:"2020-Recall",component:()=>t.e(45).then(t.bind(t,4045)),meta:{filename:"2020-Recall",title:"2020 年结束语",uuid:"701a4eea-1104-59a9-a910-fbe6d5444db5",isStandalone:!1}},{name:"post-2021-recall",path:"2021-Recall",component:()=>t.e(572).then(t.bind(t,572)),meta:{filename:"2021-Recall",title:"2021 总结",uuid:"9d7373fe-4e27-5354-8db6-cec2298e09b7",isStandalone:!1}},{name:"post-2022-recall",path:"2022-Recall",component:()=>t.e(534).then(t.bind(t,534)),meta:{filename:"2022-Recall",title:"纵观烟火和习惯于向往美好以后我的变化",uuid:"7e4eb0ee-a4df-50f0-abb8-88a6786fbf76",isStandalone:!1}},{name:"post-action-ethnic",path:"Action-Ethnic",component:()=>t.e(326).then(t.bind(t,6326)),meta:{filename:"Action-Ethnic",title:"行为伦理",uuid:"85b77676-092f-5f66-a1fb-50f6d88ac79f",isStandalone:!1}},{name:"post-array-date-and-category",path:"Array-Date-and-Category",component:()=>t.e(317).then(t.bind(t,7317)),meta:{filename:"Array-Date-and-Category",title:"对于包含日期数组的处理",uuid:"5a309181-328c-5230-be8f-7cfa3d0958ba",isStandalone:!1}},{name:"post-barren-fungus",path:"Barren-Fungus",component:()=>t.e(743).then(t.bind(t,4743)),meta:{filename:"Barren-Fungus",title:"Barren Fungus",uuid:"40acf917-ebe5-5914-919e-6dfbd715aec4",isStandalone:!1}},{name:"post-build-a-blog-using-vuepress",path:"Build-a-Blog-Using-VuePress",component:()=>t.e(515).then(t.bind(t,6515)),meta:{filename:"Build-a-Blog-Using-VuePress",title:"使用 VuePress 搭建博客",uuid:"34117c7c-f531-5cbe-9c45-f0ae727848dc",isStandalone:!1}},{name:"post-bukkit-object-pool-picking-and-updating",path:"Bukkit-Object-Pool-Picking-And-Updating",component:()=>t.e(982).then(t.bind(t,4982)),meta:{filename:"Bukkit-Object-Pool-Picking-And-Updating",title:"Bukkit 实现对象池随机抽取和定时更新",uuid:"9da2cd0d-10e0-59d5-a89d-0b4b6b77aede",isStandalone:!1}},{name:"post-bukkit-webserver-in-minecraft",path:"Bukkit-Webserver-In-Minecraft",component:()=>t.e(292).then(t.bind(t,4292)),meta:{filename:"Bukkit-Webserver-In-Minecraft",title:"Bukkit 实现 MC 服务器里的 HTTP 服务器",uuid:"b36277c4-2c3c-5219-bcea-193a6ac51107",isStandalone:!1}},{name:"post-chongqing-chengdu-tour-1",path:"Chongqing-Chengdu-Tour-1",component:()=>t.e(469).then(t.bind(t,469)),meta:{filename:"Chongqing-Chengdu-Tour-1",title:"重庆—成都游记（上）",uuid:"2c885161-16c8-5953-9358-a5d9a44290ad",isStandalone:!1}},{name:"post-chongqing-chengdu-tour-2",path:"Chongqing-Chengdu-Tour-2",component:()=>t.e(815).then(t.bind(t,815)),meta:{filename:"Chongqing-Chengdu-Tour-2",title:"重庆—成都游记（下）",uuid:"c6107731-a424-52f2-a7b2-bf22a03577b2",isStandalone:!1}},{name:"post-forge-development-diary",path:"Forge-development-diary",component:()=>t.e(390).then(t.bind(t,6390)),meta:{filename:"Forge-development-diary",title:"Forge 开发日志（一）",uuid:"fbe2f969-9990-5cbc-8b84-0afaa3812b6c",isStandalone:!1}},{name:"post-hello-world",path:"Hello-World",component:()=>t.e(271).then(t.bind(t,5271)),meta:{filename:"Hello-World",title:"Hello World",uuid:"4f6abb11-b6ec-50ce-88f7-5c51e9cd0634",isStandalone:!1}},{name:"post-learning-swift-1",path:"Learning-Swift-1",component:()=>t.e(849).then(t.bind(t,9370)),meta:{filename:"Learning-Swift-1",title:"Swift 学习笔记（一）——A Swift Tour",uuid:"778512da-02d8-58df-afb6-cda5dee5cdba",isStandalone:!1}},{name:"post-menu-handling",path:"Menu-Handling",component:()=>t.e(268).then(t.bind(t,6268)),meta:{filename:"Menu-Handling",title:"Menu 组件的基本处理和实现",uuid:"38a821d6-d947-5eb6-a77f-3c81195ee032",isStandalone:!1}},{name:"post-minecraft-sponge-server-tutorial",path:"Minecraft-Sponge-Server-Tutorial",component:()=>t.e(90).then(t.bind(t,9090)),meta:{filename:"Minecraft-Sponge-Server-Tutorial",title:"Sponge 搭建 1.12.2 Mod + 插件服务器",uuid:"688d53bf-9266-573c-a485-9873a014c4a1",isStandalone:!1}},{name:"post-my-add",path:"My-ADD",component:()=>t.e(311).then(t.bind(t,8311)),meta:{filename:"My-ADD",title:"我的 ADD",uuid:"3740f622-01dd-521a-b416-ea6f850d5c4a",isStandalone:!1}},{name:"post-only-the-river-flows",path:"Only-the-river-flows",component:()=>t.e(613).then(t.bind(t,8613)),meta:{filename:"Only-the-river-flows",title:"只有河在流",uuid:"a3195ace-bc15-5a64-93d9-0f3a10efc69a",isStandalone:!1}},{name:"post-self",path:"Self",component:()=>t.e(514).then(t.bind(t,3514)),meta:{filename:"Self",title:"自我宣言",uuid:"c84f49a7-c508-5782-9f5c-3a99580c2d2c",isStandalone:!1}},{name:"post-semi-completed-articles",path:"Semi-completed-Articles",component:()=>t.e(406).then(t.bind(t,1406)),meta:{filename:"Semi-completed-Articles",title:"精神内耗文集",uuid:"547720c7-d598-5100-9019-6dc220006cba",isStandalone:!1}},{name:"post-shennongjia",path:"Shennongjia",component:()=>t.e(594).then(t.bind(t,9594)),meta:{filename:"Shennongjia",title:"神农架游记",uuid:"c3d76b2a-69fa-5976-8cf0-cdafa24418ef",isStandalone:!1}},{name:"post-simple-authenticating-system",path:"Simple-Authenticating-System",component:()=>t.e(61).then(t.bind(t,2061)),meta:{filename:"Simple-Authenticating-System",title:"一个简单的初级登录系统",uuid:"bb90f77a-8deb-5f42-9117-6adf3def7986",isStandalone:!1}},{name:"post-simple-vote-logic-1",path:"Simple-Vote-Logic-1",component:()=>t.e(875).then(t.bind(t,2875)),meta:{filename:"Simple-Vote-Logic-1",title:"简单的投票系统实现（一）",uuid:"f384abf2-dff2-586a-acaa-402302fae253",isStandalone:!1}},{name:"post-simple-vue-tricks-2",path:"Simple-Vue-Tricks-2",component:()=>t.e(912).then(t.bind(t,2912)),meta:{filename:"Simple-Vue-Tricks-2",title:"一些 Vue 的常用技巧（续篇）",uuid:"3c0a2012-f1be-5190-9a47-2d5112f04b6f",isStandalone:!1}},{name:"post-simple-vue-tricks",path:"Simple-Vue-Tricks",component:()=>t.e(785).then(t.bind(t,6785)),meta:{filename:"Simple-Vue-Tricks",title:"一些 Vue 的常用技巧",uuid:"4df5b80d-d849-5b2b-9943-bbe5c11da8cc",isStandalone:!1}},{name:"post-smalltalk",path:"Smalltalk",component:()=>t.e(708).then(t.bind(t,8708)),meta:{filename:"Smalltalk",title:"短期锐评",uuid:"d91574d9-1c38-5966-a62c-0371bf6ba588",isStandalone:!1}},{name:"post-social-darwin",path:"Social-Darwin",component:()=>t.e(39).then(t.bind(t,4039)),meta:{filename:"Social-Darwin",title:"生存与共情",uuid:"b5141c88-f381-5744-a7d3-ec8fafa54285",isStandalone:!1}},{name:"post-some-gossip-on-vercel",path:"Some-Gossip-on-Vercel",component:()=>t.e(847).then(t.bind(t,8847)),meta:{filename:"Some-Gossip-on-Vercel",title:"吐槽一下 Vercel 的大无语操作",uuid:"aba054e0-95c5-50ba-a3e0-fcfa56c8addf",isStandalone:!1}},{name:"post-something-about-something",path:"Something-About-Something",component:()=>t.e(848).then(t.bind(t,6848)),meta:{filename:"Something-About-Something",title:"对于疫情中我的电脑的一些感悟",uuid:"ab4c7cbc-d3ab-506b-9dc4-92065ee6fb16",isStandalone:!1}},{name:"post-terrible-computer-accident-caused-by-hdr",path:"Terrible-Computer-Accident-Caused-by-HDR",component:()=>t.e(228).then(t.bind(t,3228)),meta:{filename:"Terrible-Computer-Accident-Caused-by-HDR",title:"记一次手贱导致的电脑危机",uuid:"02cc3402-a831-5ddf-98e4-48166dba7f1d",isStandalone:!1}},{name:"post-the-clown-is-myself",path:"The-Clown-Is-Myself",component:()=>t.e(138).then(t.bind(t,2138)),meta:{filename:"The-Clown-Is-Myself",title:"Vue 前后端分离的正确方式",uuid:"50086278-4c4b-5ebf-a11c-f2942796bc6f",isStandalone:!1}},{name:"post-the-depression",path:"The-Depression",component:()=>t.e(915).then(t.bind(t,8915)),meta:{filename:"The-Depression",title:"过去的一切",uuid:"5de74c21-a639-5096-b916-a250f9d58575",isStandalone:!1}},{name:"post-the-institutionalization",path:"The-Institutionalization",component:()=>t.e(108).then(t.bind(t,2108)),meta:{filename:"The-Institutionalization",title:"体制外的人",uuid:"4666349a-3abc-559b-894b-5f3db5160f17",isStandalone:!1}},{name:"post-the-overinterpretation",path:"The-Overinterpretation",component:()=>t.e(164).then(t.bind(t,4164)),meta:{filename:"The-Overinterpretation",title:"过度解读",uuid:"a43eb907-7ba4-5687-8de9-fac15763cc73",isStandalone:!1}},{name:"post-thoughts-about-minecraft-server",path:"Thoughts-About-Minecraft-Server",component:()=>t.e(262).then(t.bind(t,8262)),meta:{filename:"Thoughts-About-Minecraft-Server",title:"对 Minecraft 服务器的一些想法",uuid:"bbe5d4e1-633d-5712-8e83-bb73a94d98cc",isStandalone:!1}},{name:"post-typical-crud",path:"Typical-CRUD",component:()=>t.e(325).then(t.bind(t,2325)),meta:{filename:"Typical-CRUD",title:"常用 CRUD 前后端架构",uuid:"1bbf2764-3db1-51b0-9479-dfddf2039270",isStandalone:!1}},{name:"post-unknown-mysql-issue",path:"Unknown-MySQL-Issue",component:()=>t.e(596).then(t.bind(t,596)),meta:{filename:"Unknown-MySQL-Issue",title:"记一次奇怪的 MySQL 错误解决",uuid:"cb8c8065-b828-55e2-8a67-e1129951d346",isStandalone:!1}},{name:"post-wen-1",path:"Wen-1",component:()=>t.e(16).then(t.bind(t,16)),meta:{filename:"Wen-1",title:"杂文集 2023.9-2023.10",uuid:"c6a2ce71-3879-580f-8ce9-9b40aeb6238d",isStandalone:!1}}]}],en=(0,l.p7)({history:(0,l.PO)(),routes:nn});var tn=en,an=JSON.parse('[{"name":"WindSpirit IT","href":"https://www.leviatan.cn/","avatar":"https://img.leviatan.cn/images/2023/10/22/cat2e4e9bd20b277dfe.md.png","description":"跟随互联网发展的每一步","background":"#262626","light":true},{"name":"Dream City","href":"https://www.littleqiu.net","avatar":"https://www.littleqiu.net/wp-content/uploads/2018/01/Avatar.png","description":"愿你有一天，能与你最重要的人重逢","background":"https://www.littleqiu.net/wp-content/uploads/2018/01/ChulillaSpain_ZH-CN10170248808_1920x1080.jpg","light":true},{"name":"Bottle 小站","href":"https://bottle.moe/","avatar":"https://cdn.jsdelivr.net/gh/BottleSome/blog@latest/avatar_square.png","description":"些瓶dalao的博客~","background":"rgb(102, 203, 254)"},{"name":"crazyman_army\'s Blog","href":"https://crazymanarmy.github.io/","avatar":"https://imgur.com/lsmKGQE.png","description":"玩ctf的小菜鸡,又喜欢捣鼓捣鼓一些realworld的东西","background":"#fff"},{"name":"Ojhdt\'s Blog","href":"https://blog.ojhdt.com","avatar":"https://www.gravatar.com/avatar/af6911b4de2f5a357fa796a66e202272?s=128","description":"隐约雷鸣，阴霾天空","background":"#009688","light":true},{"name":"9527\'s Blog","href":"https://9527dhx.top/","avatar":"https://i.loli.net/2019/05/26/5cea282e596b167848.png","description":"跌倒了，站起来，换个姿势，再跌倒。","background":"#80deea","light":true},{"name":"喵呜Moe!!!","href":"https://moe.jimmy0w0.me/","avatar":"https://fnmdp.oss-cn-beijing.aliyuncs.com/assets/jimmy.jpg","description":"日常的生活","background":"#fff"},{"name":"Socular 的博客","href":"https://awsl.rip","avatar":"https://www.gravatar.com/avatar/202e3e3a8e8fcefd140c1aab9b54c0d6","description":"少一点吹捧，多一点实干 :)","background":"#2196F3","light":true},{"name":"Carm\'s Pages","href":"https://pages.carm.cc","avatar":"https://en.gravatar.com/userimage/186254338/92ff64167a1c45e8b995200e992bcfdb.png","description":"分享所见，总结所学。","background":"#8b658b","light":true},{"name":"Nocturne","href":"https://wynio.online","avatar":"https://wynio.online/css/logo.png","description":"Ivory Tower","background":"#009999","light":true},{"name":"布丁の小窝","href":"https://www.furryowo.top/","avatar":"https://dn-qiniu-avatar.qbox.me/avatar/7da7e82f04de94c795db0301c3397bb6","description":"一个有梦想的咸鱼","background":"#2396FA","light":true}]');const on={class:"links-container"},rn=["onClick"],sn=["src","alt"],ln={class:"link-content"},cn={class:"name"},un={class:"description"};var dn=(0,i.aZ)({__name:"Blogroll",setup(n){return(n,e)=>((0,i.wg)(),(0,i.iD)("div",on,[((0,i.wg)(!0),(0,i.iD)(i.HY,null,(0,i.Ko)((0,o.SU)(an),(n=>((0,i.wg)(),(0,i.iD)("div",{onClick:e=>(0,o.SU)(s.Ah)(n.href),class:(0,r.C_)(["link",{light:n.light}]),style:(0,r.j5)({backgroundImage:n.background.startsWith("http")?`url(${n.background})`:"",backgroundColor:n.background.startsWith("rgb")||n.background.startsWith("#")?`${n.background}`:""})},[(0,i._)("img",{class:"avatar",src:n.avatar,alt:n.name},null,8,sn),(0,i._)("div",ln,[(0,i._)("span",cn,(0,r.zw)(n.name),1),(0,i._)("span",un,(0,r.zw)(n.description),1)])],14,rn)))),256))]))}});const pn=dn;var mn=pn;const fn={class:"example-link links-container"},hn=(0,i.uE)('<a target="_blank" href="https://subilan.win" class="link" style="background-color:black;"><img class="avatar" src="https://fnmdp.oss-cn-beijing.aliyuncs.com/assets/avatar.png" alt="avatar"><div style="color:white;" class="link-content"><span class="name">网站名称</span><span class="description">网站介绍</span></div></a>',1),gn=[hn];function bn(n,e){return(0,i.wg)(),(0,i.iD)("div",fn,gn)}const yn={},vn=(0,I.Z)(yn,[["render",bn]]);var wn=vn,Sn=t(530),kn=t.n(Sn);const Tn={style:{display:"inline-block"}};var xn=(0,i.aZ)({__name:"two-years-ago",setup(n){const e=new Date((new Date).getTime()-63072e6);return(n,t)=>((0,i.wg)(),(0,i.iD)("div",Tn,(0,r.zw)((0,o.SU)(e).toLocaleString()),1))}});const Cn=xn;var Mn=Cn;function In(n,e){return e.title?`${e.title} | Subilan's Blog`:"Subilan's Blog"}tn.beforeEach(((n,e,t)=>{window.document.title=In(n.path,n.meta),kn().start(),t()})),tn.afterEach((()=>{window.scrollTo({top:0}),kn().done()})),(0,a.ri)(Z).component("blogroll",mn).component("example-link",wn).component("two-years-ago",Mn).use(tn).mount("#app")},2339:function(n,e){const t=[{title:"关于",filename:"About"},{title:"友链",filename:"Blogroll"},{title:"联系",filename:"Contact"},{title:"公钥",filename:"PGP"}];e.Z=t},1476:function(n,e,t){t.d(e,{XY:function(){return p},K9:function(){return m},y5:function(){return u},UQ:function(){return l},Jq:function(){return s},on:function(){return c},t6:function(){return d},Ah:function(){return f}});const a=[{title:"吐槽一下 Vercel 的大无语操作",filename:"Some-Gossip-on-Vercel",frontmatters:{date:"2023/12/13",cate:"代码",desc:"好荒谬，就像经过精密数学计算以后算出来公交车上只有 1.5 个人那样荒谬💧"},wordcount:1554},{title:"生存与共情",filename:"Social-Darwin",frontmatters:{date:"2023/11/27",cate:"思想",desc:"生存条件和情绪或好或坏，似乎也不是决定一个人的生存需求是否强烈的决定性因素。人都有着生存的需求——可以是社会上的生存，也可以是生理上的生存。求生欲望过淡的人会脱离现实，而求生欲望过于强烈的人则显得难以共情。",hidden:!0},wordcount:1339},{title:"Swift 学习笔记（一）——A Swift Tour",filename:"Learning-Swift-1",frontmatters:{date:"2023/11/19",cate:"代码"},wordcount:7541},{title:"杂文集 2023.9-2023.10",filename:"Wen-1",frontmatters:{date:"2023/10/10",desc:"把它们写在一篇里面更好",cate:"思想",hidden:!0},wordcount:2431},{title:"重庆—成都游记（下）",filename:"Chongqing-Chengdu-Tour-2",frontmatters:{date:"2023/09/05",cate:"记录",desc:"无论是跋山涉水还是领略不同的人情，最终都是只为领略不变的自然。「自然是不变的」或许正是在遭受别扭或劳累以后对我唯一有效的宽慰。"},wordcount:6675},{title:"重庆—成都游记（上）",filename:"Chongqing-Chengdu-Tour-1",frontmatters:{date:"2023/07/29",cate:"记录",desc:"领略的不仅是风景，而是一种现状，一种岁月里的永恒。"},wordcount:7124},{title:"Menu 组件的基本处理和实现",filename:"Menu-Handling",frontmatters:{date:"2023/07/10",desc:"一些强迫症方面的考虑和最终的成功实现",cate:"代码"},wordcount:2366},{title:"Forge 开发日志（一）",filename:"Forge-development-diary",frontmatters:{hidden:!0,date:"2023/07/02",desc:"面向搜索编程",cate:"代码"},wordcount:1079},{title:"Barren Fungus",filename:"Barren-Fungus",frontmatters:{date:"2023/02/25",desc:"The Venezia lying in the dream.",cate:"思想",english:!0},wordcount:382},{title:"精神内耗文集",filename:"Semi-completed-Articles",frontmatters:{date:"2023/02/13",cate:"记录",desc:"精神内耗实在是太累了，以至于回过头来看也不清楚自己究竟说了些什么、想了些什么。但是我始终认为这是对的，也正是我想表达的。只是没那么有必要，入不敷出而已。"},wordcount:8424},{title:"一些 Vue 的常用技巧（续篇）",filename:"Simple-Vue-Tricks-2",frontmatters:{cate:"代码",desc:"本期热点：状态管理",date:"2023/01/26"},wordcount:464},{title:"常用 CRUD 前后端架构",filename:"Typical-CRUD",frontmatters:{date:"2023/01/26",cate:"代码",desc:"C！R！U！D！"},wordcount:1467},{title:"纵观烟火和习惯于向往美好以后我的变化",filename:"2022-Recall",frontmatters:{date:"2023/01/01",desc:"残暴的结局或许会是欢愉。",cate:"思想"},wordcount:747},{title:"行为伦理",filename:"Action-Ethnic",frontmatters:{date:"2022/10/01",desc:"另一种形式的自我毁灭。",cate:"思想"},wordcount:2273},{title:"自我宣言",filename:"Self",frontmatters:{hidden:!0,date:"2022/06/25",desc:"顺其自然的例外。"},wordcount:1631},{title:"一些 Vue 的常用技巧",filename:"Simple-Vue-Tricks",frontmatters:{date:"2022/06/08",desc:"再做类型体操我就是",cate:"代码"},wordcount:2064},{title:"短期锐评",filename:"Smalltalk",frontmatters:{date:"2022/03/18",cate:"思想",desc:"衍生剧"},wordcount:708},{title:"神农架游记",filename:"Shennongjia",frontmatters:{date:"2022/02/07",desc:"跨越 2.49 年，是不一样的感觉。",cate:"记录"},wordcount:2952},{title:"2021 总结",filename:"2021-Recall",frontmatters:{date:"2022/01/01",desc:"让我改变了很多的一年",cate:"思想"},wordcount:1324},{title:"体制外的人",filename:"The-Institutionalization",frontmatters:{date:"2021/12/19",desc:"是孤独也是勇敢的。",cate:"思想"},wordcount:2244},{title:"过去的一切",filename:"The-Depression",frontmatters:{desc:"如何才能真正掌控自己。",date:"2021/11/27",cate:"思想"},wordcount:2749},{title:"Bukkit 实现 MC 服务器里的 HTTP 服务器",filename:"Bukkit-Webserver-In-Minecraft",frontmatters:{date:"2021/10/23",desc:"也许是与服务器直接通讯的较好方式。",cate:"代码"},wordcount:1976},{title:"记一次奇怪的 MySQL 错误解决",filename:"Unknown-MySQL-Issue",frontmatters:{desc:"不知道原理，在线等解释。",date:"2021/08/06",cate:"记录"},wordcount:1025},{title:"我的 ADD",filename:"My-ADD",frontmatters:{date:"2021/08/02",desc:"解开了我一直以来疑惑不解的谜题。",cate:"思想"},wordcount:4396},{title:"过度解读",filename:"The-Overinterpretation",frontmatters:{date:"2021/07/30",desc:"即使是这样，观点也应该被尊重。",cate:"思想"},wordcount:3890},{title:"一个简单的初级登录系统",filename:"Simple-Authenticating-System",frontmatters:{date:"2021/05/20",desc:"抛弃近乎迷惑的 session。",cate:"代码"},wordcount:2060},{title:"Vue 前后端分离的正确方式",filename:"The-Clown-Is-Myself",frontmatters:{date:"2021/04/04",desc:"一直用着另一种方法。",cate:"路径"},wordcount:1132},{title:"对 Minecraft 服务器的一些想法",filename:"Thoughts-About-Minecraft-Server",frontmatters:{desc:"回顾虚无缥缈的从前。",date:"2021/02/17",cate:"思想"},wordcount:3433},{title:"记一次手贱导致的电脑危机",filename:"Terrible-Computer-Accident-Caused-by-HDR",frontmatters:{desc:"无语无语无语无语无语无语奉劝各位集美不要手贱打开 HDR（设备明显支持除外）！我现在看到这个按钮就心有余悸。",date:"2021/01/02",cate:"记录"},wordcount:1435},{title:"2020 年结束语",filename:"2020-Recall",frontmatters:{desc:"这一切，真的值得吗？",date:"2020/12/31",cate:"思想"},wordcount:760},{title:"Bukkit 实现对象池随机抽取和定时更新",filename:"Bukkit-Object-Pool-Picking-And-Updating",frontmatters:{desc:"555555原来 Bukkit 是个巨坑！",date:"2020/07/31",cate:"代码"},wordcount:4537},{title:"简单的投票系统实现（一）",filename:"Simple-Vote-Logic-1",frontmatters:{desc:"应该是有很多缺点才对。",date:"2020/05/13",cate:"代码"},wordcount:1895},{title:"对于包含日期数组的处理",filename:"Array-Date-and-Category",frontmatters:{desc:"难道没有更好的办法了吗？",date:"2020/04/24",cate:"代码"},wordcount:1635},{title:"对于疫情中我的电脑的一些感悟",filename:"Something-About-Something",frontmatters:{desc:"浪费了我太多的时间，让我无事可干。",date:"2020/03/06",cate:"思想"},wordcount:1396},{title:"Sponge 搭建 1.12.2 Mod + 插件服务器",filename:"Minecraft-Sponge-Server-Tutorial",frontmatters:{desc:"高版本 Mod 服又想加插件...？",date:"2020/01/02",cate:"路径"},wordcount:2179},{title:"使用 VuePress 搭建博客",filename:"Build-a-Blog-Using-VuePress",frontmatters:{desc:"这篇文章的发布也是在我预料之中哒！！",date:"2019/08/19",cate:"路径"},wordcount:1516},{title:"Hello World",filename:"Hello-World",frontmatters:{desc:"Hi. 欢迎来到我的博客！",date:"2019/08/17"},wordcount:412}];var i=a,o=t(2339),r=JSON.parse('[{"title":"2020 年结束语","filecontent":"desc: 这一切，真的值得吗？\\ndate: 2020/12/31\\ncate: 思想\\n2020 年结束语\\n\\n挺久没有写博客了，大多数是在底下写一些文章，都没有发出来。对于 2020 年来说，这一年给我的感觉并没有社会上所衬托得那么激烈，但影响却不只是一点。\\n\\n在这一年里，我结识了很多人，更加明白了自己是一名尘埃的意义；我接触了很多事，更加明白了自己作为灰尘存在的事实。挫折并不能把一切都说透，我也不以为然，对于好的事情留在心中当珍宝，不好的事情就随他去吧——因为到头来都只是些唇枪舌战，对我现实并没有太大的影响罢了，因为我有一颗强大的内心。\\n\\n那么，2020 年我究竟失去了什么，我究竟要挽回什么的问题，大概就已经得到了解决，只是不好在这里一一列出。但可以知道的是\\n\\n我的 Ryzen 7 3700X 仅购买不到 6 个月因为一次对主板的通电操作（按下电源键而已）导致目前处于生死未卜的状态，我只好封存。（2023 年这块 3700X 重新焕发生机！）\\n我的 DELL 不知道什么型号总之在 2K 中很贵的显示屏伴随着我的 Ryzen 7 3700X 而去，且不能予以保修——它的左下角被它自己烧了个洞，我也不知道为什么。（2023 年这个谜题仍然没有被解决！）\\n我的钱包一去不复返。\\n我的所有贡献第一次受到了质疑，但我相信智者并不少，因此心里也得到了一定的宽慰。\\n我终于把肖申克的救赎看完了！\\n很少再上 GitHub 主动贡献些什么了。\\n我更坚定了把 SoTap 做好的信心，但还没有投入到实践中。\\n\\n不好的事情，就让他跟这篇文章一起，永远地留在 2020 年。\\n\\n那么，2021 年有什么打算呢？\\n\\n首先是减肥。因为现在根据定期心率测定的结果来看，略有异常，但这也并不是我要减肥的直接原因。\\n其次是把精力投入到自己的主业上，以防范谗与讥。\\n写一个名为《入门手册》的电子书籍，以排解自己多年来的不爽为契机，科普一些当今时代需要知道的基础信息技术知识。\\n把 SoTap 的官网弄好。\\nA little bit of Rust (not seriously)\\n为将来的 2022 年做保证。\\n坚持更新至少 5 篇博客文章。\\n\\n那么，2020 年，再见了！","filename":"2020-Recall","namespace":"post"},{"title":"2021 总结","filecontent":"date: 2022/01/01\\ndesc: 让我改变了很多的一年\\ncate: 思想\\n2021 总结\\n\\n2021 年让我改变了很多，而且大多数都集中在后几个月。回顾一年前所写的「2020 年结束语」，发现自己充满了对生活的怨言。我并不觉得这是不合理的，只是过于将自己的真实想法显露出来，企图能够得到些许的共鸣或者接纳，然而终究也只是自娱自乐。\\n\\n2021 年里，我并没有太多的获取和失去，大多数却只是在心间徘徊，久而久之便忘却了。我开始承认人生是一次孤独之旅是不可否认的事实，聒噪的环境终究不能跟渴望自由的内心相提并论。\\n\\n接下来概括一下 2021 年里对于 2020 年总结里提出的希望产生的变化：\\n我退出了 SoTap，并且不再将重心放在 Minecraft 上了。并不是热情淡了，而是感觉自己还需要努力和提升\\n《入门手册》没能编写，初来的几张就已经能感受到「劝说社会中的人去懂技术」有多么困难\\n减肥变成了玄学——想方设法地减却没有效果，无所谓地狂吃却 7 天瘦 8 斤。\\nSoTap 的官网写的很成功，也上线使用了，后来随着我的退出也下线了\\nRust 并没有施展，因为找不到可以写的领域\\n\\n2021 年里，我的思想发生的改变：\\n我从认为「孤独是被社会不接受的可悲外化」转向为「孤独是人类在社会中存在形式的本质」。我开始认为人类存在的意义在于为自己争取利益（关于这个思想的详细解释，请查看文末的注释）\\n我发现自己的大多数负面情绪都来自自己，且大多数是自己对自己的责怪和怀疑，这样不好\\n我发现每一个人都有自己的个性，任何关系都不会依照自己的意思来发展\\n我发现了更多存在于周边环境和所处社会环境的矛盾，同时我也想出了对它们的批判性概括。实践上来说，我会避免成为类似的环境产物\\n我发现自己是唯物主义者，一种即使不纯粹也十分想要追求纯粹的唯物主义\\n我拒绝任何没有原因而诞生的事物或者思想对我造成影响，排斥任何没有意义的规则观和约束\\n\\n至于 2021 年里具体经历的事情，貌似并没有什么值得提及的。\\n\\n对于 2022 年的打算，就不说太多了\\n让自己开心起来，增加自己的开心来源\\n不以达到他人的目的为目的，不以获取他人的目光为目的，不以不实际的一切为依据\\n做出一点稍微有用点的东西\\n希望自己不会受到他人语言过多的感性层面影响\\n更新至少 5 篇博客文章\\n达到自己想要的成就\\n\\n虽然说我抗拒仪式感的东西，但是还是要在这里说一句\\n\\n你好，2022！\\n\\n注释：关于人类存在的意义在于为自己争取利益\\n\\n我认为，人的存在需要一个确切的目的，才能让人生具有意义。而这个目的具有统一性。不加修饰地说出来，就是「为自己争取利益」。在这里，利益并不是单指物质上的财富，而是指一切你认为对你有价值的东西。即人类存在的目的应当是追求于己有价值的东西。这可以是为他人奉献（如果你以此为乐的话），也可以是活在自己的世界里（如果你以此为乐的话），但总之，始终不是违背自己的意愿的。因而这句话更为精确地表述应该是，人应该为了自己的意愿而活着，这是我所信奉的观点。从这个观点出发，我认为没有什么是绝对高尚或者正义的；人在精神上是孤独的；对一个人的价值的评价没有意义。\\n\\n但要避免曲解。正确的理解是，人在一生中的所有具体目的和决策都应该基于自己的意愿和对外界环境的影响的衡量，不能认为万事万物都要依照自己的意愿前进，否则就不算如愿。我们每个人都需要在「变得自我」和「融入社会」之间衡量，要确保不违反任何社会规则，这是人在成长中所需要思考的话题。\\n\\n我认为人应当避免成为傀儡，即不知道自己究竟要追求什么，而只是在他人的闲言碎语下拼凑自己人生的意义，思想上完全受他人的指使，没有形成真正属于自己的价值观。是非观模糊就是一个典型的例子，这是因为总是在参照外部对事物的评价方式对事物进行评价，而没有形成属于自己的评价方式和是非观，很难在自我利益和事物对错判断之间找到符合逻辑的通路。\\n","filename":"2021-Recall","namespace":"post"},{"title":"纵观烟火和习惯于向往美好以后我的变化","filecontent":"date: 2023/01/01\\ndesc: 残暴的结局或许会是欢愉。\\ncate: 思想\\n纵观烟火和习惯于向往美好以后我的变化\\n\\n时间快到每一次经历这样的总结之时都让我不由得发出感叹。\\n\\n值得注意的是，从最初写这一个版本的博客（2019 年）开始，几乎每一年我的心理变化都是巨大的，或许对于有些人来说并非如此。2022 年无疑是近些年来变化最大的一年，而到来的 2023 年则很有可能是我真正脱离苦海的一年。\\n\\n我并不能向自己保证，如此抽象的一个「新的开始」真的可以作为自我完全刷新的契机。我一直都在极力避免自己失望，所以也一直不敢给自己类似的承诺，毕竟已经失败了太多次。\\n\\n从前的我敏感又怯懦，矫情又造作，借助于治疗，我一直在改变，在变得难以伤害，变得更加勇于重拳出击，更重要的是，变得更加自我，也更加专注于自己的利益。\\n\\n2022 年的 5 月，本身是为了解决我类似 ADD 的症状，在饱受类似于“ADD 不是小孩子得的病吗？”之类的怀疑下，前往医院准备咨询。谁知和医生聊经历的时候，聊着聊着就哭了起来，结果医生让我去做了些测试，诊断出重度抑郁。\\n\\n其实抑郁就像计算机，人多了以后，无论是好是坏，都变得极为廉价，不值得一提。我想这是好事，但在某种程度上又让我无比惋惜。对于二者都是这样。\\n\\n在吃药以后，虽然我没有察觉我的行为有多少明显的诡异，但又感觉无论是在心理上还是行动上有了变化。这让我感觉每个日子都过得轻飘飘的，宛如浮在天空中。\\n\\n即使是这样，我也能天天看到整日视乐色为珍宝的人，以出乎意料的自我封闭能力，贬低他人的同时增加自己的锐气，在此不过多赘述。\\n\\n只想说这些苦痛折磨，也许这一生也就只有这一段时间有吧。2023 年，我终于迎来了摆脱的机会。\\n\\n烟火即将熄灭之时，我感到无比的庆幸。2023 年的到来，或许是最近些年最好的喜讯。2023 年或许并不会如我所期望的那样完美，却在客观事实上已经注定了我与痛苦之间的距离——终将变为九霄云外的往事。\\n","filename":"2022-Recall","namespace":"post"},{"title":"行为伦理","filecontent":"date: 2022/10/01\\ndesc: 另一种形式的自我毁灭。\\ncate: 思想\\n行为伦理\\n\\n过去的资本主义世界，尤其是当时工业化的欧洲，最终并没有如马克思与恩格斯的理论所预料的那样发生社会主义革命。意大利共产党创始人之一 Gramsci 注意到了这一点，认为工人之所以失去了反抗力，是因为在某种因素的潜移默化中形成了虚假的意识。针对这一现象，他总结并提出了文化霸权理论（egemonia curtuale, cultural hegemony）。\\n\\n对于文化霸权理论，其具体表现形式，在英文维基百科上被概括为：\\nIn Marxist philosophy, cultural hegemony is the dominance of a culturally diverse society by the ruling class who manipulate the culture of that society—the beliefs and explanations, perceptions, values, and mores—so that the worldview of the ruling class becomes the accepted cultural norm. As the universal dominant ideology, the ruling-class worldview misrepresents the social, political, and economic status quo as natural, inevitable, and perpetual social conditions that benefit every social class, rather than as artificial social constructs that benefit only the ruling class.\\n\\n意译译文：\\n在马克思主义哲学中，文化霸权是指，统治阶级控制具有文化多样性的社会的文化（包括信仰、解释、认知、价值观等），使得统治阶级的世界观成为被广泛认可的社会规范。统治阶级将他们的世界观定为社会中普遍且首要的意识形态，并将其造成的社会、政治、经济情况解释为一种自然、必然、会长久持续下去的社会状况，而且可以使各个阶级都受益，然而实际上这只是为了使统治阶级受益而进行的蓄意行为。\\n\\n即使后世有人对这一理论进行批判，认定其似乎将统治阶级摆放在一个过于决定性的位置，忽视了其它不同势力（不一定是阶级）之间显然也存在的斗争，但是依照历史来解读，这一理论似乎在现实中具备完全意义上的可行性。\\n\\n在本篇文章中所要详尽探讨的并非文化霸权，笔者亦认为没有探讨的必要；实际上以上只是对本文所要阐述的具体现象的一个引子。\\n\\n归因行为所遇到的难题\\n\\n道德哲学不可能有统一的结论。这句话好似废话，正如「人与人有不同的观点」。人们在意识形态方面思想差异的形成不是一天两天的事情，似乎也具有一定的必然性；而令我百思不得其解的是，究竟是什么促成了针对这方面思想的一种莫名崇拜，以至于在未深刻感知甚至了解时就已经陶醉其中。\\n\\n在这样的情况下对一个人与这样的思想有关的行为进行归因，似乎会有许多矛盾发生。如果认定是由于类似于文化霸权的「思想渗透」，难免也太不负责任，因为实际上这种思想是对意识形态极为粗糙的主观感知，完全不能代表意识形态本身，更不能代表其实际影响，因为这样的主观感知在人群中没有统一性可言；而如果认定只是因为主观感知而进行的自我感动，或者类似民族主义，似乎也轻视了这一主观感知对象的作用——如此大的感染力，使得人愿意哪怕以最粗糙的主观感知去相信。\\n\\n上述似乎概括了归因它所遇到的两大难题，但不幸的是，一些极端的例子（见下文）指出人的主观感知水平只能维持在这里所指的「最粗糙」的程度，所以这些行为的形成在某种程度上又是一种对其必然性的利用。\\n\\n标准\\n\\n「西方个人主义是否在侵蚀我国 00 后一代？」\\n\\n这是一个知乎上的问题。其中一篇回答认为，当标准飘忽不定时，一切讨论的结果会被最终的解释所掩盖，因而许多问题都是没有意义的。这是很浅显的道理，却也显得振聋发聩。\\n\\n其中的一段话是：\\n什么是00后？是指广义上出生于公元2000年以后的一代人？还是他们中含着金钥匙出生，享受着顶级资源的那一部分？还是面对社会现实茫然无措，上不来下不去的那部分？还是买不起学区房，请不起家教，走不通关系，最后被分流到中职的那一部分人？还是毕业即失业，但因从未就业，不被算作失业人群，无法领取失业保险的那一部分人？还是即使知道房地产前景黯淡，但依然为了有个安身立命的所在，掏空家底，背上负债的那批人？\\n\\n实际上，在我们日常的闲谈亦或者宏大叙事中，很容易提到某一代人的概念，但直到现在，我都没有彻底想通，这样的陈述究竟是在针对这一代人表达什么。\\n\\n也许早先人们发现一群人的共同特征后，会将称他们为一个统一的名字；而当这样的人在各地普遍存在时，这一统一的名字就正式成为了一个不统一的概念。\\n\\n闲谈之中的模糊指代不负责任很正常，也许只是当地的事情，却可能被发言积极分子映射到所有人，但显然没人在意或影响不大；而当这样的模糊进入了文章中，甚至作为了具体的抨击对象，就显得有些不伦不类了。\\n\\n除此之外，还有许多种界定不清，可以阅读这篇回答了解。\\n\\n这种现象的存在，似乎也是一种必然，因为人们显然没有时间去了解这些概念的具体定义，并且对这些定义做出合理的选择和注释，从而提出严谨的问题。在这里又得出了一个问题：\\n\\n究竟是什么让人们愿意在自己对概念与现象了解不清晰甚至错误时，使用许多自己了解不甚清楚的词汇去构造一个确是传达了某种观念却又模糊不清的问题呢？\\n\\n答案也许是：去证明自己思想观念的正确性。这就好比当你做对了一道很难很难的数学题目，就迫不及待想要和同伴分享一样。自己也许对问题的了解不甚深入，却完全可以以这样日常闲谈的风格发出，引起许多人的长篇大论，各执一词。\\n\\n但就跟「为什么」骗局一样，许多时候在为什么之后所跟的并不是事实，却往往就这样被误导为事实。\\n\\n依我看来，若是把这样的问题当成真正的问题，哪怕最为精辟的论述恐怕也会成为无的放矢的笑谈。所以专注的学者和理性的观众往往对其嗤之以鼻，只是大概率无法被看到。\\n\\n总地来说，当今许多媒体上，无论是由官方还是个人所发布的言论，相当大的一部分充斥着模糊不清的语言和概念，却依然能够被一部分人接受，一部分人反驳，好比是在针对假命题反复斟酌，最终得出「这一命题部分错误」的结论。\\n\\n这是互联网信息爆炸的必然结果，群体对精准定义的弱化也是不求严格表达的媒体存在的基石。闲谈也是一样的道理，没有营养，但有快感，大家都喜欢。\\n\\n自我机械化\\n\\n闲谈有什么错？闲谈没有错。\\n\\n然而有许多思想不完备之人，急于用滥调填补自己思想任务的空缺。\\n\\n无论是出于某种信仰，还是自幼的熏陶，这样的人往往赋予了自己某种思想任务，需要通过不断主动地对上文所提及的「闲谈」式碎片化知识进行主观的吸收，从而作为某种填充物填充内心里因思想任务而形成的空缺。\\n\\n而这份空缺的填满，就能增进自己对于身处某一集体的认同。\\n\\n当过分地吸收碎片化消息，不加以反思、查证或者整理（这三者均属于泛指，并非学习的行为）时，思维很容易形成一种「应当及时将其应用」的错觉。久而久之，这或将成为你评判事物的固定标准。而且可以推断，越是囿于这一标准，越是容易接受与之类似的信息，最终形成极其单一的价值观。但可笑的是，它们都不来源于自己。\\n\\n此即自我机械化，并非任何外界主体的作用，而是个人主动地被媒体环境塑造。\\n\\n保持一个清醒、独立思考的头脑十分重要。它是个人观点形成的基础。若是被碎片化信息侵蚀，很难摆脱。笔者认为，长此以往，即使是最终凭借自己的经验去思考问题，也难以脱离碎片化信息长期造成的思维框架；甚至许多人从此认定碎片化信息塑造的框架就是唯一正确的，只因它与其所在的集体思想不谋而合。\\n\\n行为伦理\\n\\n什么是行为伦理？因不明原因所形成的对行为道德的界定行为。一个直到现在还是有争议的问题：同性恋是否合理？可以有以下几种解释：\\n\\n唯物唯心主义**：普遍见到的动植物都需要雌雄结合才能繁衍后代；生物存活的目的就是繁衍后代；同性恋违背了自然界的法则。\\n唯心唯物主义 1**：同性恋是一种心理疾病，经过治疗以后应该就能好；所有的同性恋应该接受这样的治疗，从而回归正常的生活。\\n唯心唯物主义 2.1**：同性恋会导致艾滋病等性病的大范围传播，对社会有负面影响，且最开始的艾滋病和某些性病就是由人不正常的性偏好所导致的。\\n唯心唯物主义 2.2**：同性恋是艾滋病等性病的大范围传播的原因，对社会有负面影响，且最开始的艾滋病和某些性病就是由人不正常的性偏好所导致的。\\n完全唯心主义**：同性恋就是变态；看到同性恋就是反胃；这是本能反应，没有为什么。\\n理想主义**：人人都是平等的，都具有爱自己爱的人的权利；人人都可以为自己的爱而抗争；这样的抗争是必要且值得的。\\n极端主义**：同性恋应该都去死。\\n神秘主义**：与我无关；不支持；不反对。\\n\\n\\n如此繁多的解释使得一个问题具有巨大的讨论空间。一个人若是处于理想的思想状态，针对上述所有的解释，大都可以推断出其形成原因，是为换位思考，而并不会产生对于某一种较为强烈的排斥情绪，但也不会改变自己的立场；而若是处于自我机械化的思想状态，那么利用单一的价值标准，就会极力的排斥其它观点，对其他观点感到极为不适。\\n\\n那么当或健康或歪曲的价值标准被应用到行为伦理的领域中时，就会产生人与人之间思想以外的碰撞。对同性恋的抵抗或者支持也属于这一范围。\\n\\n总结\\n\\n最初写这篇文章的动机在于了解到这样的人的存在以后，内心无法填补的疑惑。将这篇文章作为这类人的纪念。\\n\\n同时，往往这样的人用陈词滥调彰显自己在这方面不明含义的「博学」气质的时候，显露出前所未有的自恋嘴脸，同时却看不起那些明面上表达自己与众不同观点的人（以积极的方式），认为他们才是「自恋」，批判起来也是滔滔不绝。因而在我看来，这样的行为根本不能算作是过度的自我规训，反倒是一种彻头彻尾的虚伪，是应该被唾弃的。\\n\\n: 是阿根廷政治哲学家 Ernesto Laclau 和比利时政治哲学家 Chantal Mouffe，二者都是后马克思主义的代表人物。\\n: 此概念读完本文可清晰。\\n\\n","filename":"Action-Ethnic","namespace":"post"},{"title":"对于包含日期数组的处理","filecontent":"desc: 难道没有更好的办法了吗？\\ndate: 2020/04/24\\ncate: 代码\\n对于包含日期数组的处理\\n\\n由于最近业余开发了一个时间轴的程序（但这个程序的主体不是时间轴），将不同的事件按照时间点记录下来，并仿照  的样式从上到下排列下来。由于是第一次做这方面的东西，遇到了很多问题，也收获了一些经验，在这里分享一下。\\n\\n时间线简介\\n\\n我们首先约定，时间轴上存在个体的基本单位叫「事件」。例如今天 2020/04/24 12:30:30 发生了事件 A，那么我们就把它记录下来；当今天 2020/04/24 13:59:59 又发生了事件 B，我们也把它记录下来。直到最后在时间轴上显示出来。\\n\\n为了叙述方便，我们首先看看时间轴到底长什么样：\\n\\n\\n\\nGitHub 昨天晚上又崩了啊啊啊啊啊啊啊啊\\n\\n这就是时间轴，发生在同一天的事件会被归类到这一天下，然后再根据时间点分别排列事件的内容。然后针对之前的每一天，就像这样排列着\\n\\n\\n\\n这样便可以准确地反映一个轴的概念——左侧是一个代表「轴」的竖线，上面穿插着日期，每一天都有记录。如果这一天发生了什么事情，就把具体的时间点（时、分、秒）记录下来，然后将这个事件的具体内容表示出来。\\n\\n记录时间与写入数据库\\n\\n接下来说说如何记录时间。其实很简单，在插入数据库的时候生成时间就好了。为了方便，我们生成的时间是可以被应用到 JavaScript 的 Date 对象的。格式大概如下：\\n\\nip\\n:snake: 以下语句来自 Python 语言。\\n:::\\n\\nimport time\\n\\n...\\n\\ndate = time.strftime(\\"%Y-%m-%d %H:%M:%S\\", time.localtime())\\n\\n那么此时我们的数据库里应该记录了这个事件的内容和时间，但似乎还缺点什么。那就是自增键。对于任何一个可以无限扩大的数据集合，我们都要想办法把它们编号。因为除了 ID 以外没有更好更简单的方式来确定某一条数据的身份（仅限当前讨论范围内）。现在我们的表结构可以这样表示\\n\\nCREATE TABLE Events (\\n    id int unsigned NOT NULL AUTO_INCREMENT,\\n    title varchar(50) NOT NULL,\\n    contents text NOT NULL,\\n    date varchar(20) NOT NULL,\\n    PRIMARY KEY (id)\\n) CHARSET=utf8mb4;\\n\\n可以看到，我们将事件的内容分为了两个部分，title 和 contents；然后我们确定了一个自增键 id 用于给每条数据一个特殊的标识；最后就是记录这篇发布的日期。至此，我们就大概完成了数据的写入部分，实际操作起来按照一般逻辑即可。\\n\\n获取数据和数组结构\\n\\n获取数据时，我们会出现一些疑问。如果我们直接获取这些数据库里面的数据，很有可能得到下面的这个数组：\\n\\n[\\n    {\\n        id: 1,\\n        title: \\"example1\\",\\n        contents: \\"example1-content\\",\\n        date: \\"2020/05/01 21:38:29\\"\\n    },\\n    {\\n        id: 2,\\n        title: \\"example2\\",\\n        contents: \\"example2-content\\",\\n        date: \\"2020/05/01 22:59:30\\"\\n    }\\n]\\n\\n如果这个时候直接拿到前端去渲染，一定会出现很多问题。因为这个数组里的每个对象都是独立的，但是它们的时间却又有可能处于同一天。我们的目的是将同一天的两个事件合并，然后再根据具体的时分秒在当天进行排序。如何合并？这就需要对数组采取一定的操作。\\n\\n我们首先需要想象出一个结构，来很好地处理这样一个需求。我们的需求是，忽略事件，当日期重复时，对其进行合并。究竟如何合并呢？这个时候我们的第一步是找到这些数据的共性。比如，目前为止我们能找到的共性只有日期这一个。当我们添加更多内容时，就有可能产生更多的共性。接下来仅围绕 date 这一个共性来讨论。\\n\\n既然有了共性，说明这些数据包含可以分享的部分，那么我们很容易得到如下结构\\n\\n[\\n    {\\n        date: \\"2020/05/01\\",\\n        events: [\\n            {\\n                id: 1,\\n                title: \\"example1\\",\\n                contents: \\"example1-content\\",\\n                time: \\"21:38:29\\"\\n            },\\n            {\\n                id: 2,\\n                title: \\"example2\\",\\n                contents: \\"example2-content\\",\\n                time: \\"22:59:30\\"\\n            }\\n        ]\\n    }\\n]\\n\\n这些处于同一天的数据被分类在一个对象的属性里，它们的 date 属性被拆分为了两个部分，date.split(\\" \\")[0] 作为日期被放在了「公共区」，date.split(\\" \\")[1] 则作为具体的事件被存储到每个独立的事件里。\\n\\n这个结构就可以被前端很好地处理，只需要进行两次遍历。例如在 Vue 中\\n\\n            {{ k.date }}\\n\\n            {{ a.title }}\\n            {{ a.time }}\\n            {{ a.id }}\\n\\n                {{ a.contents }}\\n\\n\\n仅供思路参考，实际使用需要额外处理\\n\\n那么又引出了一个问题，该如何把上面的数组变成我们想象的那个样子呢？\\n\\n数组的处理\\n\\nip\\n☕📔 以下语句来自 JavaScript 语言\\n:::\\n\\n数组的处理环节是最让人头疼的。我们先把完整的代码放出来，再一行行解释。\\n\\nfunction createArray(data) {\\n    let arr = [];\\n    data.forEach((k, i) => {\\n        let ix = -1;\\n        let d = k.date.split(\\" \\");\\n        let date = d[0];\\n        let time = d[1];\\n        let sameDay = arr.some((r, j) => {\\n            if (date === r.date.split(\\" \\")[0]) {\\n                ix = j;\\n                return true;\\n            }\\n            return false;\\n        });\\n        if (!sameDay) {\\n            arr.push({\\n                date: date,\\n                events: [\\n                    {\\n                        id: k.id,\\n                        title: k.title,\\n                        contents: k.contents,\\n                        time: time,\\n                    },\\n                ],\\n            });\\n        } else {\\n            arr[ix].events.push({\\n                id: k.id,\\n                title: k.title,\\n                contents: k.contents,\\n                time: time,\\n            });\\n        }\\n    });\\n    return arr;\\n}\\n首先我们新声明一个数组 let arr = []，然后将数据中的日期分割 k.date.split(\\" \\")。后面用到了很重要的一点，Array.prototype.some 函数。这个函数用于判断是否通过了回调函数中指定的测试，返回一个布尔值。在这里我们手动在回调函数里加上了一行，ix = j，用于记录日期相同的对象所在的位置。\\n\\nsome 函数返回的布尔值被记录在 sameDay 这个变量中，如果为 true 就代表在同一天。下方判断 if (!sameDay)，如果通过，就会在新声明的数组里初始化一个结构——\\n\\narr.push({\\n    date: date,\\n    events: [\\n        {\\n            id: k.id,\\n            title: k.title,\\n            contents: k.contents,\\n            time: time,\\n        },\\n    ],\\n});\\n\\n这个结构记录一个日期和一个 events 属性，如果有和这个日期重复的 event，就会被拆分后 push 到里面（依据 ix 来寻址）：\\n\\n arr[ix].events.push({\\n    id: k.id,\\n    title: k.title,\\n    contents: k.contents,\\n    time: time,\\n});\\n\\n实际运行效果如下：\\n\\n\\n\\n这个函数实际上显得比较复杂，如果有更好的办法，欢迎联系我交流。\\n","filename":"Array-Date-and-Category","namespace":"post"},{"title":"Barren Fungus","filecontent":"date: 2023/02/25\\ndesc: The Venezia lying in the dream.\\ncate: 思想\\nenglish: true\\nBarren Fungus\\n\\nBarren Fungus has lost all acquaintance with himself. He used to consider himself a dynamic person. With season, circumstances, wealth, job... and even food changing, he kept changing and finally become someone else, totally. This, can be one of the most mysterious problems he has ever met in his life. That makes him unique in the river flow of the time.\\n\\nBarren\' memories are always totally and seemingly missing. Somehow, what he thought to be real can only be real in the reality he could never reach, where he could find some satisfying reality while other parts of it unsustainably remain. This won\'t be a pity if never be told, though.\\n\\nThe darkness of cloud with the rest of sunshine lit up mountains in a weird way. Barren fell in love with the scene, where sadness and hope seemed to be equal, equal and equal, just like being half burning in a winter biting cold.\\n\\nCold air, green trees, dark sky. Wonderful. Thousands of slim segments were infiltrating Barren\'s skin. Something primitive, inevitable and... familiar filled him up.\\n\\nOnly the river flows, the wind blows. The sky is eternal, the mountains are perpetual.\\n\\nBarren could see things inside, clearly.\\n\\nThe river. It\'s just, water, right?\\n\\nThe river never stops. He couldn\'t tell if some sound came from his beating heart, hollow mind or just the god hidding in the sky, where the sun was still shining. The fresh and sweet scent of tea leaves came just like comfort which was either futile or perfunctory during one\'s depression, or just the Thorns of Goodwill that comes to stab you unintentionally only when you are deperately not in desperated need of them.\\n\\nThe sunshine came after the rain was just wonderful. Blue gray mixed with gold.\\nI can\'t \'normally\' stand the change, just like I can\'t stand changing the change to be changed by someone else.\\n\\nTruth be told, no one can understand his disappointment, at least for now. Ridiculousness was always on a par with tommyrot. How could Barren stick to his bottom line while fix it to some point so as to be invulnerable when under attack on such trivia and nothing?","filename":"Barren-Fungus","namespace":"post"},{"title":"使用 VuePress 搭建博客","filecontent":"desc: 这篇文章的发布也是在我预料之中哒！！\\ndate: 2019/08/19\\ncate: 路径\\n使用 VuePress 搭建博客\\n前排提醒: 你也许需要一定的前端基础（非传统前端）才能读懂此篇文章的内容。\\n\\n我认为 Vue 的生态是有够好的了——有 Router，有 Vuex，还有更多，都是非常有用处的。其中就包含 VuePress，原本是尤雨溪先生用来提高写文档效率而写的一个小作品，现在被发展后可以用作电子书/教程编写和博客的编写。本篇文章介绍的是后者，实际上两者是相通的。\\n\\n流程\\n\\nVuePress 与其它静态博客软件的发布流程基本一样——写完文章后 build 成为静态文件。所以如果是 Hexo 或者 Hugo 用户看到这篇文章中的流程也许会感觉很熟悉，不过这里还是提到一下。\\n\\n也正因为是静态文件，所以可以使用 GitHub 托管——当然也可以使用你自己的主机，仅需将网站根目录设置为 build 产生的静态文件的目录即可。这会在下文中提到。\\n\\n安装\\n\\n首先选择一个你想要用来作为博客源代码放置之处的文件夹，下文中如果没有特殊声明，所有的文件、目录均指创建在此文件夹里。\\n\\n通过 npm 和 yarn 均可安装。本文主要使用 npm。\\n\\nnpm install -D vuepress\\n或者 yarn add -D vuepress\\n\\n需要注意的一点是，这种方式是以本地依赖（dependencies）的形式安装 VuePress，它会在当前目录生成一个 node_modules 文件夹并自动安装 JavaScript、Vue 等所需要的依赖。\\n\\n在本文后面出现的指令均无法以 vuepress 开头，因为 VuePress 没有被全局安装。\\n\\n安装完成之后，就可以开始搭建了。\\n\\n搭建\\n\\n个人还是建议将你的博客的源代码托管到 GitHub 上，哪怕私有也好。当然，你也可以选择部署到自己的 Git 服务器上。这样做就有这些好处\\n\\n一个算是比较简单的双重备份吧，当你的数据消失后，可以通过 Git Log 找到；\\n一些插件需要通过 Git 的提交日志获得你提交某篇文章的具体时刻，然后才能够显示日期或者 XX ago。\\n\\n那么首先我们创建一个专门放置「文章」的目录（区分于「独立页面」，这样做可以避免混淆），名称可以自取，例如 archives、articles、posts、docs 等均可表达这个意思，也是传统博客程序中常用的。\\n\\nmkdir posts\\ncd posts\\n\\n然后就可以在这个文件夹里进行写作了，写作仅需在此文件夹里建立不同的 Markdown 文件，VuePress 会自动识别到你的文章。\\n\\nVuePress 的写作使用 Markdown 文件进行，路由会自动将你的 Markdown 文件名称在实际 production 中转换成文件名 + .html 的形式。\\n\\n例如 docs/Hello-World.md 将会被转化为 docs/Hello-World.html，而在根目录的 Hello.md 将会被转化为 Hello.html，这也是为什么需要专门创建一个文件夹用来放置文章的原因，根目录里只需要放置独立页面即可，这样从路由层面看来会更加友好。\\n\\n到目前为止，你的博客目录应该为这个样子\\n\\n.\\n├─package-lock.json\\n├─package.json\\n├─node_modules\\n└─posts\\n\\n写作与发布\\n\\n如果你的环境已经搭建完毕，那么你可以选择在纯 Markdown 下进行写作，然后直接 push 到你的仓库中去。\\n\\n而如果你想要实时预览自己的文章在博客上的样子，或者调试一些应用层面的东西，你就需要启动开发服务器。\\n\\n与 Vue 的开发服务器相同，VuePress 的服务器也是支持热重载的。\\n\\n如果之前 npm install 为全局安装\\nnpm install -D -g vuepress\\nvuepress dev .\\n如果之前 npm install 是以本地依赖安装\\nnpm install -D vuepress\\nnpx vuepress dev .\\n\\n这样，在默认情况下会在  开放你的开发服务器，访问即可看到你的网站。\\n\\n最后，写完了就可以进行构建了——将你的网站样式和内容编译成静态网页。\\n\\nvuepress build .\\nor\\nnpx vuepress build .\\n\\n默认情况下这个静态网页会被保存到 .vuepress/dist 内，在后文会介绍修改方法。\\n\\n配置、主题、插件\\n\\nVuePress 之所以适合开发者，是因为它可以通过配置、主题和插件三方面高程度个性化——当然，是在你会 Vue 而且会看 VuePress 的 API 的前提下。\\n\\nVuePress 的配置文件存储在 .vuepress 里，一般情况下是没有这个文件夹的，我们可以自己创建。\\n\\n进入后，创建 config.js，这就是 VuePress 的配置文件。\\n\\nconfig.js 在写入一个语句之后即可当作一般的 JSON 文件来使用——它比 JSON 要宽松得多。\\n\\nmodule.export = {\\n    title: \\"Subilan\'s Blog\\",\\n    // ...\\n}\\n\\n具体配置项目可以参考 VuePress 官方文档的配置\\n\\n要切换主题，首先使用 npm 安装你想要的主题，比如\\n\\nnpm install vuepress-theme-example --save-dev\\nyarn add vuepress-theme-example --dev\\n\\n然后在 config.js 里添加一行\\n\\nmodule.export = {\\n    // ...\\n    theme: \\"example\\",\\n}\\n\\n即可。\\n\\n在这里需要注意的一点是，VuePress 的所有主题、Plugin，根据官方的建议，均是以 vuepress-theme- 和 vuepress-plugin- 开头。也正因此，安装以他们开头的主题或插件，在填写的时候则可以省略 vuepress-theme- 这样的开头。当然，这只是一般情况，具体请以你所看到的主题或插件为准。\\n\\n关于 VuePress 原版主题的相关配置可以看官方文档的默认主题。\\n\\n参考\\n\\n这是阅读完文章后，我个人推荐去参考的一些文档，以及一些可能需要的插件。\\n\\nconfig.js 里完整的配置项有多少、哪些，有何作用？\\nGoogle 搜索 VuePress 的主题\\nmeteorlxy/awesome-vuepress - 丰富的 VuePress 周边生态推荐\\nvuejs/vuepress/packages/@vuepress - VuePress 官方开发的插件\\nvuepress-plugin-mathjax - 在你的博客里写 $\\\\LaTeX$ 公式。\\nvuepress-plugin-last-updated - 根据 Git Log 显示文章最后修改时间\\nvuepress-plugin-pwa - 将你的博客变成具有 PWA 性质的 Web App\\nSubilan/Blog - 本博客的 GitHub 仓库\\n","filename":"Build-a-Blog-Using-VuePress","namespace":"post"},{"title":"Bukkit 实现对象池随机抽取和定时更新","filecontent":"desc: 555555原来 Bukkit 是个巨坑！\\ndate: 2020/07/31\\ncate: 代码\\nBukkit 实现对象池随机抽取和定时更新\\n\\nip 前置说明\\n\\n标题中的「对象池」并不是什么新的、高深的名词，而是代表一个「包含了一系列物体」的池。例如卡池、任务池。只有在池存在的情况下，才会有「抽取」这样的操作。为了叙述方便，本文将对象设定为「任务」，围绕一个任务插件来展开讨论。\\n:::\\n\\n最近入手了一个新的 Bukkit 项目，MissionTap。由于我还是一个 Bukkit 萌新，所以要时刻写文章来反馈给自己进度，以及水一些内容。在这篇文章里，大概从两个方面进行叙述：\\n\\n从池中抽取对象，并独立存储在另一个位置。\\n设计一种模式以便对对象定时刷新。\\n\\n要理解为什么要这样做，我们需要先了解一些背景。\\n\\n这个插件的用途，是根据池的内容，定时随机抽取一部分作为任务发放给玩家，其中这些任务的个数均为定值。任务可以分为每日任务、每周任务两种，每日任务需要每日刷新，每周任务需要每周刷新。当然，上述只是针对该项目的需求，实际上在阅读完文章后可以根据其抽象逻辑实现自己的要求。\\n\\n建立对象池\\n\\n对象池该如何建立呢？最基本地，我们可以想到 Bukkit 经常使用到的 Yaml。因为毕竟 Bukkit 中与外部（文件）进行数据交互基本上都是基于 Yaml，如有不同意见请指正。这个问题很好解决，我们只需要为我们的插件引入一个新的文件即可，就用这个文件来作为我们的「池」。\\n\\npackage win.subilan.ExamplePlugin;\\n\\n// import 部分省略\\n\\npublic final class ExamplePlugin extends JavaPlugin {\\n\\n    // 前面的 onEnable 之类的后面再说\\n\\n    public FileConfiguration load(String filename) {\\n        // 获取当前插件所用的数据目录，也就是 config.yml 默认所在的位置\\n        File folder = getDataFolder();\\n        // new 一个 File 出来，很简单\\n        File file = new File(folder, filename);\\n        // 离奇！如果这个文件夹不存在的话，还是帮忙创建一下\\n        if (!folder.exists()) {\\n            folder.mkdir();\\n        }\\n        // 如果文件不存在的话，就创建一个新的文件，这是正常的\\n        if (!file.exists()) {\\n            try {\\n                file.createNewFile();\\n            } catch (IOException e) {\\n                e.printStackTrace();\\n            }\\n        }\\n        // 然后返回这个文件\\n        return YamlConfiguration.loadConfiguration(file);\\n    }\\n}\\n\\n上面这个函数就是一个基本的 Yaml 文件加载函数，而且有双重用途。由于我们写了一个「如果文件不存在就创建」的逻辑，所以一般情况下我们不需要担心这个问题。在 onEnable 中，我们只需要这样写就可以获取到这个文件\\n\\npublic void onEnable() {\\n    this.pool = load(\\"pool.yml\\");\\n}\\n\\n其中 pool 为 FileConfiguration。如果这个文件是刚刚被自动建立，那么此时的 pool 就是一个 null。这样，我们就建立起了我们的「池」，用户可以自己往池里面写东西。如果围绕这个插件来讲，我们需要创建两个池，一个用来存储每日任务，一个用来存储每周任务：\\n\\nthis.dailyPool = load(\\"daily-pool.yml\\");\\nthis.weeklyPool = load(\\"weekly-pool.yml\\");\\n\\nip\\n💡 如无额外说明，下文中所有的文件名、变量名都与上文保持一致\\n:::\\n\\n至于内容究竟写什么，不是我们今天文章所探讨的范围。但是，我需要引用真正的插件中的格式，以便后文演示「从中随机抽取任务」。\\n\\nobject1:\\n    name: Mission 01\\n    lore:\\n        Hello, this is Mission 01\\n        Woooooooooooo yeah!\\n    contents:\\n        trading: 900\\n        breeding:\\n            SHEEP: 99\\n            COW: 100\\n        collecting:\\n            DIAMOND: 10\\n\\n这就是一个对象的基本格式。不过仅针对于上面的那个插件，实际情况下，我们可以自己规定格式。这对后文的处理没有任何影响，仅作例子使用。我们可以将这个格式视为一个单独的对象，当用户需要往池中添加对象时，就按照该格式进行编写即可。最终，我们将得到这样一个文件：\\n\\nobject1:\\n格式...\\nobject2:\\n格式...\\nwdnmd:\\n格式\\nMORE!\\n\\n为什么会有 wdnmd 这样的奇妙键名？在这里是为了说明每个对象中位于最高层的键（下文称顶级键）实际上除了标记以外任何用途。除非你愿意在这上面添加工序，一般情况下并无太大必要。\\n\\n由此，我们便得到了一个池子。每个池子都是这样构成的。\\n\\n抽取对象\\n\\n要抽取对象，首先我们要从池子中获取对象。由于我们的抽取是全面的，因此应当一次性获取全部对象。\\n\\nFileConfiguration pool = load(\\"daily-pool.yml\\");\\n\\n但这还不够！我们需要将其放入一个 Java 类型中，以便我们进行操作。在这里我们需要首先梳理一下随机抽取的思路。\\n\\n经过观察，我们发现 Bukkit 的 FileConfiguration 有两个关键方法：getKeys(boolean) 和 getValues(boolean)。至于这个 boolean 到底是干什么的，我们现在不需要知道。通过 Javadoc 可以得知它们的返回值一个是 Map，另一个是 Set，因此我们认为这绝对又是一场噩梦。\\n\\n为了能够让后续的流程不乱套，我们先将这两个值获取出来。\\n\\nMap objects = pool.getValues(false);\\nSet keys = pool.getKeys(false);\\n\\n由于 Java 中的 Set 类型在我们这个上下文中啥也不能干，我们需要将它转成 List。\\n\\nList keyList = new ArrayList(keys);\\n\\n你可能现在要想，既然我们已经有了 Map，为什么还要单独把键集获取出来？可以说的是，这里是顶级键唯一发挥作用的时刻。前文我们在建立池的时候，每一个对象前面都会有一个看似多余的顶级键，其实它的标记作用确定了这个对象在该文件中的「位置」。在这里，我们的 keys 里就是这些顶级键所构成的集合；我们的 objects 则是这些键下的具体内容。Map 的确同时具有键和值，在这里需要避免将 Map 的键与值和顶级键弄混。\\n\\n既然顶级键标记了每个对象的位置，那么我们便可以通过随机取到这些键来随机取到它们对应的值。因为 Map 并不好操作，我们可以直接从 List keyList 入手。大致逻辑如下\\n\\nRandom rand = new Random();\\nString randomKey = keyList.get(rand.nextInt(keyList.size()));\\n\\n如果懂 Random 可以跳过这段话。在这里，Random 是（伪）随机数生成器，它在使用之前需要被实例化。它的实例有一个方法 nextInt，用于获取一个随机的整型。该方法的 Javadoc 叙述如下：\\nReturns a pseudorandom, uniformly distributed int value between 0 (inclusive) and the specified value (exclusive), drawn from this random number generator\'s sequence. The general contract of nextInt is that one int value in the specified range is pseudorandomly generated and returned. All bound possible int values are produced with (approximately) equal probability.\\n\\n不需要把它完全读完，粗体部分就足够。nextInt 获取到的随机数是范围性的，其范围为 $0\\\\leq{n}\\\\lt{b}$，其中 $b$ 为其参数 bound。恰好，List 的顺序是从 0 开始的。\\n\\n当我们有这样一个 List 时 $L = \\\\{1,2,3,4,5,6\\\\}$，它的大小 L.size() 为 6，Random 恰好为我们解决了 OutOfBound 的问题。由于随机数生成的范围只能是 $0\\\\leq{n}\\\\lt{b}$ 即 $0\\\\leq{n}\\\\lt{6}$，可能取的值只有 $P = \\\\{0,1,2,3,4,5\\\\}$\\n\\n而该数组可取的最高位就是第 5 位（值为 $6$）。\\n\\n接上文。我们从 keyList 中随机取到了一个键，接下来我们就可以用这个键来获取它对应的值——取键即取值。\\n\\nObject object = pool.get(randomKey);\\n\\n很明显，上面我们获取到的 Map objects 被抛弃了。的确，它在我们这里并没有用途，因为我们的最终目的是获取「池」中的对象，而不是对象中的值。仍然介绍这个值是为了启发你，也许你会用它去干别的事（例如预处理数据）。\\n\\n抽取多个对象\\n\\n我们来汇总一下我们先前的代码：\\n\\nFileConfiguration pool = load(\\"daily-pool.yml\\");\\nList keyList = new ArrayList(pool.getKeys(false));\\nRandom rand = new Random();\\nString randomKey = keyList.get(rand.nextInt(keyList.size()));\\nObject object = pool.get(randomKey);\\n\\n抽取多个对象，也就是从 keyList 中抽取多个键，只需要用到循环就可解决。我们从第四行开始改写：\\n\\n// 预先声明变量，避免重复\\nString randomKey;\\nMap results = new HashMap();\\n// 这里的数字就是你想要抽取对象的个数\\nwhile (results.size() * 由于该随机数的范围一般较小，所以被重复随机的概率不是没有。我们不愿意将重复的元素添加到 Map 中，因此要对其重复性进行检测。\\n\\n写入对象\\n\\n若要写入对象，需要灵活运用 FileConfiguration 的方法。纵观前面我们进行的行为，实则是这样的\\n\\n\\n\\n也就是说我们只是把一个池内的对象抽到了另一个池（用户不可改变）里，文件内容、数据结构都是一样的。那么这就很好办了。\\n\\npublic void onEnable() {\\n    this.resultPool = load(\\"result-pool.yml\\")\\n}\\n\\n首先我们创建一个用于存储挑选出来内容的 Yaml，即后文中的「存储池」。然后，我们开始写入。\\n\\n// 先清空先前生成的内容，因为每次生成都是覆盖性操作\\nresultPool.set(\\"daily\\", null);\\nresultPool.createSection(\\"daily\\", results)\\n\\n没错，这就完事了。假设 object1 和 objectN 被选中，最终我们获取到的文件结构就是\\n\\nresult-pool.yml\\ndaily:\\n    object1:\\n        name: Mission 01\\n        lore:\\n            Hello, this is Mission 01\\n            Woooooooooooo yeah!\\n        contents:\\n            trading: 900\\n            breeding:\\n                SHEEP: 99\\n                COW: 100\\n            collecting:\\n                DIAMOND: 10\\n    objectN:\\n略\\n\\n幸亏 Bukkit 提供了一个快捷的 createSection 方法。它的第一个参数是键名，也就是这里的 daily，第二个参数所要求的类型是 Map，恰好符合我们前面的 results 值类型，这也是为什么我们不去用其它类型。\\n\\n至此，我们获得了随机从一个池抽取对象，然后写入到另一个用于存储的静态池的能力，实现逻辑阐述完毕。\\n\\n定时更新的基本思路\\n\\n我们的插件要求是对存储池定时更新。也就是我们需要定时对存储池的内容进行覆盖操作，保证在更新后的内容大致与先前不一样。\\n\\narning\\n在这里，我们无法保证两次获取到的 results Map 的内容完全不一样，也没有必要保证它们完全不一样——如果认为这样不合理，只能从根本模式上做出改变。\\n:::\\n\\n这也是为什么前文中出现了 resultPool.set(\\"daily\\", null) 这样一句。每次所生成的 Map 是基于随机目的的。因此如果不加以清空，将会变成积累操作，到最后一切都一样了。那么究竟该如何进行定时更新？如何判断现在该不该进行更新呢？\\n\\n最简单的方法，就是在每一次将对象写入存储池时，同步地往池中写入下一次更新的时间。因为我们只有在每次写入的时候，才能知道下一次是什么时候，只有在这时将它记录下来，将来才能够使用。我们首先需要在 config.yml 中提供以下两项：\\n\\ndaily_refresh_time: 10\\nweekly_refresh_time: 6\\n\\n这两项将成为我们实现该功能的核心依赖，它们规定了究竟应当在何时进行刷新。对于每日刷新的情况，只需要规定在一天的第几个小时（$0\\\\leq{n}\\\\leq{23}$）；对每周刷新的情况，只需要规定在一周的第几天（$1\\\\leq{n}\\\\leq{7}$，$1$ 代表星期日）。\\n\\n接下来，让我们往上面的代码中添加内容。\\n\\n定时更新的实现\\n\\nFileConfiguration pool = load(\\"daily-pool.yml\\");\\nList keyList = new ArrayList(pool.getKeys(false));\\nRandom rand = new Random();\\nString randomKey;\\nMap results = new HashMap();\\nwhile (results.size() = refreshHour) {\\n        cal.add(Calendar.DATE, 1);\\n    }\\n    cal.set(Calendar.HOUR_OF_DAY, refreshHour);\\n    cal.set(Calendar.MINUTE, 0);\\n    cal.set(Calendar.SECOND, 0);\\n    return cal.getTime();\\n}\\n\\n在这里我们需要用到两个工具：Calendar 和 Date。至于它们两个的区别，属于 Java 的基础内容，在这里不再供述，但仍会解释其大致作用。首先我们需要初始化一个 Calendar 对象\\n\\nCalendar cal = Calendar.getInstance();\\n\\nip\\n为什么不是 new Calendar()？因为 Calendar 是一个 abstract class，它不能被实例化。该 getInstance() 方法返回的实际上是一个叫做 GregorianCalendar 的实例。上述语句等同于 Calendar cal = new GregorianCalendar();\\n:::\\n\\n然后将这个对象设置为现在的时间。\\n\\ncal.setTime(new Date());\\n\\n接下来是推理环节。借助 Calendar 我们可以获取到当前的小时数。例如若现在是 22:35，小时数则为 22。在配置文件中，我们也规定了在每天的第几个小时刷新（标准刷新时间）。如果现在的小时数晚于或恰好为标准刷新时间（不太可能，因为有延迟和程序处理的时间），也就是说现在的刷新操作发生在标准刷新时间以后或恰好在标准刷新时间之时，那么下一次刷新必定在明天，所以我们将 Calendar 实例加上 1 天。\\n\\n// 获取当前小时数\\nInteger now = cal.get(Calendar.HOUR_OF_DAY);\\n// 获取标准刷新时间\\nInteger refreshHour = config.getInt(\\"daily_refresh_time\\");\\n// 如果当前小时晚于或恰好等于标准刷新时间\\nif (now >= refreshHour) {\\n    cal.add(Calendar.DATE, 1);\\n}\\n\\n而如果刷新操作处于标准刷新时间之前，是怎样一种情况？也许是首次安装插件以后，第一次启动时的强制初始化早于标准刷新时间；也许是很久没有开启服务器，打开服务器后由于时间远远晚于上次更新时写入的下次刷新时间而进行强制初始化。无论如何，这些初始化行为都无法影响到这一天的下一次刷新。因此，当发生这种情况时，一天内有两次刷新，因此不需要将 Calendar 实例加上 1 天，所以会在 if 的外面。\\n\\n// 必定：将下一次刷新时间的小时设置为配置文件中的值\\ncal.set(Calendar.HOUR_OF_DAY, refreshHour);\\n// 避免影响，将其余单位均设为 0（GregorianCalendar 最小单位是秒）\\ncal.set(Calendar.MINUTE, 0);\\ncal.set(Calendar.SECOND, 0);\\n// 返回一个 Date 类型\\nreturn cal.getTime();\\n\\n以上便获取到了每日池的下次刷新时间。\\n\\n每周池刷新\\n\\n每周池的前一部分逻辑是一样的。\\n\\npublic static Date getWeeklyNextRefreshTime(FileConfiguration config) {\\n    Calendar cal = Calendar.getInstance();\\n    cal.setTime(new Date());\\n    Integer today = cal.get(Calendar.DAY_OF_WEEK);\\n    Integer refreshDay = config.getInt(\\"weekly_refresh_time\\");\\n    Integer nextWeekdayOffset = today = dailyNextRefresh) {\\n    // 强制刷新每日池\\n}\\n\\nif (now >= weeklyNextRefresh) {\\n    // 强制刷新每周池\\n}\\n\\n在这里便会出现上文中提到过的一周两次刷新、一天两次刷新的情况，其中一次刷新便是这里的强制刷新。\\n\\n对于服务器长期处于开启状态的刷新，需要借助 BukkitRunnable 每秒进行检测，所执行的逻辑与上面的代码完全一致，具体方法请自行探索，如果有机会也许会有文章。","filename":"Bukkit-Object-Pool-Picking-And-Updating","namespace":"post"},{"title":"Bukkit 实现 MC 服务器里的 HTTP 服务器","filecontent":"date: 2021/10/23\\ndesc: 也许是与服务器直接通讯的较好方式。\\ncate: 代码\\nBukkit 实现 MC 服务器里的 HTTP 服务器\\n\\n最近在写 seatide 相关项目的时候，遇到了一个需要直接与服务器进行交互的需求。具体来说，就是通过指令来获取服务器的各种信息，因为指令能干的东西很多，这样做很方便。起初我以为这个需求的实现很简单，因为有一个叫 RCON 的东西存在（虽然说在使用之前就有听说这个东西问题很多）。\\n\\n我很快就用第三方库在 API 上做了一个简单的实现，使用起来是正常的，但是却存在一个致命问题——它的发包（回复）逻辑不是很正常。具体的发包细节可以在上面的 RCON 链接指向的 Wiki 中看到，我遇到的问题简单来说就是\\n\\n它返回的包有大小限制，如果超出，会被直接截断，并返回最后一个包\\n  这与我所想要的效果——完整的结果相违背。\\n因为某种原因，没有超过大小限制的时候也会出现截断的问题 (?)\\n多个对 RCON 的请求的返回使用的却是同一个 output stream，导致其返回的信息可能重叠\\nRCON 太老了\\n\\n经过调查发现这是其自身的弊病，并不能通过简单的调整来解决。于是我就想，能不能抛弃 RCON，而像 RESTful API 那样使用 HTTP 请求直接获取 Minecraft 内的各项信息。\\n\\n我以前没有用 Java 写过任何有关 web 方面的内容，所以对这方面根本不算了解。经过搜索，发现大多数实现都是依赖一些较大型的库。而的确有一些小型的库似乎能够满足我的需求，但却又因为种种原因没有办法正常使用，对于 sun 包底下自带的服务器，就更不用说了。\\n\\n于是我就更偏向于一些纯手写代码的方法——然而受制于个人能力，并不能写出一个具有自己可以信任的性能和稳定性的实现。幸运的是，我找到了这篇文章，其介绍了一个简单的 Java 多线程+池 HTTP 服务器的实现。以下是从文章中直接摘录的完整代码内容。\\n\\npackage servers;\\n\\nimport java.io.InputStream;\\nimport java.io.OutputStream;\\nimport java.io.IOException;\\nimport java.net.Socket;\\n\\n\\npublic class WorkerRunnable implements Runnable{\\n\\n    protected Socket clientSocket = null;\\n    protected String serverText   = null;\\n\\n    public WorkerRunnable(Socket clientSocket, String serverText) {\\n        this.clientSocket = clientSocket;\\n        this.serverText   = serverText;\\n    }\\n\\n    public void run() {\\n        try {\\n            InputStream input  = clientSocket.getInputStream();\\n            OutputStream output = clientSocket.getOutputStream();\\n            long time = System.currentTimeMillis();\\n            output.write((\\"HTTP/1.1 200 OK\\\\n\\\\nWorkerRunnable: \\" + this.serverText + \\" - \\" + time + \\"\\").getBytes());\\n            output.close();\\n            input.close();\\n            System.out.println(\\"Request processed: \\" + time);\\n        } catch (IOException e) {\\n            // report exception somewhere.\\n            e.printStackTrace();\\n        }\\n    }\\n}\\n\\npackage servers;\\n\\nimport java.net.ServerSocket;\\nimport java.net.Socket;\\nimport java.io.IOException;\\nimport java.util.concurrent.ExecutorService;\\nimport java.util.concurrent.Executors;\\n\\npublic class ThreadPooledServer implements Runnable {\\n\\n    protected int          serverPort    = 8080; // 指定端口\\n    protected ServerSocket serverSocket  = null;\\n    protected boolean      isStopped     = false;\\n    protected Thread       runningThread = null;\\n    protected ExecutorService threadPool = Executors.newFixedThreadPool(10); // 指定进程池大小\\n\\n    public ThreadPooledServer(int port){\\n        this.serverPort = port;\\n    }\\n\\n    public void run(){\\n        synchronized(this) {\\n            this.runningThread = Thread.currentThread();\\n        }\\n        openServerSocket();\\n        while (!isStopped()){\\n            Socket clientSocket = null;\\n            try {\\n                clientSocket = this.serverSocket.accept();\\n            } catch (IOException e) {\\n                if (isStopped()) {\\n                    System.out.println(\\"Server Stopped.\\") ;\\n                    break;\\n                }\\n                throw new RuntimeException(\\"Error accepting client connection\\", e);\\n            }\\n            this.threadPool.execute(\\n                new WorkerRunnable(clientSocket, \\"Thread Pooled Server\\"));\\n        }\\n        this.threadPool.shutdown();\\n        System.out.println(\\"Server Stopped.\\") ;\\n    }\\n\\n\\n    private synchronized boolean isStopped() {\\n        return this.isStopped;\\n    }\\n\\n    public synchronized void stop(){\\n        this.isStopped = true;\\n        try {\\n            this.serverSocket.close();\\n        } catch (IOException e) {\\n            throw new RuntimeException(\\"Error closing server\\", e);\\n        }\\n    }\\n\\n    private void openServerSocket() {\\n        try {\\n            this.serverSocket = new ServerSocket(this.serverPort);\\n        } catch (IOException e) {\\n            throw new RuntimeException(\\"Cannot open port 8080\\", e);\\n        }\\n    }\\n}\\n\\n要运行它，新开一个线程即可。\\n\\nvar server = new ThreadPooledServer(26656);\\nnew Thread(server).start();\\n\\n// 关闭可以调用实例方法\\nserver.stop();\\n\\n看上去不错。它是异步的，有助于与 Minecraft 服务器本身解除一些可见的性能上的联系，而且可以利用 thread pool 限制最大连接个数。也许它并没有那么稳定，但似乎已经够用了。\\n\\n于是我就对其进行了魔改。我们可以看到对 HTTP 请求的主要处理一种在 WorkerRunnable 内。\\n\\ntry {\\n    InputStream input  = clientSocket.getInputStream();\\n    OutputStream output = clientSocket.getOutputStream();\\n    long time = System.currentTimeMillis();\\n    output.write((\\"HTTP/1.1 200 OK\\\\n\\\\nWorkerRunnable: \\" + this.serverText + \\" - \\" + time + \\"\\").getBytes());\\n    output.close();\\n    input.close();\\n    System.out.println(\\"Request processed: \\" + time);\\n    } catch (IOException e) {\\n    // report exception somewhere.\\n    e.printStackTrace();\\n}\\n\\n其中 input 为输入流，为发送来的内容；output 为输出流，为要返回的内容。首先，我们对其进行一个简单的简化。\\n\\nvar in = new BufferedReader(new InputStreamReader(input));\\nvar out = new BufferedWriter(new OutputStreamWriter(output));\\nvar body = new StringBuilder();\\nvar header = new StringBuilder();\\n\\n然后开始获取我们所需要的信息——header 和 body。\\n\\nString headerRaw;\\ntry {\\n    // 先读 header 部分内容到 header\\n    // 注：x.isEmpty() 是 Java 11 的方法，相当于 x.length() == 0\\n    while (!(headerRaw = in.readLine()).isEmpty()) {\\n        header.append(headerRaw);\\n    }\\n} catch (NullPointerException e) {\\n    // 当遇到一个空行（代表着 header 的结束）的时候，就会触发这个 NPE，此时不处理即可。\\n}\\nwhile (in.ready()) {\\n    // 接下来读的就全部是 body 部分了\\n    body.append((char) in.read());\\n}\\n\\n于是我们就将发来的请求读成了字符串。完整的请求内容大概是这样的。\\n\\nPOST /\\nUser-Agent: ...\\nContent-Type: ...\\nContent-Length: ...\\n（这里是一个空行，从此处隔开）\\n{\\"type\\": \\"get\\", \\"params\\": {\\"name\\": \\"ram\\"}}\\n\\nip\\n前端发来的请求内容的格式是事先约定好的，在本文中使用以下格式举例：\\n{\\n    type: \\"get\\",\\n    params: {\\n        name: \\"ram\\",\\n        target: \\"xxx\\",\\n        anyParam: \\"abc\\"\\n    }\\n}\\n:::\\n\\n现在 header 和 body 变量里分别存有空行前和空行后的完整字符串内容。要获取发来的信息，将 body 转换为 JSONObject 即可。\\n\\nvar object = new JSONObject(body.toString());\\nobject.getString(\\"type\\").equals(\\"get\\") // -> true\\n\\n下面就可以根据从 object 中获得的信息进行相应的处理了。例如约定获取服务器 RAM 使用情况的请求内容如下：\\n\\n{\\n    type: \\"get\\",\\n    params: {\\n        name: \\"ram\\"\\n    }\\n}\\n\\n处理的逻辑可以这样写\\n\\nvar type = object.getString(\\"type\\");\\nvar params = object.getJSONObject(\\"params\\");\\nvar name = params.getString(\\"name\\");\\n\\n// 使用 switch 代表着当前的键（比如 \\"type\\"）可以由多个值（比如 \\"get\\", \\"delete\\"）来确定含义\\nswitch (type) {\\n    case \\"get\\": {\\n        switch (name) {\\n            case \\"ram\\": {\\n                var json = new JSONObject();\\n                var runtime = Runtime.getRuntime();\\n                json.put(\\"used\\", (runtime.maxMemory() - runtime.freeMemory()) / 1024L / 1024L);\\n                json.put(\\"max\\", runtime.maxMemory() / 1024L / 1024L);\\n                // 返回 json 数据\\n            }\\n            // ...\\n        }\\n    }\\n    // ...\\n}\\n\\n这样我们就构建了后端的处理模式。下面要解决的就是返回请求的问题。之前读取请求使用的是 BufferedReader，此时我们就要用上 BufferedWriter。\\n\\nvar codeInfo = \\"200 OK\\";\\nvar result = json.toString();\\n// header 内容\\nout.write(\\"HTTP/1.1 \\" + codeInfo + \\"\\\\r\\\\n\\");\\nout.write(\\"Content-Type: application/json;charset=UTF-8\\\\r\\\\n\\");\\nout.write(\\"Date: \\" + (new Date()).toString() + \\"\\\\r\\\\n\\");\\n// 空行分隔\\nout.write(\\"\\\\r\\\\n\\");\\n// body 内容\\nout.write(result);\\n\\n其中 body 部分就是发送者想要的结果了，直接将我们上面封装的 JSON 对象转为字符串即可。在 out 写完以后，需要手动使用 out.flush() 方法强制将当前写入的内容返回。所以整体的代码看上去应该是这样的：\\n\\nvar in = new BufferedReader(new InputStreamReader(input));\\nvar out = new BufferedWriter(new OutputStreamWriter(output));\\nvar body = new StringBuilder();\\nvar header = new StringBuilder();\\n\\n/**/\\n/* 省略：读取 body 和 header */\\n/**/\\n\\n// 处理请求并整合信息\\nvar object = new JSONObject(body.toString());\\nvar type = object.getString(\\"type\\");\\nvar params = object.getJSONObject(\\"params\\");\\nvar name = params.getString(\\"name\\");\\nvar json = new JSONObject();\\nswitch (type) {\\n    case \\"get\\": {\\n        switch (name) {\\n            case \\"ram\\": {\\n                // 在这里封装返回信息\\n                json.put(/* ... */)\\n            }\\n        }\\n    }\\n}\\nvar codeInfo = \\"200 OK\\"; // 可变\\nvar result = json.toString(); // 可变\\nout.write(\\"HTTP/1.1 \\" + codeInfo + \\"\\\\r\\\\n\\");\\nout.write(\\"Content-Type: application/json;charset=UTF-8\\\\r\\\\n\\");\\nout.write(\\"Date: \\" + (new Date()).toString() + \\"\\\\r\\\\n\\");\\nout.write(\\"\\\\r\\\\n\\");\\nout.write(result);\\nout.flush(); // 强制返回信息\\n\\n// 关闭 BufferedReader/Writer 和 Stream\\nout.close();\\nin.close();\\ninput.close();\\noutput.close();\\n\\n经过实现可以得到下面的返回结果。\\n\\n\\n\\n就这样一个 HTTP 服务器在 StackOverflow 式的搜索下实现了，并且能够与外界产生直接的交流。由于可以指定端口，并不需要太担心服务器商相关限制。如果你有兴趣查看完整的实现代码，可以移步 Remote 插件的仓库。","filename":"Bukkit-Webserver-In-Minecraft","namespace":"post"},{"title":"重庆—成都游记（上）","filecontent":"date: 2023/07/29\\ncate: 记录\\ndesc: 领略的不仅是风景，而是一种现状，一种岁月里的永恒。\\n重庆—成都游记（上）\\n\\nanger\\n多图预警\\n\\n本页面中出现的图片为经过有损压缩后的图片，每张图片大小约 1.5~2.0 MiB，请注意流量消耗。\\n:::\\n\\n写在前面 - 旅行带给我最大、最触动我心弦的感受就是，它可以让你明白这个世界终究还是很大的。这种大，和互联网所带给你的大截然不同——它是一种更实际、更真实的大，一种关系到与你无关的无数个人的大，一种无言的大，一种不可忽略的大。与这种大相比，信息爆炸带给我们的更多是没有用处的冗余垃圾，或是一种急于用信息填满我们自身大脑的无意义的紧迫感，而旅行所能带来的是用双脚、双眼、双手去领略一个完完全全未被虚拟化的地球——一个真实的地球。\\n\\n这篇游记重点记录我在途中所拍到的一些图片以及我对当时情况的一些解读。不全是美景欣赏，因为还有部分对旅游过程非景观方面的一些思考~\\n\\n计划概览\\n\\n这次旅游的计划相比于先前的既定路线要更加复杂，但是整体依然清晰明了。旅行历时 10 天左右，目标是休闲地（走马观花地）逛逛重庆、成都以及成都周围的各色景点。当然了，这趟旅途如果全部都逛完会非常的累，也没那个必要。重点还是放在成都上，因为所谓“成都好看的地方”就集中在四川省内部，成都周边；而重庆好玩好看的地方大部分就只有在城区里了。\\n\\n第一站：湖北恩施土家族自治州\\n  市区内：土司城和女儿城 （不推荐）\\n  利川腾龙洞\\n第二站：重庆城区\\n  渣滓洞、白公馆和磁器口\\n  观音桥\\n  把地铁坐个遍\\n  重庆大剧院\\n  洪崖洞\\n第三站：四川省\\n  九寨沟与黄龙沟\\n  峨眉山与乐山大佛\\n  都江堰与熊猫基地\\n  成都城区\\n\\n第一站：湖北省恩施土家族自治州\\n\\n市区内\\n\\nip\\n恩施地区，包括周围的野三关镇、巴东县等，存在较多土豆类小吃。\\n:::\\n\\n这个地方具体来说没有什么好评价的，单纯因为我是湖北人，恩施大峡谷的名气也不算小，于是就来随便看看。\\n\\n恩施的景点以自然风景为主，也就是恩施大峡谷（当然除了它以外还有二三十个景点），但是这次我并没有去恩施大峡谷，因为听说是比九寨沟还累... 所以我只在恩施城区内游荡了一下，给人的感觉就是湖北省里典型的小城市，没什么特色。有些让我诧异的是，恩施有些地方也存在高楼，让我一会儿看到农村的影子，一会儿看到武汉的影子，一会儿又看到深圳的影子。上午 10 点左右到城里的时候，开车走了好几个宽敞的街道，几乎没遇到几个路上走的人，让我感到非常诡异。难道是温度太高了吗？（当天温度应该在 32°C 左右）\\n\\n至于我去过的那些城内的景点在这里放出来避免各位读者踩雷。\\n\\n\\n\\n上图展示的是恩施城区内景点之一土司城，大概给人一种这是过去土司（可以理解为元朝及以后由官方认定的少数民族首领）居住过的类似于皇居的地方。但是事后查询资料发现这是苏州园林设计院所设计的仿古建筑群，顿时失去了其历史底蕴。不过学生凭借学生证或者准考证进去是免费的（仅供参考）。其游览具体内容就是走路，拍照（比较单调），没了。\\n\\n: 土司是中国边疆的官职，元朝始置，用于封授给西北、西南地区的少数民族部族头目。——维基百科\\n\\n然后还有一个景点我并没有拍照，因为实在是太糟糕了。名为女儿城，是恩施城内的失败旅游项目之一。为什么说是之一呢，因为周围还有几个类似的场地，里面建设的花花绿绿的，但是一问当地人便得知这些场地基本上已经倒闭了。抛开所有包装，女儿城就是一个仿古商业街，类似于后文会提到的重庆的磁器口（但显然在各种方面都比不上磁器口）。去的时候只有一条大街道可以走。\\n\\n: 根据某旅行社在 B 站发布的相关视频得出的结论（我赞同）。\\n\\nanger\\n危险\\n\\n女儿城存在一条大道和两条小道。两条小道中间由一条人工小河隔开，上有小桥。一条小道旁边是小吃，另一条小道旁边是店子。每家卖小吃的摆出来的食物大同小异，但是基本上全部是不新鲜甚至变质的，因为我和同行的人购买了一碗迷你包子、一碗拌面和一大盆虾蟹，最终我们一致给出的评价都是不新鲜，不好吃。大道上的食物中规中矩。\\n\\n另外两条小道之间的人工河无人维护，基本上可以算作是脏水沟（但没有异味）。小道路上摆的桌椅也无人维护，人去了以后就餐用具乱丢，桌上地上都是脏乱差。\\n:::\\n\\n利川腾龙洞\\n\\n离开恩施城区，周围有一个小县城名叫利川，这个地方是腾龙洞的所在地。腾龙洞的主要特点是大，占有一个世界之最（最大的单体溶洞）。\\n\\n洞内温度比较低，但是不建议在洞口摊点购买保暖衣物，最好自己带。\\n  不怕冷的人进去还是不怕冷，比如我。\\n  我是短袖+薄防晒衣进去以后感觉温度刚刚好。\\n洞的范围比较大，分为前洞和后洞。\\n洞内不同的地方有演出可以看（包含在门票里）。我在前洞里所看的两场演出是灯光秀和当地的民族舞台。\\n  灯光秀比较普通，讲的土味神话爱情故事，不适合大多数年轻人，可以带老年人和小孩子来看。\\n  民族舞台的舞台设计比较贴合现代，内容大致是土家族的各种“土”味演出，想感受一下的也可以看看。时长 1 小时左右。\\n\\n我的路线是进去先坐观光车到前后洞交界处，然后往回走（大概 2~3km）出洞结束，后洞没有去。往回走也可以坐车，不过值得一提的是由于洞里真的很凉快所以走路相对来说不会很累。\\n\\n腾龙洞洞口会有一些小商铺，有些是卖吃的有些是卖衣服的。\\n\\n烤玉米、烤粽子，还有...鸡蛋？\\n\\n\\n景区入口\\n\\n下图展示了腾龙洞入口前的一小段路，可以看出也是人满为患的程度。\\n\\n\\n\\n\\n虽然不知道为什么要展示巴西的紫水晶\\n\\n腾龙洞洞口（莫名其妙）有热气球可以坐...不清楚能不能坐到蓝天上，我也只见热气球到升到洞顶就下来了。\\n\\n\\n\\n往回走的路上，路旁会有些小景点。接近前后洞交汇处的地方还存放有许多缸酒。下图是路途中的景象，可以看到右侧是来（或者回）的车道，左侧是栈道。\\n\\n\\n\\n洞内免费观看的“土”味演出，感觉观看的有几千人，时长出乎意料地多于一个小时。舞台上的房子是可以移动的。\\n\\n\\n这个图片压缩的有点狠了\\n\\n离开了利川就往重庆方向全速进发~\\n\\n第二站：重庆市\\n\\n最开始我对于重庆的了解是十分匮乏的，顶多只知道是个山城，却也不知道是怎么个山城法。但是随着在网络上探索，首先是发现重庆确实可以算是一个网红城市，然后又发现其实我日常关注的、好感度还不错的一些博主都是重庆人。综合起来，重庆这座城市对我的吸引力可以说是很强了，是得去看看了。\\n\\n洪崖洞民俗风貌区\\n\\n\\n沧白路\\n\\n我有个习惯，每到一个城市我都想了解一下那个城市的市中心在哪里，因为这似乎是每个城市最吸引我的地方。\\n\\n北京上海就不用说了，市中心都是既定的——但是重庆似乎没有那么广为人知的“市中心”。后来经过了一些了解，虽然不能 100% 确定是否是重庆人心中的市中心（后来发现真的不太算是），发现一个可以称作是「旅游的市中心」的地方，那就是「洪崖洞」。\\n洪崖洞民俗风貌区，常简称为洪崖洞，是位于中国重庆市渝中区的商业景区，由重庆小天鹅集团修建并运营，于2006年正式开放。其主体建筑仿照重庆传统吊脚楼的风格，依山而建，高11层，商业面积5.3万平方米，目前是国家4A级旅游景区。\\n\\n2016年后，洪崖洞民俗风貌区的夜景凭借抖音等短视频平台于中国内地社交网络走红，游客人数连年增多，被重庆官方誉为“城市名片”和“重庆宴客厅”。\\n\\n（摘自维基百科，已删去引用注释）\\n\\n在旅游之前没有了解这些，确实会有一种把洪崖洞跟洪崖门等同的错觉，赋予了它本来没有的历史底蕴，毕竟都没去过 ^_^|||。就连重庆官方都出面支持，想必的确特别赚钱...！\\n\\n根据我两天的找路经验，洪崖洞建筑群的摄影有两个角度，一个是在千厮门大桥上的俯瞰（多谢好友指路），一个是在滨江路的临江侧栈道的仰视。但是由于洪崖洞附近人实在是非常多，很容易迷路，所以我花了两个晚上才把距离如此近的两个地方的位置摸清楚。\\n\\narning\\n下面展示的路线只是我旅游途中经过的路线，更多是一种经历的分享，也可以适当参考。实际上走完一程以后发现其实有更好的路可以走~读完就知道了。\\n:::\\n\\n不多说，上路线图，起点是沧白路非临江侧。\\n\\n\\n\\n上图是前往千厮门大桥的路线。最关键的位置就是上图中的那个分叉点，如果有条件可以直接在那里下车然后直接进入隧道。我是因为住在沧白路对面的巷子里所以需要从那里过马路走一圈。\\n\\n千厮门大桥上的人，在晚上不出意料也特别多，所以甚至有人直接选择从马路路肩上走。大部分都应该是外地人吧...\\n\\n\\n人流方向就是上千厮门大桥的\\n\\n在千厮门大桥上拍摄的洪崖洞景象大概是这样的：\\n\\n\\n\\n下面那条走车的路就是嘉陵江滨江路。\\n\\n第二条路线是下到上图中人巨多的那个栈道上。在顶楼山走法很简单但是却也很容易忽略——直接从顶楼上标注「景区入口」的地方进去，然后想办法下楼即可。为什么叫“想办法”呢...因为人多的时候确实下楼非常不容易。\\n\\n直达电梯是有的，但是人非常多，而且不是一般的多，甚至把某位 UP 主给整崩溃了（参考 B 站视频 BV1Pj411d7JK「洪崖洞——可能不会再来了」）。我当时看到电梯那个逆天样直接一秒放弃了，然后走楼梯。实际上走楼梯也是要技术的，因为有些楼梯只能下到一半楼层。\\n\\n但是楼梯最终的确是可以下到底部的，所以不用担心。\\n\\n具体走楼梯的路线已经不记得了（我只记得下了一个，然后在建筑里走，然后再下一个就到建筑外围了），也没有照片，所以在这里就不提供啦。不过景区内是有指路牌的，见下图「下行步梯由此去」。\\n\\n\\n摄于中层\\n\\n在这层也可以拍到千厮门大桥。当然通过位置和焦距的调整可以把边框景物都去掉。\\n\\n\\n\\n真正快要下到底层的时候，楼梯是在建筑外围。也是肉眼可见的人多啊！拍到了一点点晚霞。\\n\\n\\n\\n一直跟随人流走，就真正来到洪崖洞建筑的底部啦！但是这也不是最底部，下面还有一个码头。观察图片可以知道，路的这边有人，路的那边也有人。但是很可惜，过马路很难。如果想要到路的对面去，还得要走些特别的路。（连我自己都忘记我是怎么发现路线的了...就一直目标往下走就到了）\\n\\nip\\n路中间存在一个过街天桥，通过那个天桥甚至可以直接上到上面的马路上，所以其实这个天桥才是真正的优选路线...\\n:::\\n\\n\\n仰视洪崖洞\\n\\n标有「洪崖洞」三个字的地方，是游客服务中心。旁边就有一个美食街。实际上整栋建筑都是卖吃的地方。\\n\\n\\n被拍到的路人如有侵犯欢迎联系我删除\\n\\n比较戏剧性的是左下角的那个“手打柠檬茶”...虽然上面标着「重庆」二字，实际上并非只有重庆有。在成都标的是「成都」，在都江堰标的是「灌县」。\\n\\n要想要到马路对面，沿着夜市街区直走，左侧会出现一个比较大的码头入口（向下的楼梯），下去然后左转一直往前走即可。下面是在路上拍摄的图片：\\n\\n\\n\\n沿着路一直走（不是掏钱买票上船）就可以上楼梯到达栈道上了。上的那个楼梯有很多人卡在上面拍照（比如我），所以也会有警察维持秩序。注意千万别被挤摔跤了...有些人的素质啊😔\\n\\n上了楼梯就到了我们的目的地啦~\\n\\n\\n摄于楼梯上\\n\\n\\n摄于栈道上\\n\\n\\n摄于栈道上\\n\\n不得不说对面的银行是真的多💰💰💰。\\n\\n要想回到上面，不必走回头路，沿着栈道往前走到达过街天桥，然后就可以看到上去的楼梯了。下面是在天桥上拍摄的嘉陵江滨江路。\\n\\n\\n\\n上到最顶部以后出去会进入一个在外边看来十分隐蔽的小巷道（如果能直接找到这里就可以直接下来了...），然后就会回到沧白路。\\n\\n\\n小巷子出口处的路牌。划重点「洪崖洞观景台（客运码头）」就是目的地\\n\\n路上有许多店铺，还有冰汤圆~\\n\\n一直沿坡度下行即可到达最开始那张地图里「交叉点」的位置（一只酸奶牛店）。\\n\\n渣滓洞、白公馆和磁器口\\n\\n其实我本身对历史并不感兴趣，对那一段历史也只是放在心中但不会主动去想起的程度。但是来都来了不去看看，有些说不过去。做路线规划的时候发现这三个景点离得比较近，且都离中心城区比较远，索性就一起去了。\\n\\n经过高德地图的帮助，路线是从小什字（就在沧白路附近）坐地铁前往石井坡地铁站步行。步行的距离应该有个 1km 左右。石井坡地铁站的出口有许多出租车司机在等着你来，坐一坐也无妨，不过我没有坐，于是就被追了差不多 50 米，大概意思是走路得走巨久，真的不坐车吗？这现象其实蛮正常的。我承认当天确实很热，但就是想要步行来体验一下生活(?)。\\n\\n那也的确被我给体验到了，看到了一些沙坪坝的老房子（算是吧），吃到了八毛钱（其实最开始我听成了八块钱还被吓到了）的老冰棒。最终导航带我来到了渣滓洞隧道的门口。在门口有老年人坐着休息。\\n\\n\\n\\n进入隧道以后就比较凉快了。出了隧道后，结合隧道里地上的钢轨痕迹和面前的废旧铁路，发现这里过去的确是一条铁路，继续往前走就是一个过去的火车站「梅园」。\\n\\n\\n\\n照片中正对的方向，向前走一段距离后右转，再掉头，就是向着渣滓洞的方向去了。这一段路有坡度，在大热天来走其实还是有点难受的...\\n\\n\\n渣滓洞内景\\n\\nip\\n上面的字并非原本就这样，下面是偶然在文章中看到的另外一版图片。\\n\\n\\n:::\\n\\n渣滓洞的游览主要是参观每个房间。每个房间里有受难人的照片和简要的介绍，以及牢房内部的床位排布、办公桌等。\\n\\n实际上我一个没有多少浓厚爱国情绪的人看到了这些东西以、墙上挂的人像以及他们最终的遭遇（一一·二七事件），心里也是说不出的难受...我希望世界能够一直和平下去。\\n\\n里面陈列的物品就是过去在牢房里生活的人的一些创作、手工品等，就不展示了。\\n\\nanger\\n后来经过查询发现，被杨钦典释放成功越狱，《红岩》的作者罗广斌在文化大革命中遇害，实在是令人唏嘘。\\n:::\\n\\n渣滓洞和白公馆相连，但是距离并不近。到了渣滓洞我才发现实际上是有一个景区公交的，60 元可以坐 4 次（如有勘误欢迎纠正）。公交路线是 渣滓洞->白公馆->公园->烈士墓地铁站->磁器口。所以最终我还是选择了买票上车。\\n\\n\\n白公馆标志性的「香山别墅」大门\\n白公馆，又名“香山别墅”，原是四川军阀白驹在重庆沙坪坝郊区的别墅，20世纪30年代，为养小妾而修建，因白驹自认为是白居易后裔，以白居易之号命其名为“香山别墅”；后成为国民政府军事委员会调查统计局的看守所，名为“国民政府军事委员会调查统计局重庆看守所”。\\n\\n白公馆的内容和渣滓洞类似。限于体力，我并没有把白公馆游览完，有很多要向上爬的地方。\\n\\n坐公交可以到达磁器口。但是实话实说，依然是商业街，因为不是很饿所以啥也没买，就是转转看看没了，没咋拍照。里面还有采耳一类的东西，从恩施一路过来真是随处可见。\\n\\n\\n\\n旁边有家茶颜悦色，人很多~霸王茶姬比不上的人流量——也可能是因为店面太小。还听到了楼上有人在唱痛仰乐队的《西湖》，这是几个月前我经常听的一首歌。\\n\\nip\\n在到磁器口的路上，我留意到了道路旁的有些沿山而建的建筑和贯穿在建筑之间长有青苔的水泥阶梯。我想，这才是真正老重庆的样子吧。\\n:::\\n\\n奇妙的二号线\\n\\n重庆人似乎习惯于把轨道交通称为轻轨。我觉得轻轨和地铁的界限，在重庆确确实实是被模糊了。当然这里探讨的不是严格的概念，只是一个「天上」和「地下」的区分。也得益于网络的宣传，又因为顺路，我来到了二号线的李子坝站，浅浅体验了一下「轻轨穿楼」的感觉~ 不过这实际上是再普通不过的交通路线...只是因为我有点对轨道交通着迷而已。\\n\\n\\n\\n\\n\\n等车的不乏只坐一站体验一下的，因为坐一站以后下车的人特别多。坐上去以后两边的风景——轨道交通与房子交汇——确实似乎只有重庆能看到了。\\n\\narning\\n旅游刚回来就看到二号线车在半路故障停车的消息了...\\n:::\\n\\n重庆大剧院闭馆游、十八梯、解放碑步行街\\n\\n听从网友的推荐，重庆大剧院打卡意义大于在里面看剧（将来有机会其实是想要看一下的）。外景还不错，当天是雨天。去的有些早还没有开放，但是门卫大哥允许我在一楼简单看下。\\n\\n\\n大剧院外景\\n\\n\\n一本书了解重庆人——馆内书架\\n\\n十八梯听说是比较有重庆味的地方（山城步道没有时间去了哭哭），也来看看。还是商业街的样子，但是体验上比磁器口要更有感觉。人并不多，也有可能是下雨的原因。\\n\\n\\n\\n在回来的路上偶然也发现了一个免费的防空洞展厅，里面展示的大概是过去抗日时期的防空洞建设、效用等内容。这里的人文气息还是比较浓烈的~\\n\\n十八梯上面也有茶颜悦色...人依旧很多，所以干脆就不准备在重庆喝了。\\n\\n\\n\\n俯瞰十八梯（非全景）：\\n\\n\\n\\n最后就是回到出发的地方了，也就是洪崖洞那一块。先去不远处的解放碑步行街。解放碑步行街就是普通步行街的样子。在解放碑下面有两名黑衣服警官打着伞绕圈。\\n\\n\\n\\n然后就可以步行回到洪崖洞，路途不远（大概 500 米？）。在路途中吃了中饭。说实话这是我在重庆吃到最满意的一餐了，因为份量终于和价格匹配了，味道还不错。更重要的是，牛肉大块~\\n\\n\\n三两\\n\\n店名是山海一面。绝对不是打广告，诚心推荐~位置在解放碑到沧白路临江段之间。店的对面就是一家霸王茶姬。\\n\\n对重庆旅途的整体评价\\n\\n洪崖洞民俗风貌区\\n  我个人选择的旅游行程就是拍拍外景走走栈道。后来看到网上一些评价，大概意思就是不要在里面消费什么的。确实，我推荐拍拍得了，在里面吃饭就没必要了。我是天然对人多的地方消费，特别是吃东西，一点兴趣没有。\\n  总体评价就是夜景比较壮观，没了。免费美化一下自己的相册，也好。\\n  地铁（小什字站）+步行 200m\\n渣滓洞、白公馆\\n  走路比较辛苦。 内部就是展示内容。如果没有特别狂热，不必专程来，在网上了解一下也是足够的。景区免费，需要在手机上预约（不是提前预定的意思，相当于是取个二维码，去景区扫码预约就行）。\\n  地铁（石井坡站）+步行/公交/出租 1km 到渣滓洞，再步行/公交/出租 2km 到白公馆。\\n磁器口\\n  可以理解为古风商业街，没有消费欲望不建议来。本地人的评价也是商业化很严重。因为没有消费所以我也不清楚里面的物价~ 但是个人不是很建议在这种地方（包括周围）解决正餐。\\n  地铁直达（磁器口站）。\\n十八梯\\n  商业化感觉不如磁器口，但是也是商业化的。路线不复杂。感觉有些部分还没有建设好。可以感受一下重庆的步道特色。有 711 便利店。\\n  有防空洞展览馆可以参观，免费。\\n  离市中心很近。\\n  地铁直达（较场口站）。\\n观音桥\\n  上面没有放图，因为内容很简单，就是一个步行街。听说也是重庆经济非常发达的地区。据说那里的好吃街是真的好吃，但我没去吃也不知道性价比如何。\\n\\n大剧院、轻轨等不需要评价，也就只有我这样不报团的散客能有机会去随便玩玩了。\\n\\n第三站：四川省\\n\\n前两站主要都是自驾散游。去了四川以后由于路途遥远加上要去的地方都不一定在成都附近，所以选择了报团。报团对我而言最大的牺牲就是自由度了，但是也是不得已的。在这里只介绍一下成都及其附近的一些小景点。关于峨眉山、九寨沟等景区，会包含在下一篇游记里。\\n\\n宽窄巷子\\n\\n其实一路走来看到这样的古风商业街都有些视觉疲劳了...但是还是得去逛逛。刚到成都就看到「成都欢迎您」几个大字。下面的通道右侧有一个大运会的办公室，里面有一张牌子，上面贴着如同高考倒计时一样的内容，「离大运会还有 9 天」。\\n\\n\\n\\n宽窄巷子里面，给人一种特别的古代与现代融合的感觉。这就体现在两家饮料厂的店铺设计上了...\\n\\n\\n喜茶庭院前的门洞\\n\\n\\n侧视星巴克院子\\n\\n\\n正视星巴克院子\\n\\n嗯，设计得还蛮古色古香的。\\n\\n路上还经过了一个朱炳仁铜展览馆。里面的制品的确很漂亮，也很贵。\\n\\n\\n应该是仿照梵高画作制作的向日葵 - ￥80,000\\n\\n\\n就一整块铜，但是很美 - 应该是高于￥100,000\\n\\n\\n一幅用铜修饰的画作 - 未标价\\n\\n还有许多作品没有在这里展出。感觉设立这个展览馆也就是给大家看看大师的作品，真正购买的，应该很少吧？\\n\\n宽巷子入口走到头的样子，人头攒动。\\n\\n\\n\\n\\n宽窄巷子\\n\\n路上还碰到了卖烟的铺子。这才发现专门有一个烟的牌子叫做「宽窄」，然后还有跟熊猫有关的牌子，确实是做出四川特色来了。\\n\\n\\n可以抽的茶，可以泡的烟\\n\\n熊猫基地\\n\\nip\\n四川省有多个熊猫基地。成都附近有两个，一个是 成都大熊猫繁育研究基地（4A 景区），一个是中国大熊猫保护研究中心都江堰基地。不得不说成都这个基地的代表性还是很强的，因为它的网址是 panda.org.cn。这次去的是前者。\\n:::\\n\\n咋说呢，去熊猫基地也就是为了看看大熊猫和小熊猫，没啥景色。所以如果真的很喜欢这两种动物的话，可以去；但是如果看看网图就能满足的话，那倒不必了，因为去了也摸不了，动物活跃时间也有差异。\\n\\n就比如大熊猫当天要求是 9 点多就要收入室内，小熊猫可能藏在树丛中，基本看不见。幸运的是这次去两种动物都清晰可见。\\n\\n\\n它真的好热，我真的好热\\n\\n\\n简单吃吃\\n\\n除了这两种动物，还可以看到第三种动物，那就是智人（二名法：Homo sapiens Linnaeus, 1758）。下图展示了疯狂的智人为了一个坐着不动的熊猫正举行某种抬手仪式来唤醒它。\\n\\n\\n\\n除此之外，还有幸拍到了小熊猫从树上爬下后准备接受喂食、两只小熊猫打架尖叫奔跑的场景~\\n\\n但说实话，这门票，这人数，这内容...换作是我自驾游的话，我是不会选择来的。\\n\\n都江堰\\n\\n都江堰和熊猫基地为旅行团打包在一起的两个项目，距离不算很远。去都江堰的目的只有一个，那就是增加阅历（虽然不知道能增加点什么阅历）。这次去都江堰走的是相反路线，也就是不走正门（1 号门），走侧门。这样就可以实现不爬山（只需要下山）的同时将景区游览完全。侧门进入后，有一个扶梯项目，可以付费然后看都江堰全景，我没有参与。\\n\\n下山的过程中，可以看到许多四川常见的寺庙。不得不说这里的寺庙是真的多！由于内容会重复，所以都江堰这里的寺庙我就省略了，简单拍了点东西。\\n\\n\\n金堤重镇\\n\\n\\n深淘滩，低作堰——这是一个管理理念\\n\\n\\n「遇湾截角，逢正抽心」的后半句\\n\\n走到山的最底下，会发现这里是都江堰鱼嘴的对岸，还需要走索桥过去。索桥入口处是一面标有「天下爱情第一桥」的墙...很厉害哦。\\n\\n\\n\\n\\n索桥景象。下面的水其实很急。\\n\\n到了对岸步行 100m 左右就可以到达鱼嘴，也就是都江堰最具有标志性的地方了。\\n\\n\\n\\n你发现图中的白色水鸟了吗？？？这鸟真的要让我笑喷了。\\n\\n\\n放大看看\\n\\n从鱼嘴处可以坐观光车（需要买票）到景区门口（1 号门）。但是路程根本不远，不到 1km，跟好友聊着天的话走起来不会很累。坐车需要排队，给我的感觉是没有 40 分钟根本坐不上，再加上天气炎热，果断选择直接走路...\\n\\n\\n\\n可能图片体现不出来。在现场看，这水花不是一般的大，可以用巨来形容了。\\n\\n出了景区入口（？）以后，可以看到一个南桥，过去以后就是商业街了。价格的话，单从我去的便利店参考，并不贵。\\n\\n\\n\\n\\n这薯片怎么没有裤衩...\\n\\n成都周围景区评价\\n\\n熊猫基地\\n  不是大小熊猫狂热粉丝不建议去。可以看到动物，但是有机遇性。竹林覆盖率很高，阴凉多。\\n宽窄巷子\\n  现代和过去融合的设计很不错。不仅仅是商业街，也有很多展览馆，例如过去的银行、朱炳仁铜等。宽窄巷子位于成都市区内，所以去了成都的话还是建议去一下。\\n都江堰\\n  不是水利、古籍爱好者不建议去。可以看到湍急的水流和古寺。\\n  都江堰附近就是青城山，不过此行并没有去。那里主要是佛教，也是主打寺庙，感兴趣可以顺带参观。\\n太古里和春熙路\\n  想看看都市风光的可以去，交通很方便（地铁春熙路站，从成都东站可以直达）。由于实在没有什么特色（抱在建筑上的 low poly 熊猫算是吗？）就不放图了。\\n  奢侈品扎堆，这也不是咱追求的东西。虽然但是，刚好在里面的优衣库买了几件“廉价”衣服回去~\\n  商场里的厕所散发着清香，哪怕是在便池前。没有夸张，建议去体验一下！\\n\\n另外关于成都城市本身，如果是第一次去真的会被吓到，一环以内整的跟大农村一样（金牛区），一眼认定是老城区。后来跟出租车司机聊天，大概意思就是一环的确是相对欠发达，在过去还有农田的存在，现在又因为地理位置，地价昂贵，难以开发。成都真正的中心在二环附近（锦江区），春熙路那里就是了。但是不管怎么说总感觉成都现代化程度跟重庆差了几节！","filename":"Chongqing-Chengdu-Tour-1","namespace":"post"},{"title":"重庆—成都游记（下）","filecontent":"date: 2023/09/05\\ncate: 记录\\ndesc: 无论是跋山涉水还是领略不同的人情，最终都是只为领略不变的自然。「自然是不变的」或许正是在遭受别扭或劳累以后对我唯一有效的宽慰。\\n重庆—成都游记（下）\\n\\n题外话 - 距离上次写这个记录已经过去了蛮久了，中途我还去了趟深圳。虽然隔了这么多年，深圳对我而言的魅力不减反增。不过，正是由于去深圳的旅途过于「自我」，因而也没什么可以说道的事情，但是无论是从体验上还是自由度上而言，都要比这趟前往重庆、成都的旅途要「顺畅且符合直觉」许多。当然了，不同人对旅途有不同的理解，我属于那类只有独自旅行才能真切感受到「饱览一切所想感受到的事物」的人。\\n\\n九寨沟与黄龙\\n\\n起初我对九寨沟的理解也就只限于「水美」的境地，甚至把它想象成是一个湖，这个湖的名字叫九寨沟。去了那边之后，冲击我的有下面几项：\\n说是去成都旅游顺便看看九寨沟，然而这路程让我感觉有点像是在「游遍四川」。\\n「沟」实则是指九寨沟这一水系，水系流过九个寨子，称为九寨沟。\\n海拔竟然很高？一路上还有不同的少数民族出现？这是我完全没有料想到的。\\n还有一些比较意外的，集中在后文指出\\n\\n其实这是我第一次感受这么高的海拔，总担心自己会晕厥或者出现什么恐怖的症状。但是现实还是告诉我，海拔 3000 和 4000 还是有很大的区别的。这高原反应（不知道算不算是）体现在我的身上就是走起路来很费劲，看了看表发现，简单爬几步楼梯心率就上了 130，往后甚至能上 140。\\n\\n\\n\\n\\n\\n按照国际惯例的最高心率为 $220 - 年龄$ 的话，其实也妹有什么好担心的~\\n\\n\\n膨胀的薯片\\n\\n走路上会经过汶川、茂县和松潘这几个我只听说过但从没想到这次旅途会经过的地方。听着导游讲解着这里的历史，也的确能让我想象出一些苦痛的回忆，即使我没有经历过——也可能是我太多愁善感了吧。\\n\\n\\n\\narning\\n在路上会有很多看似和实则为前往九寨沟游客设计的超市或者餐馆。性价比就不提了，但他们会借着路途遥远的事实，声称「越往里面越贵」。后来发现实际上进去以后价钱虽然贵一点但是都差不多，但最外面的是最贵的。我所遇到的最坑的地方位于下面照片拍摄角度所在处。\\n\\n\\n很坑\\n\\n例如一碗自热米饭，正常价格￥12，九寨沟附近价格￥20，此地价格￥40，并声称越往里越贵。属于是纯纯大冤种超市了~\\n:::\\n\\n\\n进了九寨沟景区大门以后，会到达九寨沟 Y 字形路线的最底端，然后就是通过乘坐免费的公交车一路前往 Y 字的交支点处，那里貌似有一种大本营的感觉。当然这只是路上导游介绍给我的感觉，实际上根本没到那里去过或者说停留过多久。\\n\\n\\n景区入口\\n\\n去景区的不乏有许多外国人。也难怪，因为在网上九寨沟的画风大概是这样的：\\n\\n\\n维基百科\\n\\n九寨沟景区内自带（简易版）导游，负责在乘车过程中的一些讲解，所以即使是在外面有了旅游团，导游并不一定会跟进去。当然，这也正合我意，可以在里面自由行了呢。公交车是遵循景区的调度的，也就是看景区哪个地方人相对少一点就让车把人拉到哪里去，并不是一站一站地停，也不是想去哪里就去哪里（除非走路，但是尊的很痛苦）。这也就让一部分人坐在车上突然没办法到计划中的目的地从而产生一种失控的感觉。\\n\\n没有到具体的地方，还是不知道九寨沟长什么样。但是这一次，在景区公交上就可以粗略地见识一下九寨沟的水大概是什么样子了。下图是九寨沟的地图，景区的公交会直接从入口将游客接到「诺日朗中心站」，在路上路过的景点都是可以在车窗里看到的（其实刚开始我还幻想着到时候往回走再看，结果...）。\\n\\n\\n九寨沟地图\\n\\n不过我的运气可能算是还好？虽然导游推荐的是先看右支，但是由于调度，我先把 Y 的左支看了，又让车直接带到了右支（本来准备去中间吃饭的），最后也成功到了中间。这种混乱最终又莫名完美完成路线的感觉还是比较奇妙的。左支和右支各自有对应的景点，车先是将游客送到尽头，然后让游客自行向中心走。在中途可能会存在一些站点，在这些站点可以上车坐到诺日朗中心站（但不能返回）。\\n\\n但是不得不说在两个支里走的过程还是比较折磨的，因为路途很远... 当天应该走了不下十几公里，那腿是真的要断了的感觉，为的只是一些照片。下面就是当时拍摄的一些照片（经过了一些压缩和格式转换）。\\n\\n\\n长海\\n\\n\\n长海\\n\\n先是到了长海，也就是左支的终点。那是第一次近距离接触九寨沟的水，所以给我的震撼还是蛮大的！那天天气很好，但是由于海拔高，当地的气温应该是个位数？总之就是特别特别冷，然后走路也比较累（更确切地说，并不是体力上的累，而是喘不过气）。但是因为气温比较能接受（我怕热不怕冷），所以走起路来并不难受，甚至还有点激动。\\n\\n\\n五彩池\\n\\n\\n五彩池\\n\\n没有记错的话，上面应该是叫五彩池，相比于长海就没有那么的广阔，据说这是因为枯水期。然后左支能看的就没了，这也是导游推荐先去右支的原因。\\n\\n右支的旅途并没有直接到原始森林，而是到了芳草海以后逐步往下。原始森林也确实感觉没有精力探索了...\\n\\n\\n芳草海\\n\\n芳草海实际上是一片湿地，中间有贯穿的河流。里面生活着一些鸭子。再往下走就是天鹅海、箭竹海、熊猫海。值得一提的是，前往熊猫海的途中还有一段栈道，两边是水浸的小树林。这种景象的确能给人很多精神上的活力，因为水又清又蓝（或者绿？），空气很清新，气温也不高。\\n\\n\\n箭竹海\\n\\n\\n清水流经的林地，流速不小\\n\\n这里不乏一些倒在水体中的树木。在后面的五花海更加明显。下面应该是在熊猫海或者箭竹海里拍到的树木，富有美感。\\n\\n\\n\\n在往五花海走的路上，遇到的一群鸭子也看起来清秀许多。它们是从远处慢慢游来的，这也是我第一次这么近距离接触鸭子，还蛮可爱的~\\n\\n\\n清秀的鸭子和它们在水里的倒影\\n\\n\\n\\n其实我也比较好奇这里水底长的是啥植物。下面就是几张从五花海开始向下进发图中拍到的图片啦，都很美是不是~\\n\\n\\n\\n\\n\\n\\n\\n过程中还发现树木上卡着的一颗石头，这让我不禁想起 2017 年的九寨沟地震...四川所在的地方地质灾害还是要比别的地方要频繁一些。我也从未料想到会在人们聚集的地方发生地震。想到这里，晚上就心有余悸，但是 iPhone 又没有地震提醒功能，我甚至还为了平复心情安装了一个 ICL。\\n\\n\\n\\n再往下走，靠近诺日朗中心站的地方，就是珍珠滩瀑布。这里格外吸引人貌似就是因为这里曾经是西游记的取景地，但是不得不说这一点并不吸引我，我来这里也只是走流程...瀑布的话就是瀑布的样子，但是上面的滩流还是比较独特的。有种想在上面走一圈的冲动（？）\\n\\n\\n珍珠滩瀑布的「滩」\\n\\n\\n珍珠滩瀑布的「瀑」\\n\\n基本上在左右支的游览内容就是这些，拍摄了几百张照片，也走了超多的路。实际上到了珍珠滩这里的时候我已经彻底走不动了，不得不原地坐下休息了 20 分钟左右才得以继续。但是...貌似休息了也没用啊 ^_^\'\'\'。\\n\\n继续往下走就是镜海，但是当时实在是太累了就停下来吃饭了。总之游到这个时候总感觉有些视觉疲劳...但是最初看见这些海子的时候的惊讶，还是难以磨灭的。\\n\\n\\n镜海，类似于长海\\n\\n最后就来到了诺日朗中心站，向下步行大概 500m 左右就到了诺日朗瀑布。到这个时候我才发现我来的时候还是想太多，根本走不动！\\n\\n诺日朗瀑布\\n\\n看完具有象征性的诺日朗瀑布之后，就坐公交直接离开了~ 在这里公交在路上是会停站的，怎么来的时候没有发现...总之呢，九寨沟到这里就是看完了。也还算是比较满意吧，毕竟最后蓝蓝绿绿的都要视觉疲劳了，但的确这是难得一见的水景，搭配上这种气温，还是有点享受的。但是同时又有痛苦，那就是实在是太难走了！全程走路的动力就是看景，以及没车坐的现实。\\n\\n\\n林间随手拍 1\\n\\n\\n林间随手拍 2\\n\\n离开了九寨沟的下一站就是黄龙，虽然在地图上看黄龙距离九寨沟有 100 多公里，但实际上这算是整个路途中比较近的了...而且，走完黄龙以后给我的感觉就是，黄龙必须跟九寨沟在一起才能有人去，因为内容相对来说还是比较少的。黄龙景区内，大概就是去上面看一下黄龙沟里的五彩池，然后如果有体力的话再走下去（走过九寨沟，我是没体力了）看看沿途的原始森林和流水。\\n\\n山上的五彩池还是比较惊艳的。\\n\\n\\n\\n\\n\\n\\n\\n这池里也不知道长的是什么藻类还是细菌之类的，给人的感觉很奇妙。7 月去的时候感觉黄龙似乎没水了？流水水量都很小。也不确定是不是一直都是这样的。五彩池下面还有一座寺庙，我也不信佛不知道能不能拍，无所谓了，还是放出来叭。这个烟雾缭绕——还是挺有感觉的~\\n\\n\\n\\n大概在五彩池下 200m 就是景区游览车和步行栈道的交叉点，在这里可以选择下山的方式。本来是准备坐车上山走下山的，结果没走几步（大概 300m？）就受不了了，来回简直要死要活的，还真是爬几步楼梯都费劲。最后不得不去坐游览车...但是走去的路依然很难熬啊啊啊啊啊啊啊啊！\\n\\n峨眉山与乐山大佛\\n\\n乐山大佛\\n\\narning\\n下列文字可能存在对佛教的质疑甚至亵渎，请相关宗教信仰人士迅速撤离。这不是演习。\\n:::\\n\\n首先需要强调一下，峨眉山跟九寨沟完全不在一个地方，所以前后没啥关联！\\n\\n峨眉山和乐山大佛的关系就类似于九寨沟和黄龙的关系，两个地方挨得很近，同样是景点。峨眉山甚至没有独立作为景区，而是和乐山大佛一起作为一个整体景区。无论如何这次去这两个地方，给我的感受还是比较复杂的，这个我们后文再详细说，首先先把为数不多的景色看完吧。\\n\\n去乐山大佛的那一天很热。因为海拔比较低，所以就回归了一般的盆地气候，该热还是热。不过其实这也是旅途过程中很正常的事情。由于是打包在一起的，不去白不去，于是就去看佛了。后来发现，这佛教的浓度可不是一般人能吃得消的。\\n\\n顾名思义，乐山大佛在乐山。乐山大佛的导游，应该都是乐山本地的导游。原本我觉得导游带你去看啥就看啥好了，他讲的东西感兴趣的听听也没事。后来才发现，哪怕是声称「纯玩」的团也难免陷入这样的境地。\\n\\n导游的路线规划是先从隔壁的东方佛都进入，然后再进入比邻的乐山大佛景区。从进了佛都以后导游就交接了，换成了景区的专属导游，也是本地导游，是一个大概二三十岁的年轻女人。到这里我还觉得一切都还比较正常捏。\\n\\n东方佛都里面就都是佛，有小的也有大的，总体上给我的感觉就是一个稍微土气一点的雕塑园，走一会儿就过去了。由于实在是提不起兴趣所以就没咋拍照，下面重点集中在经历上的分享和相关奇葩事的评价。\\n\\n首先我们经过了一个类似于公园的地方，有树荫遮盖。公园里可见各种长着许多手臂的佛像。从这里开始，导游就开始强调有些佛像面前不可以拍照，或者不可与人合照。说着感觉挺严肃的，而具体给出的理由却是一些故弄玄虚的「这个池子里的都是女妖，你要是跟她们合照，那下一个妖精就是你」这类说辞。我就没怎么在意，当玩笑话听了听。\\n\\n过了公园以后，到了一个叫「千佛洞」的山洞里，不清楚是人造还是自然生成。洞里的墙上雕的全是佛像和菩萨像，也有一部分类似于和尚。这与导游先前给我们描述的比较符合，就是可能对我这类完全不感兴趣的人来说震撼没那么大。\\n\\n\\n\\n还有一面墙上雕刻的是轮回的转盘，下面用标准的英语（不是机翻）写的有模有样的，也用上了一些佛学的专有名词。这一段英语的确帮助我更好地了解墙上刻的内容的含义，他是谁，他经历了什么，虽然都是传说。\\n\\n\\n还是挺抽象的\\n\\n而在这个过程中，我实际上算是短暂脱团了。因为当时一排同行的人就站在一个地方听着导游讲。我寻思讲讲佛像的含义，解读一下牌子上的内容，也没啥问题，我自己看我自己的得了。但是我听到的东西却越来越不对劲。导游开始举一些例子——「你相信报应吗？你相信因果吗？」然后说了一大堆现实中的因果，得出的结论大概是因果报应是肯定存在的，你种下什么的因，就会结什么样的果。\\n\\n为了解释这里，她还冒出了这样一句暴论：「就是说现在本来还有很多科学无法解释的东西啊，科学的尽头就是玄学。这些东西你可以不信，但是你得尊重」。我想的话要是前面这句话是真的义正言辞说出的，那后面这句话其实就可以当屁了不是吗？\\n\\n到这里，虽然讲的是前因后果这种当成一般逻辑来理解也没什么问题的观点，但是凭这种含糊其辞又一本正经的讲学态度，我就觉得导游有点不对劲了。为什么她的语气是那样的较真，甚至一点戏谑都没有？后面的经历告诉了我答案。\\n\\n走过千佛洞，来到药师佛脚下。这里导游说了一句话，含义与「无论谁，有钱或者没钱，来都一定要拜一下药师佛，因为只有拜过药师佛才能保你全家不受疾病的侵袭」类似。当时的语气以及内容，给人的感觉就是「如果你不拜，那就可能出现灾祸」，而不是说有信仰的人拜拜即可。正当我在担忧会不会是一群人排着队去拜的时候，旁边供的莲花灯吸引了我的注意力，于是我又脱团去拍莲花灯。后来发现也有和我一样脱团出来的，其余的人正在跟随导游学习拜佛的姿势。\\n\\n\\n药师佛\\n\\n看到这莲花灯让我想起来，我还是生活在一个商业化的现代世界里，因为这灯也是花钱供的。莲花造型的蜡放在类似农村请客用的塑料碗里烧着，摆在药师佛的两边。我就暂且当它是一种虔诚，与我无关的虔诚。\\n\\n\\n一排排的莲花灯 - 1\\n\\n\\n一排排的莲花灯 - 2\\n\\n\\n香炉\\n\\n离开了这药师佛就要转向乐山大佛了。去乐山大佛的目的就是去看这个大佛雕像，然而，现实是进入景区以后是大佛的头顶，若想要看到大佛的全貌，则需要通过阶梯先下到底部再走上来。但是令人困扰的是这一路非常的狭窄，所以会出现十分离谱（不是一般离谱）的堵人景象。导游在到达那里之前就告诉所有人，可以选择下去再上来，只是会非常累，如果所有人一致选择不下去，则直接跳过进入下一个地方。到了现场我也确认了这一说法是真实的。但其实下不下去对我来说意义并不大，我也就看个热闹，主要想去的还是峨眉山嘛。\\n\\n于是就先在大佛的头顶上逛了逛。大佛的头顶附近有一座碑，上面写的是景区的定义、评级和坐标一类的东西。这个时候导游又开始故弄玄虚地说「你知道神秘的北纬 30 度么······」。我先跑了。\\n\\n不过至少在顶上还教会了两个阿姨使用开柜的自动售卖机。至今还记得阿姨的那句「小子你是怎么搞的？」\\n\\n过了大佛以后才是重头戏。在那之后到景区出口之间存在着许多寺庙。在寺庙里又有很多讲究，例如按照导游所说的某种佛是可以摸的，但是只能摸一个部位，还只能怎么样摸。人类精神世界丰富起来是可能立一些抽象的规矩，这我理解，我也不怎么参与。到了另一尊闪着金光的菩萨面前，导游便开始了她的表演。\\n\\n面对这尊菩萨，导游讲述起了 2017 年九寨沟地震的事情。\\n那一天（还是前一天）是佛祖的生日，有一家人刚好来到这里拜佛，家里的老太信佛，想要等待寺庙的活动结束以后再出发前往九寨沟，没想到第二天就地震了，他们全家就此在寺庙里躲过一劫。然而，你以为这里没有地震吗？这里的确地震了，楼顶都震塌了，但是只是佛像被砸碎了，一家人都毫发无伤！他们家是开鞋厂的，挣了很多钱。所以他们就捐了千万在这里修筑了你们面前的这个菩萨。\\n\\n不过，按照先前这位导游义正言辞地说出「科学的尽头就是玄学」，说出上面这些也不是很奇怪了。还没有完。\\n你们知道本命年的传说吗？知不知道「压岁」到底压的是什么？压的那叫太岁，太岁就是木星，木星围绕地球旋转，于是形成了十二个月，也就形成了十二个生肖。有些人以为自己在本命年是最吉利的，但是实际上本命年是要去除太岁的！\\n有些人是根本不懂玉的。真正能压岁的玉，菩萨底下必须得有坐骑。我们乐山这边的玉······\\n\\n果然是营销套路，还是一种令人极度反胃的营销套路。从一开始就让我感觉不对劲，到这里彻底不装了。虽然我不信佛教，也不怎么关注佛教，但是这不是一种对佛教的扭曲？（虽然我不知道这算不算是佛教在扭曲自己）因为无论从哪个角度来看，上面的这些话，都可以算作是彻头彻尾的迷信。\\n\\n更离谱的在下面。\\n我说的这些都是我们当地的佛协会要求的。人在做天在看，我没有经历没有依据是不敢在这里胡说八道的。我和我老公我孩子一家人在，我在这里讲这些也算是一种积功德吧！\\n\\n我是完全想象不到一位长得还算可以的年轻女性，能够用标准的普通话流畅地说出这样一句匪夷所思的话来。我也不好怎么评价。也许，这就是所谓的「个人信仰」吧。\\n\\n在上面游览的过程中，她反复强调寺庙里是不能拍照的。我想，如果她是正经介绍「佛教的历史和来源」、「人们为什么需要佛教」、「现代佛教是什么样子的」之类的不那么抽象的议题，我还可以姑且认为「不能拍照」这一规定是由真正有健康信仰的人所订立的精神追求，我愿意尊重。\\n\\n可是上面说的这么多茬，给人的感觉就是一群不幸的人借此名头来麻痹自己，来发疯，一群别有用心的人又借此来赚钱。那这「不能拍照」的规矩，是想让我尊重谁？\\n\\n总而言之，最后她还是带着许多人去买玉去了。公交车隔了差不多半个小时才来，我直接上车吹空调去了。过了 40 分钟一部分人才购物完毕回到车上来。\\n\\n我看，即使是花了「大价钱」买来的非购物团，也难逃乐山导游的魔爪。\\n\\n所以我说这佛教浓度不是一般人能吃得消的。\\n\\n相比而言，彝族人所开设的峨眉院子，虽然也是营销项目（卖银饰的），但带领我们的人总归还是让人领略了一下特色食物和他们制作的木酒杯和酒（我觉得如果卖这个的话我肯定会买），也让我们感受到了一种非常真实的热情，还了解到他们山区的概况。\\n\\n而乐山导游，令人反胃。\\n\\nanger\\n不知是前往哪个景点的路上，旅行团组织了去当地的一个不知名（因为我去的时候很冷清，具体叫什么名字，等想起来再补充）的寺庙里参观。主持的人面容肃穆，我一看就知道不是什么善茬，就直接留在寺庙外面等待里面的人结束。于是让我意想不到的事情发生了。一个年纪很轻的女生被另一名女生扶着出来，抹着眼泪。然后就听闻说是这女孩捐了 100 块钱，然后就被主持莫名其妙地骂了一句：祝你越来越穷。\\n\\n当时我是觉得这个世界是越来越抽象了。先是到莫名其妙的地方，然后发生莫名其妙的事情。\\n\\n在车上同行的人还吐槽说，刚进去好奇，问这个佛像什么来头，然后就被主持怼了一句你懂甚么？\\n\\n我相信不是所有人都是瘪三神经病。\\n:::\\n\\n峨眉山\\n\\narning\\n先前在乐山推销的玉，付了钱还没有结束。作为一个忠诚的信徒，你需要和自己的行程拼凑着一起上峨眉金顶，找相应的人为你开光。\\n\\n我看见的，是室内佛像上堆积的人民币钞票。我听见的，是「拿着香，从这里上去···」。\\n\\n下面就不再对这一类事物进行评价了。\\n:::\\n\\n峨眉山也有专门的导游，但是这位导游就显得专业且专一许多。在听他讲解寺庙的时候，能够真正听到想听的东西。例如在讲述一个佛可以保佑身体部位健康的时候，他自己提出了一个设问：「那我是不是哪里不舒服就摸佛像的哪里？」「那当然不是了，这就是一种迷信。还是要自己保养好自己的身体，养成好的生活习惯了」。\\n\\n没错，峨眉山上也有许多寺庙，但这些寺庙的强度就要比乐山的小一些，导游讲的内容也正常。寺庙可以算是峨眉山上除了山以外的首要看点了。去峨眉山是为了到山顶上，也就是金顶（最开始我以为这是对山顶的美称，后来发现是寺庙名）。爬峨眉山还是比较麻烦和痛苦的，所以我选择的路线是一路转车加上小段步行再加上缆车。本团导游也会给出不到达金顶的路线，后来被证明是坑（因为有点像是白来），但是轻松。\\n\\n\\n步行道路上准备好的泡面\\n\\n其实还是比较庆幸那天天气是阴雨天，但是神奇的是依然能清晰地看见佛像和寺庙建筑。导游的意思大概是这也是在这种天气比较罕见的可见度了。\\n\\n\\n稍微有太阳光露出来的时候的华藏寺\\n\\n\\n能见度高时的普贤菩萨\\n\\n而且在这样的悬崖峭壁上，还看到了松鼠捏~\\n\\n\\n\\n松鼠附近的地上凌乱的大概是垃圾和食物碎屑，看起来稍微有点不爽。总之还是了解到了这一片是经常有松鼠出没的。\\n\\n普贤菩萨底下是可以进去的，内部大概长这样：\\n\\n\\n\\n虽然不知道该不该说，但是看到其中有些年轻的面孔我就特别不理解，是家里腰缠万贯没别的事情做来峨眉山上追求信仰，还是觉得工作太累到这里来骗饭吃？哪种逻辑我都想不通年轻人在这里修个什么劲，也许是我太过于没有信仰了吧。他们在念经的同时，我看到了这两个二维码，竟然有一点想笑。\\n\\n下山就是看一些寺庙了，没啥好看的。就放个寺庙里的喵喵吧。不过这猫好像很老了，看上去特别沧桑的样子，尤其是第二只。\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n除了猫，还有...\\n\\n\\n？\\n\\n\\n？\\n\\n看到真的野生猴子在路上窜来窜去还是比较惊悚的，因为听说它们会抢东西。我就很害怕会把我手机抢掉。更离谱的是在一片幽暗的树林里全是猴群，还是上山的人用弹弓打散的。在一个转角处还看到不远处的猴子就立在栏杆上，等着行人过去。\\n\\n所以怕猴子的还是别来了，容易崩溃下不去山...\\n\\n快要到终点的时候拍的，这才是我想象中的峨眉山景啊！\\n\\n彩蛋\\n\\n\\n\\n\\n\\n\\n\\n我想，若苦痛也可以算是一种乐趣来反复摆弄，那或许也的确是一种独特的精神财宝。","filename":"Chongqing-Chengdu-Tour-2","namespace":"post"},{"title":"Hello World","filecontent":"desc: Hi. 欢迎来到我的博客！\\ndate: 2019/08/17\\nHello World\\n\\nHi. 欢迎来到我的博客！\\n\\nHello\\n\\n这里是我经常撰写有关自己或他人的事迹与感受、对事物的看法和评价、一些日常工作中可能遇到的技术性话题讨论以及一些业余的教程的地方，感谢您的关注！本博客的所有内容，除了引用他人的语言或图片等媒体，以及有特殊声明外，均以 MIT 协议开放。\\n\\n我个人从 2016 年开始撰写博客或者类似的内容，起初是 Wordpress，后来觉得太臃肿就随大流更换到了 Typecho。经历了一次或多次的主动或被动「删库」以后，我懂得了「无论博客的内容有多么的冷门、小众或者业余，挑选一个稳定的环境是最有必要做的事情」。后来我又了解到，「博客」实质上是「写给自己看的」。如果有人关注我、给我写评论、为我叫好，我会非常开心——只不过对目前而言为时过早，我并不对这些具有信心，也不奢求能够得到他人的赞许或者批评。因此，本博客在短时间内并不会开放评论，基本上可以算是写给自己看了...\\n\\n无论如何，您依然可以通过这里的联系方式找到我，我一般周末在线。\\n\\nWorld\\n\\n本博客的所有内容和基本网页已经放置在了 GitHub 上，仓库地址为 。但是我并不会使用 GitHub Pages，反而会使用更稳定（价格也更昂贵）的阿里云 ECS。 光速打脸！ 2019/8/31 本博客正式迁移至 GitHub Pages。同时，我也将本博客的域名 subilan.win 续费至了公元 2024 年，这一切只为了能够提供给各位良好的阅读体验，和避免自己的心血被第三方干涉掉。\\n数据无价，做好备份是必要的。在先前的某次事故后，我领略到了这一点。不过，如果你要问我为什么没有备份，那是因为碰巧备份已经满了——我的所有资料均备份在同一个地方。于是被清除掉了，不久之后就发生了原博客被删库的不幸事件。\\n\\n这就是博客「正式成立」以后的第一篇博文，希望您能喜欢。","filename":"Hello-World","namespace":"post"},{"title":"Swift 学习笔记（一）——A Swift Tour","filecontent":"date: 2023/11/19\\ncate: 代码\\nSwift 学习笔记（一）——A Swift Tour\\n\\nA Swift Tour 是 Swift 官方文档中的一篇用来浅略介绍 Swift 一些主要特性的文章。这样的一种 touring 往往能够让具有一定基础的学习者更快地了解到这个语言（或者框架）相对于其它语言有了什么样的区别和特性，同时也可以作为一种「前参考」，即通过阅读这样一篇文章，可以知道大体有怎样的工具，进而在有相关需求的时候知道参考这些工具的具体概念和定义。\\n\\n这篇文章不是对原文的中文翻译（官方中文翻译：），其中掺杂了一些我个人的解读和想法。\\n\\nip\\n下面的「闲言」和「阅读笔记——About Swift」两节不算正文内容~\\n本文中的内容仅仅是基于阅读 A Swift Tour 后的认知所编写，不保证在将来会发生一些改变。如果本文中存在一些纰漏，将在将来的笔记里进行修正。\\n:::\\n\\n闲言\\nIt’s a safe, fast, and interactive programming language that combines the best in modern language thinking with wisdom from the wider Apple engineering culture and the diverse contributions from its open-source community.\\n\\nSwift 被 Apple 认为是具有 Apple 哲学的语言。我想，Apple 哲学的一些体现，抛开那些隐藏在生产线背后的不确定是利益、真正的责任感，还是二者杂糅的一些产物来说，大概最接近我的，是在一些明面上的事物，如实体设计——Apple 的一些产品的外观设计（总体），软件设计——macOS 系统本身的设计上。它追求一些细致和直观，但同时在可扩展性上又显得有些「极力追求独特」，当然有时也会做出迫不得已的让步（如 Apple Silicon 上的 Rosetta，Numbers Pages Keynotes 对 Microsoft 格式的支持）。\\n\\n我不清楚 Swift 是否可以算作是「有美感」，但它作为一门编程语言，本身就迈出了对于 Apple 来说可能很大的一步——开放（参考 Introducing Swift on Windows）。\\n\\n而通过我对 Swift 这一浅浅的了解，大概可以（目前）推断出它确实解决了一些编写过程中的痛点。这也是我第一次在语言设计本身上见到类似于 hook 的东西（willSet 和 didSet），以及一些似乎没有在其它语言中见到的，符合直觉的 extension、mutating func。还有一些语法上的新颖，如当 enum type 是确定的时候，可以直接省略 enum name 用 .case_name。\\n\\n阅读笔记——About Swift\\n\\nAbout Swift 是对 Swift 的一个简单总述，但好像确实说出了很多花来。\\n... combines the best in modern language thinking with wisdom from the wider Apple engineering culture ...\\n... guiding principle that the obvious way to write your code should also perform the best ...\\n\\n其中最吸引我的就是上面的第二句话，一种认为好好写明确的代码就应该能得到好性能的 principle（不知道是不是这样）。除此之外还有一些\\n\\nIts combination of safety and speed make Swift an excellent choice for everything from “Hello, world!” to an entire operating system.\\nIt’s an industrial-quality programming language that’s as expressive and enjoyable as a scripting language.\\nThe compiler is optimized for performance and the language is optimized for development, without compromising on either.\\n\\n你最好是 \\\\^_\\\\^\\n\\n基本的数据类型、变量和字符串\\n\\n一个语言最基础的部分，无非\\n\\n如何去声明、定义变量和常量\\n它们的数据类型如何被确定\\n关于字符串\\n一些 collection-like 类型\\n\\n1. 变量和常量的定义、数据类型的指定\\n\\n在 Swift 中，定义变量使用 var，定义常量使用 let。Swift 里这样的一种模式让人不禁联想到 JavaScript 中变量既可以用 var 又可以用 let 来声明、变量可以重定义以及 var 和 let 实际上控制的是变量的作用域的这些混乱且没有逻辑的表现显得无比诡异。\\n\\nlet implicitDouble = 70.0\\nlet explicitFloat: Float = 70\\n\\n默认情况下，带小数点的数字会被推断为双精度浮点型。\\n\\n2. 类型转换\\n\\nSwift 中没有隐式类型转换，保证了类型安全。其它的现代语言大都也都具有这样避免隐式类型转换的倾向，例如 Python。\\n>> \\"a\\" + 1\\nTraceback (most recent call last):\\n  File \\"\\", line 1, in\\nTypeError: can only concatenate str (not \\"int\\") to str\\n\\n\\n\\n强制类型转换可以通过创建实例来实现\\n\\nlet concatenation = \\"Something magical will happen here: \\" + String(123)\\n\\n3. 字符串\\n\\nSwift 自带 String 类型，可以直接创建字符串 \\"String\\"。字符串的模板化使用的是 \\\\(expression) 的语法：\\n\\nlet scoreMessage = \\"Your score is \\\\(score).\\"\\nlet costMessage = \\"The cost is $\\\\(cost).\\"\\n\\n多行字符串使用的是三个双引号。\\n\\nlet heredoc = \\"\\"\\"\\nNot Indented\\n    Indented\\n\\"\\"\\"\\n\\n注意后一个三引号。这个三引号可以理解为定义了一个缩进零点，与这个三引号缩进相同的文本被视为是没有缩进（0 缩进），缩进高于这个三引号的文本的缩进会被正常显示，缩进低于这三个引号将导致语法错误。\\nIndentation at the start of each quoted line is removed, as long as it matches the indentation of the closing quotation marks.\\n\\n\\n\\n上图中的 quotation1 和 quotation2 的值是等价的，可以注意到它们的缩进零点不同，由后一个三引号定义。\\n\\nquotation3 中出现了 Not Indented 的缩进低于后一个三引号的状况，所以出现了 Insufficient indentation of line in multi-line string literal 的错误。\\n\\n下列代码\\n\\nlet quotation1 = \\"\\"\\"\\nNot Indented\\n    Indented\\n\\"\\"\\"\\n\\nlet quotation2 = \\"\\"\\"\\n    Not Indented\\n        Indented\\n    \\"\\"\\"\\n\\nprint(quotation1)\\nprint(quotation2)\\n\\n结果为\\n\\nNot Indented\\n    Indented\\nNot Indented\\n    Indented\\n\\narning\\n放置在三引号里的双引号不需要转义。\\n:::\\n\\n4. 数组、元组和词典\\n\\nSwift 中的数组和词典均用方括号（brackets）来定义，其类型表示为 [Type] 和 [KeyType: ValueType]。\\n\\nlet numbers: [Int] = [0, 1, 2, 3]\\nlet stringToNumberMap: [String: Int] = [\\n    \\"zero\\": 0,\\n    \\"one\\": 1,\\n    \\"two\\": 2,\\n    \\"three\\": 3\\n]\\n\\n空数组用 [] 表示，空词典用 [:] 表示。空数组和空词典在赋给新定义的量时必须先指定其数据类型。对比上，TypeScript 若要正确推断类型，也有这样的要求但不严格，不指名的空数组会被直接推断为 never[] 类型；而 Java 则是在创建相关 Collection 类时需要用泛型来指代。\\n\\nlet numbers: [Int] = []\\n\\nlet numbers: number[] = [] // 不指明 number[]，空数组被推断为 never[]\\n\\nvar list = new ArrayList();\\n\\nSwift 中的元组（tuple）用途简单，即一次性多项传值和一次性多项返回。元组可以使用类似下标的数字来访问，例如\\n\\nfunc getMinAndMax(_ numbers: [Int]) -> (min: Int, max: Int) {\\n    var min = numbers[0]\\n    var max = numbers[0]\\n\\n    for n in numbers {\\n        if n > max {\\n            max = n\\n        } else if n  10 { \'🎉\' } else { \'\' })\\")\\n\\nPython 中的相关语法则更像是一种倒装的语序。\\n\\nprint(f\\"Score: {score:d} {\'🎉\' if score > 10 else \'\':s}\\")\\n\\n2. Optional 量（Optionals）\\n\\nOptional 可以简单理解为 TypeScript 中的 type | null 联合类型，即要么是相应的值，要么是 null（在 Swift 中是 nil）。Optional 和 if 搭配起来可以形成一种特殊语法 if-let。\\n\\nif let value = optionalValue {\\n    // 当 optionalValue 可以被展开的时候（optionalValue 不是 nil）执行\\n} else {\\n    // 当 optionalValue 是 nil 的时候执行\\n}\\n\\n上面的语法也可以简写为 if let optionalValue {}，此时花括号内可使用的变量是经过展开后的 optionalValue。\\n\\nip\\n文档里对于一个非 nil 的 Optional 值被正确作为原类型使用的情况，存在一种对 Optional 量「展开」（unwrap）的描述。我想这也是 Swift 相对其他语言的一种不同之处。在这里，可以将 optional 值 T? 理解为一种特殊的泛型 Optional，它决定了具有该泛型的表达式在具体被取值时候的返回具有两种可能性，这种在取值时对原值或是 nil 的内部选择就是 unwrap 的过程。\\nIf the optional value is nil, the conditional is false and the code in braces is skipped. Otherwise, the optional value is unwrapped and assigned to the constant after let, which makes the unwrapped value available inside the block of code.\\n:::\\n\\nSwift 中存在空合并运算符（null coalescing operator）双问号 ??。这是对 optional 量的另一种处理方法：optionalValue ?? defaultValue。\\n\\n在这里就不得不提 null 这样的一个值了。在其它某些语言中的 null 可以被直接赋给几乎任何类型的值，也可以作为一些类型值的默认值，这种缺省机制在有些时候被语言本身采用。这种 null 的广泛存在导致了一些代码中几乎所有变量的存在不具有保证，产生许多额外的判断。注意这里的问题集中在所有上面。\\n\\n从这个角度来看，JavaScript 这种同时具有 null 和一个叫 undefined 的值的动态类型语言在这方面的代码简洁性和可维护性甚至会表现得更糟糕。在 TypeScript 中，由于值可以被作为一种不变的 literal type，在有些代码中会存在 T | null、?: T 和 T | undefined 甚至 T | undefined | null 等多种含义不定写法，但它们最终表达的大概依然只是可选值。当然不排除在一些模式下，null 和 undefined 会被明确区分且具有明确的含义。\\n\\n3. switch 语句\\n\\n文档中对 switch 语句的描述是\\nSwitches support any kind of data and a wide variety of comparison operations — they aren’t limited to integers and tests for equality.\\n\\n而通常情况下 switch 仅能被用于相等性的检查。上面所说的特殊用法，来源于一种特殊的 switch-where 写法。下面的这段代码的结构来自官方的文档\\n\\nlet vegetable = \\"红辣椒\\"\\nswitch vegetable {\\n    case \\"celery\\":\\n        print(\\"加点葡萄干就能做出蚂蚁爬在树干上的效果了\\")\\n    case \\"cucumber\\", \\"watercress\\":\\n        print(\\"可以做出好吃的沙拉捏\\")\\n    case let x where x.hasSuffix(\\"椒\\"):\\n        print(\\"这\\\\(x)辣吗？\\")\\n    default:\\n        print(\\"放汤里应该都好喝\\")\\n}\\n\\n// 输出“这红辣椒辣吗？”\\n\\n其中可以看出这么几点：\\n\\ncase-let 语句可用于拦截变量，并将拦截到的变量用于后面紧跟着的 where 条件中。这里将 case 后的表达式广泛化了，一般的 case x 是一个特例 case let a where a == x。\\ncase 结尾不需要写 break，但也可以写。做出这样的改动的基础应该是将跨 case 执行语句视为一种错误，所以这种操作直接被抛弃了。\\n多项同时 case 用 , 分隔。\\n\\n另外还有一点是这里的 switch 必须有 default 语句，否则会报错 Switch must be exhaustive（Switch 的情况必须全面）。如果需要跳过 default 情况，则应写作 default: break。\\n\\narning\\n想问问你们 Swift 人为什么在 Swift 里面 switch-case 的一般写法（Swift 文档和 Swift Playground 里的表现）中认为 case 前面应当没有缩进？😨😨\\n:::\\n\\n4. for 和 while 语句\\n\\nfor-in 可以用来遍历数组和词典。其中词典使用 for (key, value) in dictionary {} 的写法，对于不需要的值则使用 _ 代表缺省。下面是官方给出的一种从 [String: [Int]] 词典中提取出数组中全部数字的最大值的算法。\\n\\nlet interestingNumbers = [\\n    \\"Prime\\": [2, 3, 5, 7, 11, 13],\\n    \\"Fibonacci\\": [1, 1, 2, 3, 5, 8],\\n    \\"Square\\": [1, 4, 9, 16, 25],\\n]\\nvar largest = 0\\nfor (_, numbers) in interestingNumbers {\\n    for number in numbers {\\n        if number > largest {\\n            largest = number\\n        }\\n    }\\n}\\nprint(largest)\\n// prints 25\\n\\n对于 while，Swift 中仍然有 while 和 do-while 的区分，只不过后者改名叫做 repeat-while。和 if 一样，一个表达式的条件可以简写。\\n\\n此处还存在一种特殊的表达式 `m.. Functions are a first-class type. This means that a function can return another function as its value. A function can take another function as one of its arguments.\\n\\n通常支持闭包的语言都存在头等函数的概念，这一点可以参照 Wikipedia 上的一些说法\\n\\nClosure** is a technique for implementing lexically scoped name binding in a language with first-class functions._\\nThe use of closures is associated with languages where functions are first-class objects, in which functions can be returned as results from higher-order functions, or passed as arguments to other function calls; if functions with free variables are first-class, then returning one creates a closure.\\n_Closures typically appear in languages with first-class functions—in other words, such languages enable functions to be passed as arguments, returned from function calls, bound to variable names, etc., just like simpler types such as strings and integers._\\n\\n在这里可以简单区分一下函数和闭包。对于闭包，它所捕捉到的自由变量（captured, free variables），当闭包处于其它作用域时也可以正常使用。例如 JavaScript 中：\\n\\nfunction removeFromArray(array, number) {\\n    return array.filter(x => x === number)\\n}\\n\\n这里存在的闭包是 lambda 表达式 x => x === number 所创建的匿名函数（anonymous function），它被传递给 array 自带的 filter 方法并被反复调用。值得注意的是这里的 number 作为实参存在于函数 removeFromArray 的作用域，其被闭包所捕捉后则可以传递到外部去继续使用。\\n\\n一个更明确的例子是使用函数来构造函数。\\n\\nfunction d(f, dx) {\\n    return x => (f(x) + dx - f(x)) / dx;\\n}\\n\\n这里 d(f, dx) 所返回的是一个由 f 和 dx 参与构成的闭包。\\n\\n// 构造新的闭包\\n\\nvar func = d(f1, dx1);\\n\\n// 在某个 f1 和 dx1 都不存在的作用域内\\n\\nfunc(2); //  Int in\\n// do something with number\\nreturn // some int\\n}\\n\\n在一些情况下参数列表可以省略，例如当回调被用于作为回调函数时，其参数和返回值的类型实际上已经确定，此时就可以省略掉类型的注明。\\n\\n{ number in\\n// do something with number\\nreturn // some int\\n}\\n\\n若其返回值可以在一个表达式里得到，则可以直接简写为\\n{ number in expression }\\n\\n这一点类似于 JavaScript 中的箭头函数 x => expression 和 x => { /* do something */ return }。\\n\\n当参数列表数量和类型都确定时，上述表示还可以进一步简化为用数字代表指定位置的参数所执行的表达式的结果。例如\\n\\nlet x3numbers = numbers.map({$0 * 3})\\n\\n$0 表示第一个参数。\\n\\n在 Swift 中，函数的声明使用 func。\\n\\nfunc add(a: Int, b: Int) -> Int {\\n    return a + b\\n}\\n\\nfunc makeIncrementer(step: Int) -> ((Int) -> Int) {\\n    func add(number: Int) {\\n        return step + number\\n    }\\n    return add\\n}\\n\\n函数的每一个参数具有一个标签（label），这点和 Python 很相似，但在 Swift 中当标签存在时，其在传值时必须带上。参数的标签默认与名称相同，也可以通过在参数前加上 _ 来删除标签达到顺序化的效果，或者加上其它词语来更改标签。\\n\\nfunc makeIncrementer(s step: Int) -> ((Int) -> Int) {\\n    func add(n number: Int) {\\n        return step + number\\n    }\\n    return add\\n}\\n\\nlet incrementer1 = makeIncrementer(s: 4)\\nprint(add(n: 2)) // 6\\n\\n类和对象\\n\\n1. 类的简单性质\\n\\n类的属性可以使用 let、var 声明，方法可以使用 func 声明。\\n类可以有构造函数也可以没有。构造函数不写 func，而直接写作 init(...) {}。\\n在类中，使用 self 来代指当前实例本身，使用 super 来代指继承的对象，super.init 是继承的对象的构造函数。\\n类的继承不使用 extend 而是 class ClassB: ClassA 这样的表达。\\n\\n2. 方法重载\\n\\nSwift 支持类似于 Java 中 @Override 的方法重载，用法是直接声明 override func。无效重载将导致编译错误。\\n\\n3. 属性的 getter 和 setter\\n\\n除了对属性的一般定义，即类似于 let a = 1 这样的定义以外，还可以进行拓展的 get/set 定义。\\n\\nclass EquilateralTriangle {\\n    var sideLength: Double = 0.0\\n\\n    init(sideLength: Double) {\\n        self.sideLength = sideLength\\n    }\\n\\n    var perimeter: Double {\\n        get {\\n            return 3.0 * sideLength\\n        }\\n\\n        set {\\n            sideLength = newValue / 3.0\\n        }\\n    }\\n}\\n\\n这样一来，perimeter 的值将与 sideLength 产生直接的关联，且当 perimeter 改变时也会带动 sideLength 发生改变。Setter 函数的参数为新的值，当不写该参数时，新的值默认名称为 newValue。\\n\\n4. 属性的 willSet 和 didSet\\n\\nwillSet 中的代码将会在属性的值被设定之前被执行，didSet 则是在设定之后。这一「设定」的操作不包括在 init 函数里进行的操作。这两个 hook 可以被用于执行一些同步的操作，但不宜出现使用很长或者重复的多值比较来确定一个值的情况。\\n\\nvar a: Int {\\n    willSet {\\n        print(newValue)\\n    }\\n}\\n\\n5. 类的 Optional 类型和 optional 访问\\n\\n类的类型后也可以加上 ? 来表示该类不一定能被正常实例化。\\n\\nlet optionalInstance: Class? = Class()\\nprint(optionalInstance?.someProperty)\\n\\n第二行中的 optional 访问，使得当 optionalInstance 确实为 nil 时，该表达式的值也为 nil 而不会抛出错误。\\n\\n6. 枚举\\n\\n枚举可以有类型，也可以没有。若枚举具有类型，则必须是 Int、浮点和 String 之一，其余类型不能使用。\\n\\nenum Months: Int {\\n    case January = 1\\n    case Febrary, March, April // ...\\n}\\n\\n枚举的项用 case 来指定，对于有类型的枚举，每一项都具有一个原始值（rawValue）。当枚举类型是 Int 时，原始值会从第一个项开始，从 0 一直递增。当手动指定了某一项的值时，该项的原始值即为指定的值，而下一项的值为指定的值的下一个值。\\n\\n然而，当枚举类型是浮点时，默认情况下仍然是从 0.0 一直递增，但是当存在人工指定的值时，递增的规则不再适用，所有的项目均需要被人工指定值。\\n\\n当枚举的类型是字符串时，其原始值为该项的名称，如 Months.January 的 rawValue 就是 \\"January\\"。\\n\\n枚举内部也可以有方法，且当枚举类型确定时，不需要带上枚举的名称，直接写作 . 后跟上枚举项的名字即可。\\n\\n\\nenum Months: Int {\\n    case January = 1\\n    case Febrary, March, April // ...\\n\\n    func toChinese() -> String {\\n        switch self {\\n            case .January:\\n                return \\"一月\\"\\n            // ...\\n            default:\\n                return String(self.rawValue)\\n        }\\n    }\\n}\\n\\n\\n通常情况下对枚举的使用是作为常量，如 Months.January。但枚举也可以被实例化，其自带一个返回值为 optional 的构造函数，接受一个 rawValue 参数。例如下列语句：\\n\\nif let wtf = Months(rawValue: 13) {\\n    // Oh no...\\n} else {\\n    print(\\"So what are you thinking?\\")\\n}\\n\\nelse 中的语句被执行。以及\\n\\nif let january = Months(rawValue: 1) {\\n    print(january.toChinese())\\n} else {\\n    print(\\"Uh...\\")\\n}\\n\\n// 输出 一月\\n\\n枚举项亦可以有自己的参数，这在枚举的实例化中表现出一定的作用来。例如下面的 ServerResponse 枚举。\\n\\nenum ServerResponse {\\n    case success(String, String)\\n    case failure(String)\\n}\\n\\nswitch result {\\n    case let .success(a, b):\\n        // use a and b here.\\n    case let .failure(msg):\\n        print(\\"Failed. Message: \\\\(msg)\\")\\n}\\n\\n在这里 ServerResponse 仍然可以省略，且 case let 实际上向后面的代码传递的是「存在」于当前枚举项中的参数。\\n\\n7. 结构体\\n\\n结构体类似于类，可以拥有构造函数、属性、方法等。一个区别是，结构体的实例可以被形容为是「静态」的（相对于类的实例），其传递的是一种拷贝，而类的实例在传递时表现为引用。同时，结构体还有这样的特性\\n\\n结构体之间不存在继承\\n结构体没有反构造函数（deinitializer）\\n当结构体被赋给常量时，其变量属性亦不可变\\n\\n根据上述特性，结构体可以理解为是一种主要用于携带静态数据，并可能带有不牵涉外部数据的一些方法的对象。例如，注册信息可以用结构体这样表示：\\n\\nenum Level: Int {\\n    case starter = 1\\n    case two, three, four, five, six\\n    case ultimate\\n\\n    func getDescription() -> String {\\n        switch self {\\n            case .starter:\\n                return \\"Newbie\\"\\n            // ...\\n            default:\\n                return \\"Level \\\\(self.rawValue)\\"\\n        }\\n    }\\n}\\n\\nstruct RegistrationInformation {\\n    var username: String\\n    var password: String\\n    var email: String\\n    var level: Level\\n\\n    init(username: String, password: String, email: String, initialLevel: Int) {\\n        self.username = username\\n        self.password = password\\n        self.email = email\\n        self.level = Level(rawValue: initialLevel)\\n    }\\n\\n    func getLevelDescription() -> String {\\n        return self.level.getDescription()\\n    }\\n}\\n\\nvar information = RegistrationInformation(username: username, password: password, email: email, initialLevel: 1)\\nprint(information.getLevelDescription())\\n\\n此外，默认情况下一个结构体的方法不能直接修改其本身的变量属性。如果需要这样的方法，需要在 func 前显式地写上 mutating。\\n\\n异步\\n\\nip\\n作为 Tour 的内容，此部分所写的较为粗略。\\n:::\\n\\n和其它支持现代化对异步操作处理的语言一样，Swift 支持 async-await 模式。对这两个关键字的使用，也有如下常见的限制：\\n\\nawait 只能在被标记为 async 的函数中使用（有一项例外）\\nawait 只能对被标记为 async 的函数使用\\n\\n若要定义一个异步函数，使用 func K(...) async -> T 的语法。使用它时，在对它的调用之前加上 await 即可。此外，Swift 还支持一种 let async 的写法。这种写法可以使一些异步操作并行执行后取值，使用这些值时再在量前加上 await。\\nUse async let to call an asynchronous function, letting it run in parallel with other asynchronous code. When you use the value it returns, write await.\\n\\nfunc connectUser(to server: String) async {\\n    async let userID = fetchUserID(from: server)\\n    async let username = fetchUsername(from: server)\\n    let greeting = await \\"Hello \\\\(username), user ID \\\\(userID)\\"\\n    print(greeting)\\n}\\n\\nTask {\\n    await connectUser(to: \\"default\\")\\n}\\n\\nSwift 还提出了一种新的处理并发的模式，即 Actor 结构。将在后面的笔记中继续研究。\\n\\n协议和拓展\\n\\n1. 协议\\n\\n相比于 Java 中的 Abstract Class 和 Interface，Protocol 的模式能够更好（且更整齐）地反映「接受协议」、「接受约束」、「保持一致」的这种代码需求。同时，在 Protocol 中所声明的方法若需对目标的结构自身的属性进行修改，其前也要求显式地加上 mutating。\\n\\nprotocol Example {\\n    var variableProperty: String\\n    mutating func modify()\\n}\\n\\n协议可以被 Class、Enum、Struct 甚至类型（见下面的「拓展」）接受。Struct 内的 mutating function 前的 mutating 不能省略，而 Class 则不需要写 mutating，这是因为类本身就可以修改自身的变量属性。\\n\\n2. 拓展\\n\\n拓展（Extension）所针对的是 Swift 中的类型，这一概念使得类型也可以变得有无限可能。在拓展的过程中，也可以让类型去接收协议。一个很好理解的例子是为所有的 Int 加上绝对值的方法。\\n\\nextension Int {\\n    func absv() -> Int {\\n        return abs(self)\\n    }\\n}\\n\\nprint((-2).absv())\\n\\n拓展中引入的方法也可以修改值本身（用 self 表示），这样的方法前面同样要加上 mutating。此外在这里需要注意的一点是 . 的优先级要高于 -，-2.absv() 的结果是 -2。\\n\\n异常处理\\n\\n1. Error 协议\\n\\nSwift 语言内置了一种 Error 协议（实际上这个协议是空的）。根据前文，多种结构可以接受 Error 协议；接受了 Error 协议以后就可以被用来表示一个异常。例如下面的 Enum 就可以用来表示异常。\\n\\nenum HttpError: Error {\\n    case NotFound\\n    case InternalError\\n    case Forbidden\\n}\\n\\n而实际上既然类型也可以通过 Extension 接受协议，甚至可以做出这样的效果来：\\n\\nextension Int: Error {\\n    func getError() -> String {\\n        switch self {\\n        case 1:\\n            return \\"ErrorNameRepresentedByNumberOne\\"\\n            // ...\\n        default:\\n            return \\"Error\\\\(self)\\"\\n        }\\n    }\\n}\\n\\nfunc throwSomeError() throws {\\n    throw 2\\n}\\n\\ndo {\\n    try throwSomeError()\\n} catch let number as Int {\\n    print(\\"I am the number \\\\(number) and represent the error \\\\(number.getError())\\")\\n}\\n\\n// 输出 I am the number 2 and represent the error Error2\\n\\n2. do-catch 语句\\n\\n与其他语言 try-catch 不同，Swift 中的 try 关键字在 do 中被使用，且只会作用于部分语句（表达式），而非 try-catch 中的所有语句。例如\\n\\ndo {\\n    print(\\"Trying to retrieve a response\\")\\n    let someResponse = try doSomething()\\n    print(someResponse)\\n} catch {\\n    print(error)\\n}\\n\\n当 doSomething 抛出异常时，就会跳转至下面的 catch 中继续执行，且错误的默认名称是 error。除了什么也不带的 catch 以外，还有下面几种形式\\n\\ncatch EnumCase {}，使得后面的 block 中的内容仅在捕捉到 EnumCase 的枚举类型错误时执行\\ncatch let x as Type {}，使得后面的 block 中的内容仅在捕捉到 Type 类型的量 x 时执行，且 x 可以在 block 中被使用。上面的一小节中的代码段就用到了它。\\ncatch is Type，使得后面的 block 中的内容仅在捕捉到 Type 类型的错误时执行；这一点在文档中并没有提到。需要注意的是它和 catch EnumCase 的区别，is 后跟的必须是类型，例如枚举类型，但不能跟具体的枚举项。\\n\\n3. try? 语句\\n\\ntry? 可以在 do-catch 外使用，它将一个表达式的值变成一个 Optional，当语句执行成功时 unwrap，throw 时为 nil。\\n\\n4. defer 关键字\\n\\n其实我并不清楚为什么要在这里介绍 defer，也许是因为它在异常抛出时的表现有一些特殊性吧。defer 后跟的是一段 block，在函数中使用，代表这段 block 会在函数结束执行（正常结束、return 或者 throw）时执行。所以 Swift 中的函数也可以拥有自己的「初始化」和「反初始化」代码，为了可读性可以将它们写在一起，初始化代码写在 defer 外面，反初始化写在 defer 里面，并放在函数代码的最开头。\\n\\n下面是文档中给出的一个例子：\\n\\nvar fridgeIsOpen = false\\nlet fridgeContent = [\\"milk\\", \\"eggs\\", \\"leftovers\\"]\\n\\n\\nfunc fridgeContains(_ food: String) -> Bool {\\n    fridgeIsOpen = true\\n    defer {\\n        fridgeIsOpen = false\\n    }\\n\\n\\n    let result = fridgeContent.contains(food)\\n    return result\\n}\\nif fridgeContains(\\"banana\\") {\\n    print(\\"Found a banana\\")\\n}\\nprint(fridgeIsOpen)\\n// Prints \\"false\\"\\n\\n这是因为在现实意义上，操作 frigeContains 时必须要对 fridgeIsOpen 产生一种对称的修改，即从 false 到 true 再到 false 的改变。这一点在抽象意义上也可以被利用。我能够想象到的是在异步操作中根据对象的状态进行正确的处理，这种状态的变换如果具有一定的对称性，就可以通过上面的代码的类似逻辑来实现。\\n\\n泛型\\n\\n1. 函数泛型\\n\\n和有些语言一样，函数中的泛型写在参数列表前，用 `` 包含。\\n\\nfunc makeArray(repeating item: Item, numberOfTimes: Int) -> [Item] {\\n    var result: [Item] = []\\n    for _ in 0..` 包含。例如 Swift 标准库中的 Optional 类型可以这样实现：\\n\\nenum OptionalValue {\\n    case none\\n    case some(Wrapped) // 注意这里 some 括号里标注的不是形参名而是形参类型\\n}\\n\\n3. 泛型条件\\n\\nSwift 不仅支持了泛型，同时也在语言设计上支持了对泛型使用条件的约束。借助 where 可以直接声明一些泛型的适用条件，这使得一些确实需要的限制可以在编译阶段被明确表达，而不需要在运行时进行额外的检查，甚至对语言的底层进行一些操作。\\n\\nwhere 语句放在函数声明的最后，返回值类型的后面，格式是 where 条件1, 条件2, ...。例如：\\n\\nfunc equal(a: A, b: B) -> Bool where A == B {\\n    return a == b\\n}\\n\\n上面的 equal 函数要求输入的 A 和 B 两种类型必须相等，它排除了一些类似于「跨类型进行相等性比较」的不必要操作。除了类型之间的 == 关系，还可以用 : 来指定对特定 protocol 的接受情况以及类的继承情况。文档中给出的例子为\\n\\nfunc anyCommonElements(_ lhs: T, _ rhs: U) -> Bool\\n    where T.Element: Equatable, T.Element == U.Element\\n\\n其中 where 后给出的限制条件的意思是 T.Element 必须接受 Equatable 协议，且 T.Element 和 U.Element 类型相同。此外，` 的写法等价于  ... where T: Sequence, U: Sequence`。","filename":"Learning-Swift-1","namespace":"post"},{"title":"Menu 组件的基本处理和实现","filecontent":"date: 2023/07/10\\ndesc: 一些强迫症方面的考虑和最终的成功实现\\ncate: 代码\\nMenu 组件的基本处理和实现\\n\\nMenu 组件实际上并不是一个正统的称呼，但是也算是一个比较广泛使用的习惯性称呼。还有一些其它的 de facto 叫法，比如 Dropdown、MenuList 等。通俗来讲就是当一个被绑定的触发器被触发后所弹出的窗口。窗口内容通常表现为有序的列表，在某些实现里还有可能有部分的分割以及标题，例如\\nVuetify 的 Menu\\nMUI 的 react-menu\\nVueMaterial 的 Menu\\nArco Design 的 Menu\\nAnt Design 的 Menu\\n\\n值得注意的是 Arco Design 和 Ant Design 两个国内较为成熟的方案中，都同时用到了一个概念——Navigation Menu，表现为水平或者竖直方向的导航栏。它们的表现更像是某种 Sidebar 而不是后触发的弹窗，同时也它们附带了本文中传统意义的 Menu。这一组件不是本文所讨论的范围。\\n\\n在本文所述的 Menu 中包含两种元素：\\n\\n触发器*（Activator） — 即触发 Menu 的元素，通常是 Button，在必要情况下可以是任何 *link-related 元素。\\n本体** — 即 Menu 本体，默认应当处于隐藏的、不可点击状态\\n\\n: link-related 在这里具体是指任何可以当作是“链接”作用的元素，一些原生的例子包含 a、button，当然还可以根据用途重新自定义新的。\\n\\narning\\n本文中的代码仅仅作说明作用，不能保证正常运行。\\n:::\\n\\n本体的定位\\n\\n本体应当出现在触发器附近，这是毫无疑问的。为了不挤占正常文档流的空间，而仅仅作为一个弹窗或者浮窗的存在，其理所应当具有 position: absolute 属性。由此推知，为了正确定位，它必须与触发器之间存在位置上的相对联系，也正因此，一般实现起来都会用到如下结构：\\n\\n        Open Menu\\n\\n        Item 1\\n        Item 2\\n\\n\\n.menu-wrapper {\\n    position: relative;\\n}\\n\\n.menu {\\n    position: absolute;\\n    top: /* ... */\\n}\\n\\n\\n在一些特殊的例子中，并不会用到这种含有 wrapper 的结构，而是将两者相独立，这在代码可读性和可维护性上有所帮助。然而，在这种情况下若想要实现位置的相对性，则需要用到额外的 JavaScript 代码和计算逻辑，并不是一种高效的解决方案。\\n\\n本体的出现与消失\\n\\n出现与消失的实现使用正常的 active 逻辑即可，具体代码如下：\\n\\nfunction toggleMenu() {\\n    const menu = document.querySelector(\'.menu\')\\n    if (menu.classList.contains(\'active\')) {\\n        menu.classList.remove(\'active\')\\n    } else {\\n        menu.classList.add(\'active\');\\n    }\\n}\\n\\n.menu {\\n    position: absolute;\\n    /* ... */\\n\\n    display: none;\\n}\\n\\n.menu.active {\\n    display: block; /* depends on needs */\\n}\\n\\n这样就实现了下面两点：\\n本体的 position: absolute 属性确保了 Menu 不会干扰正常文档元素排布\\n在单击触发器后，可以实现 Menu 的显示状态的切换\\n\\n由于我们切换的是 display 属性，其优点是可以保证在 display: none 状态的元素不再干扰文档中的点击事件，亦可以对此状态下的本体增加 pointer-events: none 的属性。然而缺点则是无法添加任何动画效果，固然是一种不成熟的方案。然而如果想要添加动画效果，就可能会带来一些另外的问题。\\n\\n本体的显示—消失动画与相关问题的解决\\n\\n对于动画，我们首先想到的是与显示—消失直接相关的不透明度的调整。\\n\\n.menu {\\n    opacity: 0;\\n    transition: opacity .2s ease;\\n}\\n\\n.menu.active {\\n    opacity: 1;\\n}\\n\\n注意，在上面的代码中不能使用 display 来切换，否则会导致 transition 效果的丢失。然而没有了 display，即使是在 opacity: 0 的不可见情况下，其内容仍然存在于某个位置，比如触发器的正下方。这个时候当鼠标移动时，仍然会有相关事件的产生。\\n\\n为了解决这个问题，我们会自然地想到 pointer-events 属性，于是将其修改成这样：\\n\\n.menu {\\n    opacity: 0;\\n    transition: opacity .2s ease;\\n    pointer-events: none;\\n}\\n\\n.menu.active {\\n    opacity: 1;\\n    pointer-events: auto; /* 不建议使用 all */\\n}\\n\\npointer-events 属性固然好用，但是不加研究仍然可能触碰到雷区。一些对 pointer-events: none 的肤浅理解包括，它可以让鼠标“直接透过”被应用 pointer-events: none 的元素而不产生任何交互。这在某些情况下也许是对的，但并不是 pointer-events: none 所表达的本质。MDN 上对 pointer-events: none 的解释是这样说的。\\npointer-events: none - The element is never the target of pointer events; however, pointer events may target its descendant elements if those descendants have pointer-events set to some other value. In these circumstances, pointer events will trigger event listeners on this parent element as appropriate on their way to/from the descendant during the event capture/bubble phases.\\n\\n简单而言，就是该属性仅仅屏蔽了元素自身的事件，但是对于其子代元素（descendant）的事件冒泡/监听仍然会有相关的反应。此外还有一点便是，“直接透过”的效果只能发生在被屏蔽事件的元素处于某一父元素的包装下的情况，其透过后所指对象是父元素。\\n\\n例如一个 box 里装了一个 button，对该 button 设置 pointer-events: none，那么鼠标在 button 上的 events 相当于传递给了 box，这就是“透过”。然而，如果在某种布局设定下， button 对 box 有溢出，溢出的部分位于 box 的外部，且该部分下遮挡了 button2，那么无论如何点击 button，button2 都无法接收到点击事件，因为 button2 与 button 虽然有布局上的遮挡但是没有直接的父—子关系，这一点就不能称为“透过”，而只能算作“完全遮挡”。\\n\\n因此，为了避免这样的意外发生，我们最好还是避免使用 pointer-events 事件。当然，如果 Menu 满足上述的一些条件，使用起来也不会有太大的问题。\\n\\n解决方案一：z-index 的切换\\n\\n我们的目标是将 opacity: 0 状态下的 Menu 完全从鼠标事件中屏蔽掉，其中可以考虑的一个方案是调整其 Z 轴层级。当然 z-index 也不是没有坑，比如所适用的对象的 position 值不能是 static、Stacking Context 创建条件(MDN)。不过，如果你有一套较为完整的 z-index 排列，就可以考虑这个方案。\\n\\n对 opacity: 0 的状态设定最低 z-index，可以是 0、-1 等，要求低于其父级元素的 z-index\\n对 opacity: 1 的状态设定较高 z-index，要求高于其父级元素（以及应当被遮挡的一些元素）的 z-index\\n\\n这种情况下就可以避免当 opacity: 0 时鼠标仍然可以选中被隐藏的主体的问题。但这样做仍然不是完美的，因为对于其遮挡物，由于 z-index 不存在渐变的中间态，在 opacity 过渡的过程中会出现一些层级错乱的现象，取决于具体的层级设置。这一点如果不是强迫症，或者遮挡的区域没有样式大可以忽略。\\n\\n解决方案二：display + setTimeout 排除对动画效果的影响\\n\\n考虑到 display: none 可以直接满足我们的需求，并不一定要将其放弃，而是可以与 setTimeout 结合来避免同时应用效果的时候破坏 opacity 的 transition。\\n\\n.menu {\\n    opacity: 0;\\n    transition: opacity .2s ease;\\n}\\n\\n.menu.active {\\n    opacity: 1;\\n}\\n\\nfunction toggleMenu() {\\n    const menu = document.querySelector(\'.menu\')\\n    if (menu.classList.contains(\'active\')) {\\n        menu.classList.remove(\'active\');\\n        setTimeout(() => {\\n            menu.style.display = \'none\';\\n        }, 200)\\n    } else {\\n        menu.style.display = \'block\';\\n        setTimeout(() => {\\n            menu.classList.add(\'active\');\\n        }, 1)\\n    }\\n}\\n\\n进入 active 状态之前将 display 改为正常值，然后设置一个 1 毫秒的 timeout 即可实现动画效果的正常呈现。退出 active 状态后，设置一个与 transition duration 相等时长的 timeout，等待 duration 结束后再将 display 改为 none。这样就可以避免 display 的切换影响动画的过渡。\\n\\n注意，在这里不建议除了修改 display 以外的其它 style 操作。对于动画的前后状态的描述应该放在 .menu 和 .menu.active 里以避免过度使用 JS 操作 DOM。\\n\\n点击外部以关闭\\n\\n根据直觉以及一般使用的习惯而言，这样的 Menu 打开以后，可以通过单击其它部分关闭。我们在这里要首先作出一个对关闭行为的划分\\n\\n类型 1：Menu 自身逻辑导致的关闭\\n类型 2：点击外部的关闭\\n\\n这两种关闭都是关闭，但是在实现上有所区别。先说点击外部的关闭。一个常见的做法是监听 document 上的任意点击事件。这样虽然有点性能上的顾虑，但实际上这也是实现这一特性所必须的监听。\\n\\ndocument.addEventListener(\'click\', e => {\\n    const el = e.target // as HTMLElement, in typescript\\n    const activator = el.closest(\'#activator\');\\n    const menuBox = el.closest(\'#menu-box\');\\n    if (wrapper === null && activator === null) {\\n        closeMenu(); // 此处不应为 toggleMenu 而应是绝对的 closeMenu 操作\\n    }\\n})\\n\\nactivator 和 menuBox 分别对应的是承载触发器和本体的包装父元素，它们都应该有相关的可供选择器选择的属性设置。通过上面的判断可以知道是否是点击了自身逻辑范围（即类型 2）内的元素。如果没有，那就可以认定是在“点击外部”，然后就可以直接关闭了。除此之外还可以选择性地添加一个判断 Menu 是否已经开启的逻辑。\\n\\n对于第二种类型，可以自行在本体内的元素设置。将这两种类型隔开有助于有序地设定相关事件。\\n\\n完整代码\\n\\n\\nfunction toggleMenu() {\\n    const menu = document.querySelector(\'.menu\')\\n    if (menu.classList.contains(\'active\')) {\\n        menu.classList.remove(\'active\');\\n        setTimeout(() => {\\n            menu.style.display = \'none\';\\n        }, 200)\\n    } else {\\n        menu.style.display = \'block\';\\n        setTimeout(() => {\\n            menu.classList.add(\'active\');\\n        }, 1)\\n    }\\n}\\n\\n\\n\\n.menu-wrapper {\\n    position: relative;\\n}\\n\\n.menu {\\n    position: absolute;\\n    /* ... */\\n    opacity: 0;\\n    transition: opacity .2s ease;\\n}\\n\\n.menu.active {\\n    opacity: 1;\\n}\\n\\n        Open Menu\\n\\n        Item 1\\n        Item 2\\n\\n\\n`","filename":"Menu-Handling","namespace":"post"},{"title":"Sponge 搭建 1.12.2 Mod + 插件服务器","filecontent":"desc: 高版本 Mod 服又想加插件...？\\ndate: 2020/01/02\\ncate: 路径\\nSponge 搭建 1.12.2 Mod + 插件服务器\\n\\n虽然说目前 1.15.1 的 Mod 服务器实现方式已经有了（Fabric），但是仍然有本文发布的必要——因为目前能够做到高版本、支持 Mod、支持插件的只有这一种服务端，Fabric 仅支持 Mod。\\n\\n在本篇文章中会介绍 Sponge 的安装方法，也就是如何部署一个这样的服务器。\\n\\n原理\\n\\nSponge 分为三个大分支，在这里为了能够安装 Mod 我们选择 Sponge Forge 分支。\\n\\n在实际服务器中，Sponge 的文件被作为 Mod 放置在 mods 的文件夹里，与其它插件、Mod 并列。\\nSponge 中插件也是放在 mods 里的。\\n\\n也就是说，实际服务器是由一个简单的 Forge 服务器（原版服务端 + Forge）加上 Sponge 组合而成的，Sponge 所发挥的作用就是提供 API 给其它模组使之能够与 Sponge 对接，从而运作。\\n\\n这与高版本 Fabric 中的一个 Optifine Loader 类似，由于 Optifine 无法在高版本中搭配 Fabric（甚至 Forge）使用，就有人开发出了 Loader 使之能够在运行时间段将 Optifine 转换为可在 Fabric 上运行的形式。\\n\\n废话不多说，从原理中我们可以看出这整个部署的步骤和一般的 Forge 服务器类似，只不过多加了一个 Sponge 而已。\\n\\n开始搭建\\n\\n首先我们需要下载必要的文件，包括：\\n\\nMinecraft 原版服务器端 👉Link\\nForge 安装器 👉Link\\nSponge 本体 👉Link\\n\\n::: warning\\n⚠️ 注意\\n\\nSponge 对 Forge 的版本有要求，在选择 Sponge 时需要注意到其支持的 Forge 版本号。在上面所给的链接中，下载到的 Forge 和 Sponge 应分别为 forge-1.12.2-14.23.5.2838-installer.jar 和 spongeforge-1.12.2-2838-7.1.8.jar。\\n\\n注意到其中，Forge 版本号为 1.12.2-14.23.5.2838，Sponge 版本号为 1.12.2-2838-7.1.8，这代表它们是对应的版本。如果这两个版本不一致，Forge 偏高（Sponge 偏低）会导致运行不稳定，Forge 偏低（Sponge 偏高）会导致部分插件无法正常运行。\\n:::\\n\\n下载以后，首先创建一个文件夹，取名随意。在这里我们叫它 sponge-server。\\n\\n$ mkdir sponge-server\\n$ cd sponge-server\\n\\n然后，将 Minecraft 原版服务器端放入，并将其改名为 minecraft_server.1.12.2.jar。\\n\\n::: tip\\n提示\\n\\n这一步是为了避免 Forge 安装出错。Forge 安装时会尝试下载官方客户端，但是实际上根本无法下载（即使科学上网）。因此我们要用正常的途径提前下载完毕后，将其命名为 Forge 所 expect 的那样，这样它便会跳过它而开始下载 library 文件。\\n:::\\n\\n双击或使用 java -jar 打开 Forge 的安装器，可以看到下面的画面：\\n\\n\\n\\n选择 Install server，然后选择你之前所创建的那个文件夹。这时会提示\\nThere are already files at the target directory.\\n\\n然而实际上这是可以忽略的。我们直接点击确定。在这之后就是漫长的等待了——这个过程，至少对于我来说，科学上网是没有任何加速作用的。我等待了约 10 分钟。\\n\\n在这期间发生错误（下载失败）也很正常，不需要担心，只需要重复上述步骤即可，Forge 会自动跳过已经下载的文件，继续上一次进度。\\n\\n当下载完毕以后，你会发现 sponge-server 文件夹里多出了一个 libraries 文件夹，这便是我们所需要的文件。\\n\\n在这个时候，一个 Forge 服务器就搭建好了。如果上述这一切均在你的电脑上进行，那么可以使用\\n\\nscp -r sponge-server root@host:/\\n\\n将你的文件夹复制到服务器上继续进行下一步操作。这种方法适用于无法命令行的面板服务器。\\n\\n如果你直接在服务器上进行的，那么就继续往下看吧。\\n\\n这个时候，位于 sponge-server 中，也会有一个 Forge 的 universal 文件。它便是服务器核心本体了，以后启动就要启动它。我们现在就启动它，来准备服务器的一些文件：\\n\\n$ java -jar forge-1.12.2-14.23.5.2838-universal.jar\\n\\n不出意外的话服务器会顺利启动，然后就是喜闻乐见的 eula.txt 环节，同意以后继续启动，便会生成服务器的基础文件（夹），比如 logs、world、server.properties 以及最重要的 mods。\\n\\n启动成功后我们就关闭服务器\\nstop\\n\\n然后将我们先前下载的 Sponge 放入 mods 文件夹内，有打算的话可以直接把你准备安装的 Mod 放进去，重新启动，你就会发现：哇，启动速度慢了一大截呢成功了！\\n\\n这个时候，如果你在你的客户端上也安装一样的 Mod 组合，就可以直接进入服务器了！\\n\\n::: tip\\n提示\\n\\n你必须有与服务器相同的 Mod 组合才能进入服务器，当然也有例外（见下文）。\\n:::\\n\\n插件\\n\\nSponge 既支持 Mod 又支持插件，但是它们都放在 mods 文件夹里，这一点与 Bukkit 完全不同。它们的配置位于根目录的 config 文件夹中。\\n\\n一般来说一个 Sponge 服务器的 Mod 与插件方面结构如下：\\n\\n.\\n├── config\\n│   ├── plugin1\\n│   │   └── main.conf\\n│   ├── plugin2\\n│   │   └── config.conf\\n│   └── simpleplugin.conf\\n└── mods\\n    ├── plugin1.jar\\n    ├── plugin2.jar\\n    └── simpleplugin.jar\\n\\n每一个插件或 Mod 都有与其对应的配置项，放置在 config 里。一般均放置在与之同名的文件夹内，少数简单的会直接放在 config 里不带其它文件夹。通过更改它们便可以改变设置，就像 Bukkit 中的 config.yml 一样。\\n\\n区别于 Mod，插件不需要在本地客户端内安装。这就意味着你将要安装的只是那些可以玩的 Mod，而非这些只能用在服务器上的插件（例如领地、经济等）。对于 World Edit 这种既可能是插件又可能是 Mod 的尽量选择其插件版本，原因很明显了。\\n\\nSponge 的插件兼容性是通过 API 来判断的。目前 1.12.2 的版本为 API7，所以任何为 API7 接口的插件均可以用在 1.12.2 的 Sponge 服务器中。少数 API6 / API5 或更低插件也能够正常运行（例如 World Edit），但是不如 API7 稳定。但是有些则彻底不能运行。\\n\\n这也告诉我们在更新 Sponge 的过程中要慎重，如果更新版本过高，一些不再维护的插件就会失效。\\n\\n插件推荐\\n\\nSponge 界构建出了一种独立于 Bukkit 插件的体系，因此它们的主流插件也都不一样了。在这里给出 Sponge 界中常用的一些 Mod，注 R 的为推荐项目。\\n\\n经济\\n    TotalEconomy\\n    EconomyLite (R) 👉MCBBS\\n商店\\n    AmberShop 👉MCBBS\\n权限管理\\n    LuckPerms (R) 👉官网\\n    PermissionsEx\\n领地\\n    RedProtect (R) 👉MCBBS\\n    GriefPrevention\\n    没有 Residence！\\n登录\\n    FlexibleLogin (R) 👉GitHub\\n基础管理\\n    Nucleus (R) 👉MCBBS\\n    没有 Essentials！\\n皮肤\\n    CustomSkinLoader (R) 👉MCBBS\\n杂项\\n    JoinTitle - 登录标题 👉MCBBS\\n    SpongeLoginFix - 修复登录的 Bug 👉MCBBS\\n    GiftCode - 兑换码 👉MCBBS\\n    SendItems - 发送物品 👉MCBBS\\n\\n一些坑\\n\\nQ 进入服务器后无法破坏东西？\\n\\nA 可能是出生点保护。将 server.properties 中的 spawn-protection 项目更改为 0。这个项目没有任何实际作用，如果真的需要相关功能，可以使用插件，但是这个功能会导致即使拥有最高权限也无法做出任何更改。\\n\\nQ OP 无效？\\n\\nA Sponge 中没有 OP 这种概念，取而代之的是较为复杂但是又很方便的权限组管理模式。具体可以上网查找相关资料，需要依靠权限管理插件来实现。比较推荐 LuckPerms\\n\\nQ /help 无权限？\\n\\nA help 的权限在 sponge.commands.help，确保此权限给到。OP 应拥有 sponge.commands 权限。\\n\\nQ /gamerule、/gamemode 等无权限？\\n\\nA 这些都是原版指令，在 minecraft.commands 里。OP 应拥有 minecraft.commands 权限。\\n\\nQ 在一次性给予所有权限（* 权限）以后，发生很多奇怪的事情？\\n\\nA 重置权限组。不提倡一次性给予 * 权限，因为这有可能给到那些不一定需要的权限，例如 nucleus.vanish.onlogin 会导致每一次登录自动隐身，除了聊天以外没有任何办法发现此人（Tab 菜单也不可见）。\\n\\nQ Nucleus 如何设置玩家最大家的数量以及称号？\\n\\nA Nucleus 和 LuckPerms 搭配使用可以方便地设置这两者，用权限组进行区分。\\n/lp group default meta set home-count 5\\n将 default 组的最大 home 数量设置为 5 个。\\n/lp group default meta addprefix 1 [&a玩家&r]\\n给予 default 组聊天时一个 [玩家] 称号。其中 addprefix 后面需要跟上一个表示权重的数字。\\n","filename":"Minecraft-Sponge-Server-Tutorial","namespace":"post"},{"title":"我的 ADD","filecontent":"date: 2021/08/02\\ndesc: 解开了我一直以来疑惑不解的谜题。\\ncate: 思想\\n我的 ADD\\n\\n一个小时之前，我睡不着。也许跟每一个失眠的夜晚一样，睡不着很痛苦，脑海里充斥着不知道哪里来的声音，干扰着我的睡眠。许多时候我都是放弃了睡觉，通过咖啡来维持自己挺到早上。而既然这样的情况也并不常有，也就没有要过度在意的必要了。可是今天不一样，我打开了搜索引擎搜寻我一直以来的疑惑，终于还是解开了。\\n\\n经历\\n\\n我永远无法忘记我小时候的生活，却再也记不起其中的细节。小时候，我生活在一座普通小镇的一座四层楼的房子里，虽然内部装修并不豪华，只是一个普通楼阁，在当时的镇上也很常见，但它承载了我很多的回忆。邻居家的孩子都是女孩，我很愿意和她们一起玩，她们也愿意和我玩。或许在当时的父母眼中显得有那么点非主流吧，但是他们在之后的日子里没有过多评价，只是问道，小时候你的玩伴都到哪里去啦？只可惜，她们都没有像我一样读了像样的高中。\\n\\n后来我接触到了电脑，它摆放在楼梯下面的空间，父母经常会坐在那里使用电脑。我很惊奇，每次都在旁边看着。我看到电脑上弹出不同的窗口来，点击上面的一些按钮，又会弹出更多的窗口。我突然不知道从哪里就产生了一种所谓创造欲，想要把这一切画下来。家门口有一个台阶，台阶上铺的是黑色的瓷砖，经过长期的踩踏已经变得粗糙不平。我清楚地记得，我拿起白色的粉笔，一次又一次在狭窄的瓷砖上面画着自己印象中的窗口，如痴如醉，却根本不知道这是什么。我画出一个窗口，用手碰了碰上面的按钮，然后再用手擦掉，画上另外一个窗口。我到现在都没有想明白当时为什么会这么做，显得十分另类了。\\n\\n再然后，不再是小孩子了，上了初中，知道了这个东西是操作系统————然而学校是不教的，我只能通过搜索和询问他人知道。在当时，我自以为水平超出了所有的老师，事实也似乎在向我证明这一点。我开始疯狂地查询，怎么自己做操作系统？刚开始我认为这是一个特别有趣的议题，并没有看透它干枯的本质。我不断地搜索，不断地看到一些我一点也不感兴趣的文字，可是它们却在真真切切地叙述一个操作系统的产生。说实话，我甚至连操作系统的概念都不知道，只知道他是我日常在电脑上看到的东西。直到最后我发现这个东西并不容易，有很多无聊的概念需要我去理解，而且自己做出来的系统永远比不上自己平常所用的系统的外观。\\n\\n于是我开始装系统。我随便找下载站下载我不知道是什么形式的系统，然后点击安装程序去安装。当时的系统是 XP，我看到了 Windows 7 的页面，仿佛是开启了新世界的大门，着了魔的想要把它装到那悲惨的电脑上。终于，系统装上了，我惊奇地分享给我的父母。我的父母似乎感到很震惊，却又不知道该怎样去形容和评价。但是后来我发现自己被骗了，电脑越来越卡，直到爸爸把电脑抱到了一位开电脑店的邻居家里面，邻居说这个系统里有好多“插件”，都是“病毒”。我一瞬间感觉到自己的劳动成果受到了冒犯，但是又不敢说。再到后来我终于明白这些都意味着什么，现在已经是系统重装中级高手。\\n\\n可是上了初中以后我发现数学变难了。实际上小学的时候，某一次期末考试我的数学考了 80 多分，已经是预料之外了，为此我和父母去领成绩单的时候，班主任还多说了几句，那一次让我的印象很深刻。可是初中数学，特别是初中的几何，让我感到特别的难受，很多时候考试会呼吸困难，焦虑。做选择题的时候会犹豫很久，以至于面没有时间做————这也许在现在的学生中也挺普遍的，但是我后来发现我犹豫的动机和普通人犹豫的动机并不一样。我犹豫的动机只是因为脑子想不过来，具体在后文有提及。于是，我的数学有的时候考 90 分，有的时考 100 分左右。考得最好一次，却是在初三的时候，数学是年级第一名，110 分。我的数学老师一向是不太信任我的成绩稳定性的，那一次他夸奖了我。然而上他的课的时候，他故意点我回答问题，我回答不上来，他于是就说这只是因为我运气好。当时我问了其他我认为很大佬的人物，他们考的都没有我高。我清楚地记得，我写最后一题的时候，只剩下十多分钟，我的手在颤抖，到最后写下了一个很奇怪的分数，直到现在我也不敢相信那是我。可是从那以后，再也没有考过这么好。\\n\\n从这个时候开始，我就发现了不对劲。但是周末回家，我依然会把大部分的时间都花在我喜欢的东西上面————代码。然而这个代码不是真正的代码，而是我自己创造的伪概念。因为当时我没有任何学习途径，很多概念我一点也不了解，沉迷于自己建立的体系之中。直到我写出第一个 Batch 脚本的时候，我才发现创造程序就好比是创造了一个属于自己的新生命一般令人愉悦。\\n\\n可是我发现我开始对这个东西有一些过度的痴迷了。我的父母怀疑过我有网瘾，我也怀疑过我自己。我发现我和同龄人一点也不一样，我不喜欢玩游戏，一直都不喜欢，除了某些特定的对我口味的游戏，而这些游戏很少很少，并且在当时是根本不存在的。而同龄人却可以围绕一系列的话题聊很久，无论是男生还是女生。那个时候还不流行王者荣耀，但是他们依然能够聊到一起，让我一次又一次感到被孤立。我发现自己与他人的确是有些不同了。\\n\\n再到后来不断长大，我发现自己面临了一些他人似乎都没有的情况。比如，在一件大任务下焦虑，特别焦虑。而且很急于求成，导致很多事情根本就办不好。健忘，前一秒想到的事情或者灵感，下一秒直接消失得无影无踪。间歇性失眠（高中很疲劳除外），脑子里充斥着声音，这些声音都是我日常所接触的，比如说听过的歌，它们不会自己消失。甚至我感觉自己的大脑对自己有敌意，很多时候我的大脑会不自主地要求我：不要这样做，否则会 XX。这种想法莫名其妙就自己产生了，只是的确有一段时间没有出现了。有的时候情绪会很低落，因为一件事情办不好；有的时候情绪会很高涨，因为一件事情办好了，然而这两者都是没有必要的。特别在意他人对自己的看法，很希望博得他人对自己的关注，却又不想要显得那么哗众取宠或者矫情，于是一次又一次地隐藏，很少显露出来。\\n\\n我不止一次想要找到一个沟通对象，发现自己的现实中其实根本不存在这样的人。因为我具有完全不同于同龄人的心境，我讲的话也许他们根本就听不懂。这一切就这样迷迷糊糊地潜入进了我的生活，而我一直以来只能选择习以为常。\\n\\nADD 解释了这一切\\n\\n就在今天，我找到了这一切的原因————ADD。ADD 全称 Attention Deficit Disorder 注意力缺失症，是一种精神疾病，而且威力不小。单看疾病的名称似乎就和我的比较吻合。刚开始我是在这篇豆瓣文章中找到的这个概念。原本我以为这个疾病应该只是和我略有皮毛上的牵连，可是我随着阅读的深入发现自己简直完全吻合。\\n另一种情况是，比如你是一个有高度创造欲的人，总是渴望作画、写小说，但每次却又不肯付诸实施，因你总觉得自己缺乏自律精神，或是缺少强烈的动力，借口多多。更有甚者，你甚至怀疑自己有轻微的抑郁症。其实，真正的原因可能是ADD。ADD患者一般有很强的创造欲，但正是受ADD的影响，他们的创造欲不得发挥，于是导致他们更加抑郁。如果不及早明白这个道理，ADD可能真就导致了抑郁症。\\n\\n我的确是一个有高度创造欲的人，甚至小时候第一次对计算机产生莫名其妙的兴趣也是因为这一点。然而我只会对感兴趣的事情具有高度创造欲，并且喜欢去实施，但是大多数的实施均以失败告终。我的确怀疑自己有轻微的抑郁症，一直得不到解释，上面的引文中很好地解释了我对我的“轻微抑郁症”的认知。可是我一直都告诉自己无论如何千万不要抑郁，否则自己负担不起，父母也负担不起，活着就失去了意义，也许这也是我一直坚持下来的原因之一吧。\\n\\n在这篇文章中有一个判断自己是否患有 ADD 的环节，我发现自己几乎命中所有。\\n\\n在工作或生活中不能注意细节或经常犯粗心的错误；\\n    很多时候犯下的错误连自己都不敢相信，显得智商特别低，而且一看又可以改正回来。\\n在工作或娱乐中很难保持注意力；\\n    娱乐中可以保持注意力，也许是长久以来的惯性所致。但是工作和学习的确很难保持注意力，需要通过自我刺激才能实现。\\n别人与你讲话时，你没留意听，经常走神；\\n    这一点不是很符合，因为一直以来我发现自己受到孤立的事实，我一直告诉自己不要用他人无意中令我感到难受的方式来对待他人，于是我很想去倾听别人，哪怕是装的。\\n不遵从指令且完不成工作；\\n    以前很不喜欢遵从程序化的一切东西，比如课程表，作息时间表，觉得这些东西都没有意义，不知道算不算。\\n难以组织好工作和活动；\\n    有的时候组织的很好，有的时候组织的很不好。组织的很好的情况是因为被组织人本身就有经验。\\n逃避、不喜欢或不情愿参加需要持久保持注意力的工作或活动；\\n    我逃避所有与注意力有关的游戏，尤其是恐怖游戏、逃亡游戏，玩着会感到特别的焦虑和痛苦，倒不是因为恐怖不去玩，而是因为压抑，所以不喜欢玩游戏。\\n丢失工作或活动中的必需品；\\n    很容易丢东西是真的。手机经常忘记放在哪里，需要用 iPad 上的查找去找。\\n很容易分散注意力（多因外界刺激）；\\n    查阅资料的时候很容易点进莫名其妙的链接，即使知道这样做是不对的。\\n在日常活动中健忘。\\n    健忘是肯定的，思绪和灵感经常消失。\\n\\n同时也有几点特质很符合\\n\\n不善于处理金钱或做财务计划。\\n    从前帮老师收钱的时候也很焦虑，好在没有因此出现什么大事，但是每次收的时候都很难受，生怕少了一分一毫。\\n即使很努力，表现却时好时坏。\\n无法欣赏自己的优点或了解自己的缺点。\\n    有的时候表现得自大，有的时候表现得自卑。我觉得这样对外界很不好，一直想要隐藏。\\n解读社交讯息有困难，因此不容易交朋友。\\n    很容易对信息产生误解。如果遇到不那么耐心的人，很有可能发生争执。我依然有朋友，他们在这方面是比较谅解我的，我也逐渐形成了默契。\\n容易忘记自己及别人的缺点。容易原谅别人。\\n    除非极其讨厌对我造成非常大伤害的人不会原谅，其余的都有可能主动找上门求原谅或者主动原谅别人。\\n一般人偶尔也会有上述的症状，但是ADD的诊断不是依据你是否曾经有这些症状，而是依据症状的强度和延续时间的长短决定的。\\n\\n以上列出的症状都是一直存在，从来没有消失的。所以我才认定自己是一个 ADD。\\n\\n看完这篇文章以后，我又去查阅维基百科的资料，除了与文章中重合的部分以外，我发现了跟脑部有关的信息。\\n\\n我并不是很确定这个东西跟脑部有必然的联系，但是我又怀疑这至少在我的身上是的确体现出来了，它已经不再是精神层面的东西了。因为我回忆起我从前写试卷的时候，每一次很简单的计算都要列竖式，从来都没有尝试过口算。尤其是科学计数法，带 0 的规律一直以为自己能理清楚，但是一直都理不清楚，每次都是一个个地数，很像小学生。而且每个竖式哪怕再简单也要列好几遍心里才能放心，后来发现这样实在浪费时间于是放弃，然而后来每次计算完毕以后心里都有焦虑的感觉，一直反复地读题目又不知道目的是什么，要采取怎样的行动。解一元二次方程的时候，只用过公式法，从来没试过十字相乘因式分解，而几乎所有的同学都会先用这种方法，但我还是一路挺过来了。上课思维完全无法跟上老师走，只能靠大量的笔记和题目来感悟。很多老师上课写的例题，因为害怕时间太短索性放弃思考。同学要我讲题的时候，我也往往无法当面作出反应，总需要自己研究个几分钟以后才能一口气全部讲出来，而其他的同学可以边思考边讲题。我不知道这一系列行为跟 ADD 有没有关系，但是我长久以来一直觉得自己大脑不清醒，再怎么睡都不清醒，也许原因就在这里。\\n\\n我也很在意他人对我的看法，无论这个人在我的心中是怎样的地位。很多人可以选择在争论面前不发言，可是我却总是止不住要发言，去表达自己的观点。而且经常说出很直接的话语，让大家觉得我是一个很直接的人。我觉得这些都跟 ADD 有一定必然的联系，我也不希望再这样继续下去了。\\n\\n根据维基百科上的信息判断，我发现自己是混合型注意力缺陷多动障碍患者。这只是一个初步的自我诊断，也没有看医生，到时候还是去看一个比较保险。不过也许是因为年龄和心理素质因素，多动并没有体现在行动上，而体现在观点和交流上。","filename":"My-ADD","namespace":"post"},{"title":"精神内耗文集","filecontent":"date: 2023/02/13\\ncate: 记录\\ndesc: 精神内耗实在是太累了，以至于回过头来看也不清楚自己究竟说了些什么、想了些什么。但是我始终认为这是对的，也正是我想表达的。只是没那么有必要，入不敷出而已。\\n精神内耗文集\\n\\n在这里收录了几篇精神内耗期间写过的小段文字。现在回过头来看，已经不清楚具体的行文思路和主题是什么了，但如果能回归当时的那种状态，文章还是可以成功堆叠出千字的。\\n\\n这些文段的特点也正是没有明确的主题和对象。因而现在对我而言它们更像是蹦出来的另一个人格所写。\\n\\n我认为文章还是需要实际一点，所以尽量还是不再发这一类不甚明确观点但也确实表达了一些东西的文章出来了。\\n\\n在这里我把这些文段整理成一个个小节作为记录，同时也作为我研究自己精神内耗的资料。\\n\\nip\\n下面列出的文段可能戛然而止而显得很突兀。\\n文段会持续更新。\\n:::\\n\\n《旧世纪领袖》\\n\\n（2022 年 11 月）\\n\\n秩序带来了最大的无序，而更大的秩序需要依靠无序而生存。\\n\\n没有秩序的无序是混沌，有秩序的无序是虚无，而没有秩序的秩序无处不在。\\n\\n每个人都在寻找自己的利益，区别在于寻找的方式。\\n\\n商人十分赤裸。为了违背实用主义而构造出的花样，在资本的洗涤下或许成为了潮流——但在不久之后又化为了泡影，被迷途知返的傻子们以指点他人的方式自我反思。本不应该发生的一切浪费了没人愿意浪费的资源，最终将这份债务加在了所有无论是否参加了这场狂欢的人的思想上。\\n\\n商人可以改变世界，但永远是暂时的。当需求不存在时，就创造需求。如果说商人是骗局的主谋，那么有些技术可以算作是忠实拥趸。社会需要创新，而技术却不总是创新。无用的技术也许单凭新奇就吸引了无数人的目光，其铸就的光环是庞大的。以至于哪怕技术尚不存在，便有无数的外行资本家，将夺来的钱财挥霍入虚空。任由仇富的人谴责，穷苦的人感慨，高阶的人啼笑皆非——最终这些钱又去了哪里？没有人知道，但总之不在你这里。\\n\\n商人却是坦诚的。他们没有自己的保护伞，不需要多少来自外界的庇护。闭上眼睛享受阳光，钱便持续入账。他们是经济中的湍流，财海中的浪潮，宏大而有力。\\n\\n高阶人十分虚伪。讽刺的是，由一部分高阶人的成见搭建起的一套制度中，因循守旧成了值得称颂的一部分。高阶人十分擅长划定界限和标准，代替所有人制定一切。体系的运转需要的规则，应有尽有；而体系丝毫不需要的累赘，亦是铺天盖地。也正因此，没有人愿意高阶人从此消失，因为随之而来的便是体系前所未有的的危险格局。\\n\\n高阶人可以选择放弃一部分自己的利益，亦可以在众目睽睽之下不要脸。高阶人之所以高阶，正是因为他们具有与平常人独特的地方，至于究竟在哪里，竟然也不可言说。与商人极为相似的一点是，凭借能力的强大，他们可以选择完全不受外界的影响；即使有，也是从中精挑细选的属于自己利益的一部分。高阶人的存在本应是合理的，只可惜贪欲无止境，体系的每个角落似乎都充斥了他们的声音，让体系中的人有在劫难逃的错觉。\\n\\n高阶人中有智慧的，有才干的，也有农村的。智慧的高阶人负责闭嘴，才干的高阶人负责顺从，而农村的高阶人才是主角。这一点也不诡异，而是十分显然的自然规律。\\n\\n有人说，农村的高阶人带来体系的毁灭，因为他们只能带来倒退。但体系里又有多少人不是农村人呢？少数服从多数的道理，十分显然。那些自诩高明的小丑，在高阶人面前也不得不夹起尾巴来。有些小丑自愿退出，没人稀罕他们；有些小丑哭天喊地，这是精神病；有些小丑耀武扬威，最后被完全打趴下。农村的高阶人在打压小丑方面显得格外卖力，也许他们中的智慧分子察觉到了前所未有的危险。这正是他们的明智所在。\\n\\n事实证明，农村的高阶人的确可以为体系带来前所未有的和平。\\n\\n傻子十分可悲。在成见和裹挟之中长大，傻子不懂得该如何选择自己的道路，只好按自己的性别——因为这是他唯一天生具有的认可——研究道德、行为准则，连镜子也不照便出发了。\\n\\n傻子不懂什么叫做喜欢，什么叫做不喜欢。也许他们的喜欢中夹杂着些许不喜欢，而不喜欢中又夹杂着朦胧的喜欢。喜欢与不喜欢没有明确的界限，使得他们对有些事物的表现和操守十分令人诧异，哪怕是自己的食物。\\n\\n社会不是由傻子构成的，因此天然具有对傻子的迫害，但傻子却难以领略这样的痛苦；反倒是正常人察觉到一丝丝痛苦便能呻吟，尽管并不能被听到。\\n\\n傻子不懂什么叫做苦，什么叫做甜。也许他们时常念叨先苦后甜，在上传下达的时候心里仍在默默念着「此乃真理也」，却从来没有尝过真正的苦头，从来不敢去体验真正的甜头。傻子没有尝过苦头，却早已莫名其妙地明晰苦头的滋味，这成为傻子们茶余饭后的谈资，滔滔不绝——甚至让新生的小傻子也有些厌倦了；傻子没有尝过甜头，却觉得甜头都是苦的，真正的快乐是不存在的，于是对那些声称自己当前很甜的人表示不屑。\\n\\n既对抑郁深恶痛绝，又永远不会快乐的人，坠入低谷、风吹雨打的时候也会笑。他们被铁刀刺入的那一刻，流下的血液中不混杂一丝泪水。他们痛苦的愤怒播撒在所有向往美好的人身上，痛恨他们没有和自己一样——热爱痛苦，心系痛苦，投身痛苦，成为痛苦。\\n\\n傻子的记忆力非常好。他们总是能够铭记自己出生不久发生的各种事情和言语，并将其作为人生的基础。也许，改变是一种背叛，这在农村的傻子心中异常明显。这些早年的教育将会成为他们行事的唯一准则，不曾改变。杞人忧天的傻子会以周围的一切违背这一准则而悲叹；自以为是的傻子会以这一准则贬斥所有人，尽管并没有什么用。傻子向来将这些出生以后的「馈赠」当作至高无上的财富与经验，哪怕后天再高等的知识也无可替代。 讽刺的是，城里的傻子只顾自己的同时谴责他人的自私而农村的傻子则是毫不收敛地规训陌生人了。\\n\\n傻子从来没有放弃一个将自己的规则拓展到所有人的机会，以至于一旦拥有，那么所有人都有可能笼罩在傻子的主观意愿之下。\\n\\n只可惜大部分的傻子向来只能在吹牛嘴炮中抒发感慨，最后仍然被双脚踏入上层的高阶傻子重重地踩在脚下。\\n\\n道理到这里，已经十分清楚了。\\n\\n《宏大之谜》\\n\\n（2023 年 2 月）\\n\\n政治的存在，使得群体意识的合理性得到最大化的伸展。无论是对现实的构造，还是精神层面的平衡，政治似乎构成了人类社会最不可或缺的基础。我们很难想象没有合作的原始社会，更无法将当下价值观与完全意义上的共产主义类比。\\n\\n恩格斯在 《家庭、私有制和国家的起源》（Der Ursprung der Familie, des Privateigenthums und des Staats）中描述：\\n国家决不是从外部强加于社会的一种力量。国家也不像黑格尔所断言的是“伦理观念的现实”，“理性的形象和现实”。毋宁说，国家是社会在一定发展阶段上的产物；国家是表示：这个社会陷入了不可解决的自我矛盾，分裂为不可调和的对立面而又无力摆脱这些对立面。而为了使这些对立面、这些经济利益互相冲突的阶级，不致在无谓的斗争中把自己和社会消灭，就需要有一种表面上站在社会之上的力量来抑制冲突，把冲突保持在“秩序”的范围以内；这种从社会中产生但又居于社会之上并且日益同社会相异化的力量，就是国家。 （德文第 6 版，p. 177-178）\\n\\n因而事实上，从人类第一次产生剩余价值，再到奴隶制，再到阶级划分——在持有不同观点和利益的人面前，国家显得越发重要，以至于成为了一种人类生存的必然。没有了国家的负责，我们很难想象法治的实现和安全的保障方式，也无法想象人类将如何继续以全新的方式相处。一个国家的毁灭必定伴随着极端的利益冲突和军事行动，而这些的诱因却又几乎必然是成为另一个国家。\\n\\n政治是国家统治的工具和过程，不同的政治思想说明了不同国家在政治方面有着或多或少的天壤之别。在如此层面上论述，我们发现：无论如何也无法将思想统一或消灭，因而国家之间永远存在一定程度上的对立。这在某种程度上代表了不同社会环境之间的巨大差别，彼此在文化、经济层面必然具有截然不同的态度和举措。人类的思想从远古时期便形成了地理隔离，然后便是不可磨灭的生殖隔离。\\n\\n然后，我们发现国家无时无刻不在给我们惊喜。\\n\\n《断裂的鸿沟》\\n\\n（2023 年 2 月）\\n\\n当世界上的容身之地越来越少，个体的价值也越来越低微之时，人们所在意的便是如何获取和获取什么。已经成为既定事实的社达主义规定了一切的规则，而万兽所争执的顶端力量便是那权利和利益。\\n\\n消费与享乐，节俭与吃苦，不一样的作态造就有着天壤之别的态度。资源看上去是无穷无尽时，便有人踩着脚下的饭菜去得到自己想要的虚无；资源储备又显得火烧眉毛时，便有人不惜纵火焚烧而去维护他也无能为力的局面；资源又显得沾满了淋漓的鲜血时，便有人畏惧资源的同时叫嚷着让所有人都成为缩头乌龟；而资源最终却又彰显了强权与暴力时，便有人去围追堵截争强好胜，一无所有或是金城千里。\\n\\n在如此感性的人类面前，理性的力量很荒谬地显得微不足道。\\n\\n生物的本能是生存和繁衍。在这样的社会的驱使之下，出生在一些特殊种群以外的一无所有的所有的人们都踏上了近乎完全相同的道路，他们在探索的途中逐渐会明白自己想要什么。这一切是必然，并没有什么错。\\n\\n于是经验和教训，无限地积累；前行的道路，无限地延伸。年老的人们踏过曾经存在的冰湖和雨雪，踏过烟花爆竹响彻的夜，踏过风雨交加的黎明和黄昏，踏过千疮百孔的黄土高原。一切都在证实着他们有着指责和不承认颓废的权利。\\n\\n动物的长者确保了幼小个体的生存，搜集食物，教其本领。而人类因为有了利益的牵扯，一切却变得复杂起来：雌性的个体自古以来被区别对待，以至于至今所有人对其的态度还是个不可调和的迷；长者对个体的指导并不限于生存，或者重点根本不在生存，而是如何去投机取巧，如何去压榨他人；长者还有长者，还有长者的长者，纵使并非血缘关系，但管辖力度显然远超至亲。\\n\\n然后，当个体意外死亡而长者仍然具有生育力是，他便成为一个令人失败落泪的过去，父母含泪诞下下一个传宗接代的种子。\\n\\n时代不曾将任何人拒之门外，但长者主动将自己认定为了局外人，无病呻吟起来。\\n\\n《谁比谁高贵》\\n\\n（2022 年 9 月，原题《人性是如何被泯灭的》）\\n\\n不知道从何时起，我的生活中走入了这样一类人：似乎命运的逻辑已经被他全然掌握在手中，以俯视众生的姿态出现在现实世界，无时无刻不生活在自己制定的一份似严密似松散的抽象规则中。\\n\\n这么说来，似乎还不大明确。但值得庆幸的是，调查的样本出奇地典型，所以我们可以用大量的篇幅来详细地描述他们，并阐述我的一些想法。\\n\\n制约\\n\\n从最简单的例子说起。\\n\\n一件事情究竟应该以什么样的方式被完成呢？在我看来，只要满足了绝对的硬性要求和个人的追求，就可以算作是完美。在这里的绝对硬性要求并不等价于最低要求，而是可以实现讨好相关人员、维系自我地位并且从中获得愉悦感，同时满足最低要求的一种可变的主观标准。\\n\\n这一定义已经十分清楚，但令我不能理解的是，某些人的心中总是或多或少扎根了另一类非理性的固有标准，即抛开上面的定义，这件事情应该以这一固有标准完成，而非当事人所定义的标准。\\n\\n然而客观来看，这种固有标准的形成纯属偶然，并且与上述主观标准仅有部分相交，而且可以确定不会相交的部分就是令当事人愉悦。既然自己不是任务的执行者，也不是相关人物，却依然要借不知从何处得来的办事伦理来评判与自己利益高度无关的事物，这听起来像什么？\\n\\n上面的例子似乎显得有些过于系统化。那么接下来就来说说某些人贴近生活的一个特点，那就是他们存在极为严重的自我制约。\\n\\n自我制约是指在我的观察中，因为某些未知原因的个人信仰因素，对自己的行为进行有别于其他所有人（根本没有意识到这样做的必要性）的限制，让自己的行为维持在某种由自己非完全主观（是指思想来源并非自己）思想所定义的范围之内。\\n\\n也许是因为受到了某种成功学的蛊惑，认为做事情应该按照一种「直播逻辑」，要「落实生活的每一个小细节」才能让别人有朝一日或者私下讨论时发现自己如此巨大的闪光点，而非直接了当地去展示自己，这么做的效果似乎就好比为了成就这么一个段子：扎克伯格从 X 年开始每个星期做 Y，这就是 Z 的原因。然而现实中真的会有人这么无聊吗？\\n\\n也许是因为受到了某种血脉规矩的制约，认为做事情应该围绕一种「对祖上的尊重」，要有「民族气势」，「发扬个性」的同时「不失本分」、「不忘根本」、「不坏礼乐」，成为「真正的人」，这么做的效果暂时不得而知，但似乎能让其本人因为无声地尊重了虚无获得莫大的成就感。可能有相关同好会指责说，这怎么能算是尊重了虚无呢？我的回答是，这似乎正是让这一切显得不那么正常的根本原因。既然如此的狂热，却没有实际措施，也没有语言上的表态，而仅仅是用这样的作态来营造一种似乎像是骨子里（虽然根本不存在一种基因序列让你生而如此）本有实则是后天自己塑造出来的形象，这么幽默的行为还能发生在现在的年轻人里，只能说让人笑掉大牙。这种疯狂塑造的行为屡见不鲜，对于那些塑造的比较好、比较自然的人勉强可以投以赞叹的目光来表示「对汗水的尊重」，而那些塑造的比较差的人，似乎也只能当成是满口空话的跳梁小丑如无家可归一般操持着固定的句式，在网络上四处像孤魂野鬼地游荡，寻找活人，在现实中老气横秋，指点江山了。\\n\\n如此可悲又如此享受，正道在这些人的眼中就是这样一种荒诞不经却又因所谓传承而亘古不变的存在。\\n\\n马基雅维利\\n\\n没有人能够理解究竟有多少进入职场的马基雅维利主义者是以这样狼狈不堪的方式度过青春的。我的这些朋友确实是其中之一了。\\n\\n没有人会把自己定义为冷酷（如果有，请搜索自恋型人格障碍），也没有人会随意把人定义为冷酷无情的。但有没有一种可能，即使冷酷这个词语无人问津，却以许多其它形式存在着。\\n\\n不知道有没有人这么想过：我只认可客观世界的理性，至于你的想法究竟是什么、如何评价，我也只相信科学的解释。\\n\\n一些心怀梦想，生来就想当理科生的男性人类似乎在年轻的时候都发觉自己或多或少有些理性的「天赋」乃至待到「合适时机」定能发挥作用的「潜质」。但类似于我的这些朋友的部分人在给自己打上这样一种标签以后，便开始无限的向它靠近，永远不相交。为什么？因为他们在虚伪地标榜自己理智的同时完全放弃了去做一个真正会交谈，理解他人思想，甚至是最基本的逻辑论证的正常人。\\n\\n一个很经典的例子就是，沉默是金。沉默到底是金，还是根本无话可说的低交流能力的凸显？想必没有人会心甘情愿承认后者。他们正是这样，在沉默中不断消灭着自己的共情能力，对事物真正的理解能力和评判能力，最终变成对待万物只按照固有标准形式的自我感动型人物。一旦事物违背了其固有的思想，那么一份份公式化的论证就会不自觉地从脑海中输出予以反击，无论是否表述出来。我认为，即使是对待科学上的事物，这样的方式是正确的，但精神和作风却依然扭曲。\\n\\n他们正是由于这种无意间，类似于性别刻板印象的自我标榜，逐渐难以正常表达自己的观点，只能通过不断地阅读网上四处乱飞的「文献」来丰富阅历并被塑造价值观。夸张点说，甚至连一些复杂的中文句式都难以表达。\\n\\n这是一种什么样的情景呢？就好比你看到了山水水彩画觉得很美，无意间将它与诗词联系了起来，由此萌生了对诗词的兴趣，这固然是好的，没有什么理由。但自从你爱上了叫自己诗词爱好者，同时又根本没有兴趣从多个方面去认真解读这份爱好，仅仅是读一下、看一下，甚至根本没有读懂，单凭自我感动，就认为自己的生活被诗词充实起来了，连生活都变得有诗意了起来。时间久了，你就认为自己的确是诗词爱好者，诗词确实与你寸步不离，你确实与诗词紧密相连。但实际上你什么也不懂，你只是醉酒后在五彩纸屑里起舞。\\n\\n若是在这样一种寻求虚假理性（实则是外在形象）的路上走得过远，最终人就会变得冷酷，货真价实的冷酷。把一切与自己无关的娱乐看作是对资源的浪费和对理性的亵渎，把一切不合规范的判断看作是无效的输出和对规则的「不尊重」，把一切隐晦的浪漫视为搔首弄姿和矫揉造作，把一切不符合内心固有标准的存在视为不合理的存在并予以永久的鄙视。最可笑的是这一性格的形成原因竟然与理性毫无任何联系，仅仅是把在病态社会环境的熏陶下自己对个人利益的偏执诠释变成在追求假理性的路上外界的赠予（即获得的知识）。\\n\\n虽然很多人将此姑且认作是普遍存在的一种性格特征，尤其存在于男性中，但最终钢铁直男们，尤其是那些攀升到领导职位的古铜色啤酒肚，会变成不折不扣的马基雅维利主义者。可悲的是他们的决策竟然会影响大部分和他们不一样的人。\\n\\n这显然并不是常人应该有的样子。\\n\\n管辖\\n\\n划分无论是行动还是思想上的管辖权向来不是他们所擅长的事情。\\n\\n人们往往为了自己的利益越界做事，但在遵循社会公序良俗的前提下并不会把对他人的利用摆在明面上，越界做事在很多时候被认为是迫不得以，类似于正当防卫的行为。然而在缺乏界限观的类似于我的这位朋友的人中，他们由于种种原因给自己划定（同时也为别人划定）的固有标准促使他们以五花八门的方式没日没夜的对他人的行为进行审视和评价。\\n\\n正如上文中提到的一个问题，一件事情究竟应该以什么样的方式被完成？吃饭的时候应该喝水吗？按照正常的思维来看，答案都是不定的，且与当事人高度相关，他人怎么想实际上是无关紧要的。所以一般人不会对这类事情进行过多评述。而我操持的观点是别人怎么喜欢怎么来。\\n\\n但是，缺乏界限感的人往往无法懂得上面的这一道理，总是乐于按照自己的标准给出绝对的答案：吃饭就是不应该喝水。如果要问为什么要这么说，就如同在问为什么这样的人会存在，神会知道的。当然人的父母除外。\\n\\n一个典型的例子是部分男性对女性行为的评论。例如，认为女性在某些方面不应表现过于张扬，或者女性的行为应该遵循某种固有逻辑，等等，从这些点出发对女性发表或委婉或讽刺的评论，即使已经知道会引来对方强烈的反感。\\n\\n《论调》\\n\\n（2023 年 1 月，实验小说）\\n悲观的论调没有根据，而潜藏在他背后的无数的人们又无不佩戴着面具。强悍的人究竟是真的强悍，还是缺乏理解这一切的能力？\\n\\n1\\n\\n越秀在沙发上醒来。\\n\\n昨晚的欢愉和不省人事以后，这样他再熟悉不过的早晨如期而至。窗外是大太阳，毫无生气的街道映入他的眼帘。\\n\\n「出太阳了。再睡会。」\\n\\n这是一栋十分陈旧的建筑。\\n\\n虽然说「陈旧」，但更适合用「年代感」来形容。这样的建筑并不多见，或者说只能在这样的街道上看见。他给许多人，包括越秀，挽回了来自过去的回忆。或许这也是他们如此喜欢在这周围转悠，而不去造访充满着透明的高级玻璃、毫不夸张的霓虹彩灯的干净城中心。\\n\\n在这样的建筑里居住的，都是蜷缩着喘息的下层人。一些有洁癖的上层人将这里视作是肮脏不堪的蝇巢，可是这里的一切又如文学作品里描写的那样，充满着令人羡慕和怀念的生活气息，所以也有越来越多的人开始以自己的方式理解它。\\n\\n越秀长得既不清秀，也不端正。他的眼睛不大，但也不至于眯成一条缝，这让他的平常神态略显猥琐，虽然他并不愿意被别人这样看。他脸上的胡茬并没有修剪干净，使得脸部下围宛若是刚被快要报废的收割机收割过的麦田，一些细微的胡须清晰可见，而大多数都是小小的根部。\\n\\n这一残局在某种程度上，让他又略显年轻了——好像这些胡子刚刚在他脸上安家似的。\\n\\n越秀看着镜子里的自己，眨了眨眼。他一向对自己十分自信，也不外乎自己的外貌。\\n\\n简单地洗漱后，他出了门。\\n\\n楼梯是用朴实的水泥铺成的，这颇像上世纪 90 年代的居民楼里的景象。墙上贴满了报纸，有些已经发黄，但是上面刊登的都是几个月内的事情。\\n\\n越秀走出了大门，坐上了他开的出租车。\\n\\n2\\n\\n冯裕昨晚喝多了酒，恍惚之感从家里一直陪着他，到了早餐店。\\n\\n他安静地坐在略带有塑料感的木质桌子旁，透过庞大的落地窗看向外面。街上的人们按照他们自己的轨迹走着，时不时有车把他们遮挡。\\n\\n这在冯裕的眼里宛若一幅动态的静态画。画上的人无时无刻不在做自己的事情，毫无闲心将目光转向他。\\n\\n冯裕很讨厌这样头脑晕乎乎的感觉，因为他向来是习惯清醒的。\\n\\n在他很小的时候，他便发现自己能够只睡小几个小时就达到别人所说的「理想工作状态」。\\n\\n更让他惊异的是，在多年前，疫情刚刚放开之时，他是他的家庭中唯一一个在半年内没有感染的人。\\n\\n这更让他相信自己的体质异于常人。他想要珍惜这种体质，所以想来对不健康的饮食敬而远之。\\n\\n这样固然是好的。\\n\\n正当他在回忆自己这番传奇的过去时，服务员将他点的菜品端了上来。\\n\\n他的桌面上的内容十分简洁，在人满为患，平均每张桌子上都有三到四碗面、一两碗包子的店子里显得格格不入。\\n\\n服务员对他微微地点了点头，冯裕笑着回应。\\n\\n实际上，冯裕自从在这周边住下开始，就把这里当作早餐的唯一据点，而每天的早餐都是如此的平淡且统一，似乎从来没有变过。\\n\\n这给餐厅里所有的服务员都留下了十分深刻的印象。\\n\\n「冯先生，打扰一下可以吗？」\\n\\n服务员微笑着对冯裕轻声说道。\\n\\n「可以。」\\n\\n冯裕的眼光放在了服务员的眼里，笑容不知在什么时候消失了，显得有些令人诧异的严肃。\\n\\n「是这样的，我们的经理很想感谢您一直这么爱戴本店。但是今天的油条，很不幸，已经卖光了。您一直吃一样的套餐，要不今天换换口味？」\\n\\n服务员的笑容并没有消失，眼光转了转，放在了冯裕桌上的一杯豆浆和一碗清汤粉上。\\n\\n「不用了。辛苦你们了。」\\n\\n冯裕微笑着说，顺带着点了点头。\\n\\n「那您作为我们的老客，为了补偿今天的失误，最近两天的早餐您随便吃，我们不收钱。」\\n\\n「不用，不用。」\\n\\n冯裕的笑容又消失了。经过一番推辞以后，冯裕没有接受这份款待。吃过早饭后，付了钱就离开了。\\n\\n阳光洒在路面上，也洒在他的身上。可是这阳光不像往日那样甜美，而是显得刺眼。他的眼睛又酸又麻，不知该如何解决。只回想起过去一些朋友熬夜，说一般起床后流些眼泪，眼睛就会好转。\\n\\n阳光这么刺眼，他到哪里去找眼泪呢？\\n\\n他将眼睛一闭，果然，一股酥麻感袭来。\\n\\n他便这样一边闭眼一边向前走。\\n\\n3\\n\\n早上五点半，北峰就已经起床，这时的天完全是黑色。\\n\\n北峰望向窗外，是掉完树叶的枝头在摇曳。月光是向来没有的。有时他甚至会想，这应该是地球上唯一一个看不到月亮的地方。\\n\\n北峰的家门前是一大片荒地，延伸到远端罕见的青绿。那青绿所环绕的是一座土坡，上面立着烈士的纪念碑。在纪念碑的周围，一层层顺着土坡向下排布着的，是村子里所有逝者的坟冢。\\n\\n没有多少人铭记这里发生过的事情，因为这里从来不是任何外人会在日常闲谈或文辞中所能随便想到的地方。这里就是这样平凡。\\n\\n土坡上，随着那些逝去的人一起的，是一些毫无根据的悲伤，它们悄无声息地在一夜夜里被埋葬。\\n\\n北峰的外婆的性命被数年前肆虐全球的病毒所夺。\\n\\n当他听闻这一噩耗的时候，几乎惊掉了下巴。因为他完全不能相信，那一个被身边人，尤其是自己当时的老师大声呼吁要「看淡」的疾病，竟然如此轻易就索取了至亲的生命。\\n\\n没人能够理解北峰的情感，正如那些早已被埋葬在土坡上的哀伤。但北峰的情感终将散尽，而哀伤却会以不可知的形式永远存在下去。\\n\\n4\\n\\n冯裕到了公司。\\n\\n在这高大建筑的遮蔽之下，未经阳光烘烤过的冰凉而又干燥的空气在公司大门前不停地吹。\\n\\n冯裕感到了一种自己极为熟悉的寒冷之感，这与小时候他随父母去银行，结婚时陪妻子去领证时并无差异。\\n\\n电梯门打开，冯裕走到了他的工位上。\\n\\n不出意外地，冯裕的工位也显得异常整齐，犹如一些样板间里工整的书桌。电脑旁摆着一盆小小的绿萝，这是无尽的白色之间的一点青绿。\\n\\n没有日历，没有马克杯，也没有各式各样的小玩意。\\n\\n「冯哥，早晨啊！」\\n\\n那是一个和他年纪相仿的男人，工位与他相隔不远。他们并不认识，因而冯裕不清楚为何他每天都如此热情，甚至有时还为此感到诧异。\\n\\n「早上好。」\\n\\n他平淡地回复，然后便坐在了自己的椅子上。\\n\\n","filename":"Semi-completed-Articles","namespace":"post"},{"title":"神农架游记","filecontent":"date: 2022/02/07\\ndesc: 跨越 2.49 年，是不一样的感觉。\\ncate: 记录\\n神农架游记\\n\\nanger\\n流量预警\\n\\n本页含有大量未压缩原图，每张图片大小平均在 2.5M 左右。请根据自己流量供给实际情况酌情访问。由于图片较大，可能加载较为缓慢，请耐心等待。\\n:::\\n\\n开端\\n\\n最早听说「神农架」这个名字是通过电视的广告，却又很模糊，现在回想起来，也有相当长的时间没有见到过相关的广告了。一般而言的自然风景，对我来说是很难动脚前行的，这是因为我总是觉得这样的美景仅仅通过照片就足以领略，并没有什么需要亲身经历的。不过，这一次冬日前往神农架，也确实有难以遗忘的——神农架的雪。那里的温度可比武汉等地要低得多。\\n\\n实际上这次去神农架来自于家人的邀约，虽然一开始并不想去，一是因为前面所说的，二是因为 2019 年 8 月已经去过一次。但最终畏于大年廿九晚上发生的种种事情，为了避免在初 $n$ 时上演类似的遭遇，我决定前去。\\n\\n这篇杂记里，有些风景部分由于是 2019 年游历，已经忘却得差不多了，所以可能写的比较简略。重点应该是放在今年去的那一次。\\n\\n跟团和自驾\\n\\n这两次去神农架，恰好从两个方面体验了神农架的旅行体验：一个跟团，一个自驾。\\n\\n2019 年去的那次是跟团旅行，好处是可以较为经济，较为完整地体验神农架。如果只是想去看看，并且想要看个完整，跟团也许是个好的选择（不过跟团一定是节省时间的最好选择）。跟团的问题在于你的旅行具有一定的限制，活动时间、作息安排、住宿安排等都会受到不同程度的限制。虽然正常情况下旅行团都不至于将你安排得过于寒碜（如果是，建议退出），生活条件也在选择范围之内，但其自由度远远不及自驾。\\n\\nip\\n跟团还有一个问题就是你很有可能旅行就只是旅行。这是什么意思呢？你可能旅行一趟下来根本不知道去了哪些地方。或者即使知道去了这些地方，也对路上的路一点头绪也没有。\\n\\n如果你只打算去找个地方一次，那其实也没什么问题。但是这次第二次去，我深深感受到了我上一次跟团旅行所造成的这次路痴状况：什么地方都有印象，但又不知道这是哪里；去过所有的地方，但都不知道怎么走。\\n:::\\n\\n今年去的是自驾旅行。自驾最大的好处就是自己掌握，是一场有意义旅行的基础。如果你认为你并不想走马观花似地前往，就可以选择自驾。然而自驾造成的困难，最大的并不是旅途规划问题（因为都有资料可查，有向导可问），而是景区限制和消费问题。\\n\\narning\\n以下描述所针对的季节是冬天，对于夏天的情况可能有变。\\n:::\\n\\n比如这次我们开车准备上神农顶，景区规定如果外地司机没有四驱车则不允许进入；而本地司机可以直接开两驱车进入。这是赤裸裸的歧视啊！这一消息来自于「神农顶 · 大九湖」景区入口处的工作人员和我们吃饭地方的工作人员。根据吃饭地方的工作人员的描述，这样做的理由是本地人对山上路况更熟悉，水平更高！\\n\\n如果没有四驱车，或者是单纯的散客，则必须去乘景区统一的巴士上山，然后统一时间下山。但是！自驾游就要有个自驾的样子，要把主动权掌握在自己的手里！所以我们就决定先回旅店，要么就随便玩玩然后回家8。\\n\\n然而就在决定要遗憾而归的次日，我们想碰碰运气，于是又一次去到同一个入口处，人还是照样问是不是四驱，有没有防滑链（沿路都有卖的，大概价格参考：租用 ￥100，购买 ￥150，帮忙安装 ￥50）。我们故意回答的四驱。结果就真的让我们上了。笑晕，有点后悔昨天太老实了。\\n\\nanger\\n玩归玩，安全还是要保证的。技术要过关也不是没有理由的。\\n\\n上了山以后我发现和我们一样的两驱车不在少数；而有些吉普车高玩不带防滑链直接稳定上山。不过，有些两驱车即使带了防滑链，中途也在上山过程中侧滑了，差不多四五辆车前后堵在那里...甚至还差点被它滑下来撞了。\\n\\n在这次去和回神农架的高速路上，我也目睹了两起车祸。一起是去时隧道里，两辆车头碰头相撞，前部直接不成形了，还有一辆彻底上下翻倒在地上......不知道司机怎么样了。回来的路上也是两辆车前部完全损坏。\\n\\n总之，安全第一！\\n:::\\n\\n这些问题大概就是自驾要面对的。跟团的话就简单多啦。\\n\\n住宿、饮食和娱乐\\n\\n神农架的收费站在 G42（沪蓉高速）沿途，从武汉等 G42 沿途城市上高速可以直接一条路到达。最先到达的是神农架的经济重心：木鱼镇。不得不说，神农架作为景区，没有丧失它独有的特质——贵！下面举三个参考数据\\n\\n|消费项目|人数|总价|平均价格|评价|\\n|:-:|:-:|:-:|:-:|:-:|\\n|住宿|6|￥3000|￥250/人/晚|民宿（隐遇•香溪水榭）的环境真心不错，我们住的是复式，这个价格很良心了。值得注意的是这个价格是被砍过的，而且直接去那里订房比在网上订要贵个几百。|\\n|木鱼镇街上烧烤|5|￥575|￥115/人|味道是正常的烧烤味，没啥特色。虽然可能是我们点的有点多，但他的有些项目比如牛油、排骨等还是比正常情况下要贵。|\\n|爆竹|-|约 ￥400|-|贵死了。有一个炮的单价甚至高达 ￥120 但效果很差。在木鱼镇街上的便利店里买的。以为总算过把瘾了，却只有少数几个鞭炮是满意的······|\\n\\n\\n\\n这是我们这次住的民宿的正门（来源于网络）。下面三张是我拍的我们所入住的房间的状况：\\n\\nIMG_0788.JPG\\n\\n这是第一层的大床，可以容纳两个人。第二层没有拍，有两张大床，可以容纳四个人。\\n\\nIMG_0789.JPG\\n\\n一个美美寒冷的阳台。上面的烟灰缸里的水已经结冰了。\\n\\nIMG_0791.JPG\\n\\n4K 电视，机顶盒自带会员。晚上看《爱情神话》后出去吃饭~ 当时吃的就是那个特别贵的烧烤。\\n\\n下面是第二天吃的东西，在同一家餐馆（叫「老地方」，就在香溪水榭的外面）。有些菜的味道真心还不错，只是有些菜点的不太合适。\\n\\nIMG_0834.JPG\\n\\n这是被群友痛批不正宗的鸡火锅(?)，好像也是北方的一种菜式？拍的时候已经晚了，上面的软饼（不是土豆）已经被吃了几个了，本来还准备等饼子被拿完再拍，显得规整，但那样太寒酸了。\\n\\n群友的点评摘要大概如下：\\n不正宗！！！这些饼子都是做好以后再放的，应该做之前就一起炖才好吃。\\n\\n实践证明了这一点。刚开始我们都觉得这些软饼挺普通的，后来快要吃完了这些饼也没吃多少，被炖了一会以后变更软、入味了，于是就愿意吃啦！\\n\\nIMG_0832.JPG\\n\\n这是虽然普通但是我超喜欢的烤土豆~\\n\\n98049B98-E7BB-4145-BDFA-D6CCE7E4AFA1.JPG\\n\\n这是一锅牛肉，看上去很豪华，其实牛肉并不多...大多数都是魔芋。不过这个魔芋和平时吃的魔芋也不太一样，它是一咬就碎掉，平时吃的还有点弹性。\\n\\n风景\\n作为一个不经常出去旅游的人，其实任何景色都可以给我冲击。\\n\\n接下来的一个重点就是风景了。其实还算挺好的，至少对我来说是值得惊叹的景色。尤其是好几张，随手一拍竟然感觉像是网图。\\n\\n还是一一上图进行记述吧。说实话有些地方，大概是人工景点吧，我也并不了解相关的知识，也不知道该说些什么，所以就省略了。下面只介绍一些自然景点。这些景点包括了 2019 和 2022 两次访问。\\n\\n其中 2019 访问时所使用的拍摄设备是 iPad Air 2，2022 访问时所使用的拍摄设备是 iPhone X 和 iPad Pro 第二代 11 寸。\\n\\nHQ3gSg.jpg\\n\\n👆这是一个山洞里的瀑布，具体是在哪个景点已经不清楚了，如有知道的请告诉我（联系方式）。下面是瀑布底下的小湖（有一说一这个光线真的可以）。\\n\\n\\n\\n👇好像是去时路上的小湖。\\n\\nHQ8ptK.jpg\\n\\n👇下面是好几张路上的小坑洼（应该可以这么叫吧）和泉水流淌的美景！随手一拍真的好像好像网图啊。\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n不过这确实是我当时用 iPad Air 2 拍的，请相信这一点。\\n\\n\\n\\n👇山岩\\n\\n\\n\\n👇小浅滩\\n\\n\\n\\n👇长满小花和地衣的树\\n\\n\\n\\n下面的这些我就比较记得了，好像就是大九湖那边。大九湖的景色大概是这样的（也是我用 iPad Air 2 拍的~）。\\n\\n\\n\\n\\n\\n\\n\\n👇不知道在哪里拍的岩石\\n\\n\\n\\n虽然看上去阴沉沉的，但实际要比照片里亮很多。没有看到动物，有点遗憾；不过我是相信这里有动物的。大九湖附近好像也有一个类似于动物园（没有那么专门）的地方，里面可以观赏梅花鹿并且近距离接触（没有任何阻隔）。我当时给我妈拍了一系列喂梅花鹿的视频，手感：很痒！\\n\\n👇这是在梅花鹿园外面的草坪上的景象，当时有人坐滑翔伞，我拍摄了全程。山雾真的是太迷人了！\\n\\n\\n不过可惜我当时并没有拍梅花鹿。这一次自驾去其实还想看看梅花鹿，然而却并不知道路线怎么走，加之时间有限，只上了个神农顶。\\n\\n值得注意的是，2019 年去，由于是夏天，神农顶上实际是草原，看上去并没那么有感觉。然后这次去，别的地方都没去成，上了神农顶看雪景。所以这两次旅途实际上可以算作是完美的互补了！\\n\\n下面就是这次去的内容了。\\n\\n👇道路上的积雪，所以才要装防滑链。\\n\\n\\n\\n👆在拍摄这张图片时，我脚下所站的地方的积雪至少有 $30\\\\mathrm{cm}$，整个小腿几乎都陷进去了，甚至差点没爬上来。南方人总算有机会领略一下真正的冬天了。\\n\\n👇上神农顶沿路上的景象\\n\\nHQxxq1.jpg\\n\\n2019 年的夏天，由于神农顶上面还没有积雪，所以我就没有去登顶（车开到某一地方需要自己登顶，大概还要登个 $50\\\\mathrm{m}$。这次整座山都积雪了，于是我就去登顶了。虽然查了一下资料发现神农顶的海拔只有 $3100\\\\mathrm{m}$，但给我的感觉就是真的高原反应上来了。爬上去的过程特别的累，但上去一段时间就适应了，千万别放弃哦。\\n\\n下面就是神农顶上的景象了。\\n\\n\\n\\n\\n\\n\\n\\n登顶路上还有可以滑雪的地方。不过并不是单人滑雪，而是坐在橡皮舟子上划，看上去还挺好玩的，不过我没有划。这里的雪基本上都是粉状雪，也就是随便一搓就会变成单片雪花的那种，蹲一个形成原因的解释~ 有不少人在雪上写字，画爱心。在怂恿之下我也仿照着倒在一片特别平整（似强迫症福利）的雪上画人字。\\n\\n远方的山上的山雾运动得特别快，在照片里得样子是只有一点点漫上来，等到我们出发时已经将那两座山之间的缝隙填满并且漫了过来，当我们驶过时就像驶进了大雾天气。\\n\\n因为山上雪太多了，再加上有阳光，现场真的很刺眼。这导致我用 iPad Pro 拍出来的照片和视频有一大半都是不能见人的，因为这些反射光让拍出来的照片像蒙上了一层雾。只有少数几张（也就是上面那几张）包含了太阳，显示的更加清楚，但是整体上却又更暗了。所以这种专业场景还是得让摄像机来。\\n\\n至于有多刺眼：我认为这是配戴墨镜的最好时机。对于我来说我的眼睛基本上只能眯成 $2\\\\mathrm{mm}$ 的缝，没有夸张。\\n\\n其它\\n\\n神农架是冬冰夏凉。夏天，神农架绝对是武汉等地人民的避暑胜地。因为 2019 年夏天，在我家 $34°\\\\mathrm{C}$ 的高温折磨后，来到神农架简直感觉来到了天堂。当时我记得神农架只有 $10°\\\\mathrm{C}$ 左右。冬天就更不用说了，家里还在 $0°\\\\mathrm{C}$ 以上，神农架直接 $-7°\\\\mathrm{C}$，神农顶甚至 $-10°\\\\mathrm{C}$。\\n\\n神农架的旅行路线几乎是线形的：\\n\\n","filename":"Shennongjia","namespace":"post"},{"title":"一个简单的初级登录系统","filecontent":"date: 2021/05/20\\ndesc: 抛弃近乎迷惑的 session。\\ncate: 代码\\n一个简单的初级登录系统\\n\\n先前一直在想登录系统到底该怎样简洁地实现。在这里，简洁是指能够满足最基本的用户识别需求，而没有其它更多方面的需求，例如验证方面、安全方面等等。因而概括来说，我们所要实现的只是\\n登录以后储存状态，根据该状态判定访问权限。\\n\\nip\\n🐘 本文代码使用 PHP 实现。\\n:::\\n\\n基本思路\\n\\n这样一个简单的登录系统的思路，大致如下\\n前端收集登录信息。 包含最基本的两项：用户名和密码。\\n后端验证信息并发放 *Token*。 在这里，验证信息主要是对数据库中对应用户名的密码进行比对，可能的结果有不存在、不匹配和匹配三种。本文中比对所使用的方式是 password_verify 函数。\\n前端存储 *Token* 并用于执行各项操作。 后端所需要权限的操作可以将 Token 作为参数，需要 Token 才能工作。前端存储 Token 的办法，可以用 localStorage。当然，使用 Cookie 也不是不可以。本文演示前者，实现方式类似。\\n针对不同状况拟定 *Token* renew & expire 策略。 Token 一定要有有效期，自然而然也有 renew 和 expire 等问题。\\n\\n上面四条，我们接下来注意解释和实践。\\n\\n实践\\n\\n1. Token 设计\\n\\nToken 到底应该长什么样？实际上应该先讨论我们该怎样传递 Token。为了安全性，我们必定要设计一些加密（encrypt）方法。为了信息可处理，我们也需要思考怎样进行解密（decrypt）。在这个地方我们当然不能用简简单单的 base64 混合其它花里胡哨方法的肤浅加密，而要使用 OpenSSL 的相关方法。\\n\\n首先，OpenSSL 的加密函数为 openssl_encrypt，利用这个函数我们可以封装出一个简单的实际 encrypt。\\n\\nfunction encrypt($message, $key) {\\n    $nonceSize = openssl_cipher_iv_length(\'aes-256-ctr\');\\n    $nonce = openssl_random_pseudo_bytes($nonceSize);\\n\\n    $ciphertext = openssl_encrypt(\\n        $message,\\n       \'aes-256-ctr\',\\n        $key,\\n        OPENSSL_RAW_DATA,\\n        $nonce\\n    );\\n\\n    return $nonce . $ciphertext;\\n}\\n其中，aes-256-ctr 为加密方式，具体可以自行查询了解，这是比较推荐使用的一种方式。上面的函数具体内容就不多解释。利用上面的函数，只需要一个 key 即可对指定信息进行加密，这些信息便是我们的 Token。\\n\\n针对上面的 encrypt 函数，我们也有一个对应的 decrypt 函数。\\n\\nfunction decrypt($message, $key)\\n    {\\n        $nonceSize = openssl_cipher_iv_length(\'aes-256-ctr\');\\n        $nonce = mb_substr($message, 0, $nonceSize, \'8bit\');\\n        $ciphertext = mb_substr($message, $nonceSize, null, \'8bit\');\\n\\n        $plaintext = openssl_decrypt(\\n            $ciphertext,\\n            \'aes-256-ctr\',\\n            $key,\\n            OPENSSL_RAW_DATA,\\n            $nonce\\n        );\\n\\n        return $plaintext;\\n    }\\n}\\n而实际上，这两个函数都并不完全安全。在后文，我们会介绍更为安全的版本。\\n\\n这两函数便负责了加密和解密。接下来 Token 内容的组织便很容易了。我们可以使用最简单的，那就是 JSON。例如\\n\\n$token = json_encode([\\n    \\"expires\\" => strtotime(\\"+1 week\\"),\\n    \\"creates\\" => time()\\n]);\\n\\n对这个 Token，我们进行 encrypt，然后返回到前端，基本上就没有什么问题了。这个 Token 在前端将长久存在，因而其必须指定一个合理的 expires 以便后端判断其有效性。同时为了避免冒充，我们还可以在 Token 内加入一些特异性内容，例如字符串签名。\\n\\nToken 存储\\n\\n按照设计，Token 被返回到前端以后会被存储起来，目的是作为敏感操作（涉及权限的操作）的凭证。例如若要 POST 涉及权限的操作，则必须带上 Token，否则返回 400。\\n\\n上文已经提到，我们将会使用 localStorage 或者 Cookie。例如\\n\\n// 假设 r 为后端返回的 Token（已加密字符串）\\nlocalStorage.setItem(\'xxx-login-token\', r);\\n\\n至此它就被存了起来。至于 localStorage 保存数据的持续性，可以参考 StackOverflow How Persistent is localStorage?。\\n\\n对于 Chrome，localStorage 持续性的叙述为\\nOn disk until deleted by user (delete cache) or by the app.\\n\\n来自 GWTProject\\n\\n所以实际上不需要担心 localStorage 被无缘无故清掉。换句话说，Token 将会在 localStorage 中长期存在。\\n\\n在这里出现了一个问题：localStorage 在定义上是属于用户的东西，用户可以完全管理其内容，可以添加、读取和修改其内容，这会对 Token 的安全性造成什么影响？\\n\\n实际上基本没有。因为 Token 只能由后端生成，而用户把 Token 修改了相当于自己放弃了这个 Token，被修改后的 Token 也无法通过验证（decrypt）。唯一需要防备的，就是不要泄漏 Token 的加密方式。如果加密方式泄漏，那么用户就可以利用各种方法采取完全相同的加密方式加密出完全符合服务端解密函数需求的 Token。在这里，加密方式包含的不仅仅是 method 本身，还有 key。\\n\\nToken 利用\\n\\nToken 的利用主要体现在请求上，且有多种。在这里我们演示最为简单的一种：每一次 POST 敏感操作接口，附带上 Token 作为参数，后端在接到请求后，第一步是验证 Token，通过后继续操作。\\n\\n比如，每次 route 跳转到敏感页面，我们就可以执行这样一个函数：\\n\\nfunction checkAuth() {\\n  let token = localStorage.getItem(\\"xxx-login-token\\");\\n  return new Promise((r, j) => {\\n    if (!token) {\\n      j();\\n    } else {\\n      post(\\n        \\"/CheckAuth.php\\",\\n        {\\n          token,\\n        },\\n        (response) => {\\n          if (response === true) {\\n\\t        r();\\n          } else {\\n            j();\\n          }\\n        }\\n      );\\n    }\\n  });\\n}\\n\\n这个函数会获取 localStorage 中的 Token 并发送给后端相应的接口，通过验证，返回一个结果值，前端再根据这个结果值决定是否跳转到指定的页面。\\n\\n至于 Token 怎样验证：\\n\\nfunction checkToken(string $token)\\n{\\n    $key = \'...\'; // 提供加密时的 key 以解密\\n    try {\\n        $content = json_decode(decrypt($token, $key, true), true);\\n        if ($content[\\"expires\\"] > time()) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    } catch (Exception $e) {\\n        return false;\\n    }\\n}\\n\\n具体应用中还可以添加更多验证方式在里面。验证成功，就会返回一个 true。如果过期，那么就会直接返回 false。如果是无效的 Token，根据上面的 encrypt 和 decrypt 函数，会产生一个 Exception。如果产生这个 Exception，就代表通过验证的一个或多个必要条件不满足，自然就能判定这个 Token 无效。\\n\\nToken renew & expire 策略\\n\\n如果 Token 过期了，我们将把它当作无效 Token 同等处理，即 checkToken(x) 函数永远返回 false。\\n\\n至于 Token 的更新以及销毁，前者会发生在登录时。由于 Token 已经被（近乎）永远存在了前端，所以过期的 Token 并没有必要直接删除。每次登录的时候，如果 Token 没有过期，那么直接跳转到相关页面，如果 Token 过期了，那么就返回一个新的 Token。执行 localStorage 的 setItem 语句直接覆盖旧 Token 即可。而对于销毁，则是用户专门在 Token 有效的时候执行了相关的操作，这个时候就不需要和后端沟通，而前端直接删去 localStorage 中 Token 对应的数据即可，由于前面路由逻辑的存在，页面刷新以后一切就跟没有登录一样了。\\n\\n更安全的 encrypt 和 decrypt\\n\\n更安全的 encrypt 是将原先不安全函数的加密结果的开头加上一个计算出的 MAC 值。\\n\\nfunction encrypt($message, $key)\\n    {\\n        list($encKey, $authKey) = splitKeys($key);\\n        $ciphertext = unsafe_encrypt($message, $encKey);\\n\\n        // 计算\\n        $mac = hash_hmac(\'sha256\', $ciphertext, $authKey, true);\\n\\n        // 把 MAC 放在开头\\n        return $mac . $ciphertext;\\n    }\\n\\n更安全的解密也是基于 MAC 的。在这里我们先验证 MAC，然后再使用先前的解密函数即可。\\n\\n    public static function decrypt($message, $key)\\n    {\\n        list($encKey, $authKey) = splitKeys($key);\\n\\n        // 避免加密算法变换\\n        $hs = mb_strlen(hash(\'sha256\', \'\', true), \'8bit\');\\n        $mac = mb_substr($message, 0, $hs, \'8bit\');\\n\\n        $ciphertext = mb_substr($message, $hs, null, \'8bit\');\\n\\n        $calculated = hash_hmac(\\n            \'sha256\',\\n            $ciphertext,\\n            $authKey,\\n            true\\n        );\\n\\n        if (!hashEquals($mac, $calculated)) {\\n            throw new Exception();\\n        }\\n\\n        $plaintext = unsafe_decrypt($ciphertext, $encKey);\\n\\n        return $plaintext;\\n    }\\n\\n以上操作依赖了两个额外的函数。一个是用来把一个 key 分割成一个用来加密一个用来验证的两个 key。\\n\\nfunction splitKeys($masterKey)\\n    {\\n        return [\\n            hash_hmac(\'sha256\', \'ENCRYPTION\', $masterKey, true),\\n            hash_hmac(\'sha256\', \'AUTHENTICATION\', $masterKey, true)\\n        ];\\n    }\\n\\n另一个是用来验证 hash 是否全等。\\n\\nfunction hashEquals($a, $b)\\n    {\\n        if (function_exists(\'hash_equals\')) {\\n            return hash_equals($a, $b);\\n        }\\n        $nonce = openssl_random_pseudo_bytes(32);\\n        return hash_hmac(\'sha256\', $a, $nonce) === hash_hmac(\'sha256\', $b, $nonce);\\n    }\\n}\\n\\n总结\\n\\n这是一个相对来说特别简单的登录或者说是验证系统。主要的代码都写在了加密和解密上。对于这样一个系统，是肯定存在漏洞的，因而不能用来当作一个特别重要系统的主要验证方式。但是通过完善，还是可以看到这个系统的有效性的。\\n\\n这个系统在浏览器无痕模式下是无法记录 Token 的，这点和正常的登录也类似。\\n\\n这个系统不止 PHP 能实现，而能在所有的语言中实现。\\n","filename":"Simple-Authenticating-System","namespace":"post"},{"title":"简单的投票系统实现（一）","filecontent":"desc: 应该是有很多缺点才对。\\ndate: 2020/05/13\\ncate: 代码\\n简单的投票系统实现（一）\\n\\nip\\n:snake: 本文中大部分代码使用 Python 或 JavaScript 实现\\n:::\\n\\n没错，写这篇文章正是因为在业余开发一个简单的投票系统。要注意，这是简单的投票系统，因此并不具有广泛的应用前景，只是突然想到了这样的方法，分享一下。还是像往常一样，在开发一个功能之前，我们往往需要思考这个功能的细节部分该如何实现。这次的投票，我们大概需要思考如下内容：\\n\\n如何设计投票\\n投票的数据如何存储\\n  我们需要哪些数据\\n投票者应对数据有着怎样的权限\\n对投票项目的数目造成的更改会对数据产生怎样的影响\\n过滤重复的投票者\\n可视化地展示投票结果\\n...\\n\\n请不要把上面的内容看成目录，我不确定会不会 100% 按照它写\\n\\n围绕着上面这些问题，从「多选式投票」的角度出发，我们来逐一解决并实现。\\n\\n设计投票\\n\\n一般来说，一个投票大概长这样：\\n\\nip\\n我是投票的题目\\n\\n选项 A\\n选项 B\\n选项 C\\n:::\\n\\n标题并不重要，因为它只是一个纯文本，并不牵涉到任何复杂的操作，我们主要探讨选项部分。如果从组件的角度解释选项，大概就是同一个组件被利用了多次，每一个组件副本均有着不一样的文字，对应和控制着不一样的数据值。也正因为重复性，我们可以直接利用循环来「生成」这些选项。\\n\\n我们首先需要定义一个描述该选项内容的文本数组，以及一个与文本数组相等长度的布尔数组，并将这个数组事先全部填为 false 以便记录。例如，如果我们要实现上面例子里的选项渲染，应当做的是：\\n\\nlet items = [\\"选项 A\\", \\"选项 B\\", \\"选项 C\\"]\\nlet dataArray = [false, false, false]\\n\\n更广泛的方法：\\n\\nlet items = [\\"A\\", \\"B\\", /* ... */]\\nlet dataArray = [];\\ndataArray.length = items.length;\\ndataArray = dataArray.fill(false);\\n\\n这样就可以轻松借助循环来实现在两个不同数组相同位置的数据关联。以 Vue 为例子：\\n\\n    \\t{{ x }}\\n\\n给 checkbox 或者 radio 组件绑定一个 v-model 指向数据数组的相应位置，那么该选项就与该位置的布尔值建立了联系。被选中为 true，未被选中或被反选则为 false。\\n\\n数据存储\\n\\n我们选择使用最简单的方法——将数组以字符串的形式存储到数据库的表中。一般来说，对于复杂的情况，我们也许要记录用户或者其它杂七杂八的，但对于这种简单的情况，我们只需要收集有多少人选择了这一项。那么首先我们需要弄清楚的一个问题，如何将 [false, true, false, false] 这样的数组，转换为一个记录每项选中人数的数组。\\n\\n既然我们的数组里每一个布尔值，都跟一个唯一的选项对应，那么我们可以记录所有为 true 的值在数组中的位置。例如，我们可以创造一个函数 getTrueIndexes(array: Array): Array：\\n\\ngetTrueIndexes([false, false, true, false])\\n// => [2]\\n\\ngetTrueIndexes([true, false, true, true])\\n// => [0, 2, 3]\\n\\ngetTrueIndexes([false, false, false, false])\\n// => []\\n\\n简单实现：\\n\\nfunction getTrueIndexes(array: Array): Array {\\n\\tlet arr = [];\\n\\t// 用 for 也可以\\n\\tarray.forEach((k, i) => {\\n\\t\\tif (k) arr.push(i)\\n\\t})\\n\\treturn arr;\\n}\\n\\n接下来我们来讲讲如何去存储每个选项选中的人数。一些人可能开始会想到这样的结构：\\n\\n{\\n    a: 1,\\n    b: 2,\\n    c: 4\\n}\\n\\n也就是利用对象的键值构建选项与人数之间的关系。\\n\\n这种办法的缺点也很明显——键显得很没必要。因为正如前文所介绍，投票项目呈有序排列的（即每一个项目的位置均与最终数据有对应联系），因此使用数组并无大碍；对象则将每一个选项的独特标识关联到了一个特定的数据，这种结构似乎更适用于那种可能会被打乱的数据集，或者更为复杂的投票结构，对于本文中的「简单」投票系统没有实际意义，同时也会对后面的操作造成困难。\\n\\n所以，我们最终所需要的只是\\n\\n[1, 2, 4]\\n\\n这是什么意思？还是上文中的例子，这代表着选项 A 有一人选中，选项 B 有两人选中，选项 C 有四人选中。\\n\\n对于此数组的初始化，不同于前文的 [false, false, false]，它应当位于后端。使用 Python 可以轻松做到\\n\\nitems 即前端中的选项文字数组\\nvoteData = [0 for i in range(len(items))]\\n\\n那么这个时候 voteData 就会被初始化为一个全为 0 的数组，就像 [0, 0, 0, 0]，代表还没有任何人投任何项。\\n\\n回到之前的话题来，我们获得了一个标注了「被选中」项目（即为 true 的项目）的位置的数组，然后此时我们要以它为依据对位于后端的统计人数的数组做出修改。实际上很简单\\n\\n假设：来自前端的数据\\nvoteTargets = [0, 1, 3, 4]\\n假设：后端记录人数的数据\\nvoteData = [0, 0, 0, 0, 0, 0]\\n\\nfor i in voteTargets:\\n\\tvoteData[i] += 1\\n\\n也就是这样，可以直接实现对数组指定位置的修改。其中 += 1 是定值，除非是想要让每个人的一票变成多票。\\n\\n修改投票\\n\\n如果我们要对原先的投票项目做出修改（不是修改数据）怎么办？实际上，这是不被允许的——因为如果我们将投票的项目文本修改，就有可能影响投票本身的客观性，例如我们可以将「支持」项改成「反对」，这是很恐怖的。不过，本文只作技术讨论，具体地可以看情况进行取舍。\\n\\n修改投票时，对应的数据的意义将会受到影响，在这里我们讨论两种极端情况，即「新建」和「清除」。\\n\\n在对投票的项目进行编辑时，我们需要记录究竟删除了哪些项目，增加了多少项目？这些记录的代码可以放在删除或增加时所要调用的函数内。\\n\\n\\n\\n\\n{\\n\\tdata() {\\n\\t\\treturn {\\n\\t\\t\\tdeletedCount: 0,\\n\\t\\t\\t// ...\\n\\t\\t}\\n\\t},\\n\\tmethods: {\\n\\t\\tdeleteVoteItem() {\\n\\t\\t\\tthis.deletedCount += 1;\\n\\t\\t\\t// ...\\n\\t\\t},\\n\\t},\\n\\t// ...\\n}\\n\\n\\n如果删除了项目，则对应的数据也应当被删除。因此，还需要加上记录该被删除项目在数组中的位置的机制；如果增加了项目，那么也应当在数据数组的最后追加相应数量的 0。具体流程应遵循先删除旧项再添加新项的原则，否则会导致数据的对应问题。删除时，使用 del 关键字可以实现：\\n\\n删除\\ndel voteData[index]\\n\\n增加时，我们先创建上下文场景以便更好地叙述：\\n\\n假设这是原先的投票项目数据\\nitemsOld = [\\"选项 A\\", \\"选项 B\\"]\\n假设这是添加后的投票项目数据\\nitemsNew = [\\"选项 A\\", \\"选项 B\\", \\"选项 C\\", \\"选项 D\\"]\\n假设这是原先的记录人数数据\\nvoteData = [0, 0]\\n\\n原理与先前大致相同，添加了简单的计算：\\n\\nvoteDataNew = voteData.extend([0 for i in range(len(itemsNew) - len(itemsOld))])\\n\\n上述代码有没有问题？是有的。extend 方法会改变原先数组的数据而不会返回一个新的值，这与往常情况不同。因此，我们要去掉前面的赋值部分，否则会导致 voteDataNew 的值变为 None\\n\\nvoteData.extend([0 for i in range(len(itemsNew) - len(itemsOld))])\\n然后再对 voteData 进行操作就行了\\n\\n以及请不要使用 append 方法，否则可能让你的数组变成 [0, 0, [0, 0]]。\\nTo be honest, no one likes it.\\n\\n未完待续\\n\\narning\\n由于个人原因，此文章的续集可能需要较长时间完成。\\n:::\\n","filename":"Simple-Vote-Logic-1","namespace":"post"},{"title":"一些 Vue 的常用技巧（续篇）","filecontent":"cate: 代码\\ndesc: 本期热点：状态管理\\ndate: 2023/01/26\\n一些 Vue 的常用技巧（续篇）\\n\\n5. 自制状态管理\\n\\n通常情况下想到全局的状态管理，最原始的方式是 eventbus，然而只能实现事件的通讯传递；数据在传递过程中必须有一层操作。若想用正规且有保障的方式，可以用 pinia 或者 VueX，然而都有杀鸡用牛刀之势。\\n\\n一个最简单的状态管理，其实就是一个 object。但是为了对其的修改可以引起视图的更新，需要让其变得 reactive。这可以通过 Vue 自带的函数 reactive 实现。\\n\\nimport { reactive } from \'vue\';\\n\\nconst states = {\\n    state1: \\"123\\",\\n    state2: \\"123\\",\\n    state3: \\"12\\",\\n}\\n\\ndeclare module \'vue/types/vue\' {\\n    interface Vue {\\n        $states: typeof states\\n    }\\n}\\n\\nVue.prototype.$states = reactive(states)\\n\\n此时在组件里可以通过调用 this.$states.state3 = \'123\' 引起视图的更新。\\n\\n6. v-model 的使用\\n\\nip\\nv-model 是常用的 Vue Directive 之一。在这里清晰地介绍其用法。\\n:::\\n\\n在编写 checkbox、dialog 等组件的时候，经常需要在父组件内控制子组件的状态。例如\\n\\n\\nimport Vue from \'vue\';\\n\\nexport default Vue.extend({\\n    data() {\\n        return {\\n            dialogState: false\\n        }\\n    }\\n})\\n\\n\\n这一点在子组件内如何实现呢？官方提供了 v-model 这一方案，实际上是语法糖。\\n\\n\\n以上两行代码应当是等价的。具体的逻辑是\\n\\n父组件向子组件传入 data（对应 props 中的 value）\\n子组件使用此 data\\n有需要时，子组件使用 $emit 触发 input 事件提出更新，父组件更新相应的值，导致 data 传入子组件 props 的值发生变化\\n子组件使用新的 data 值\\n\\n这一整个逻辑都可以使用 v-model=\'data\' 做到。例如对话框\\n\\n父组件：\\n\\n            关闭\\n\\n\\n子组件：\\n\\n\\nimport Vue from \'vue\';\\n\\nexport default Vue.extend({\\n    props: {\\n        dialog: Boolean\\n    },\\n    mounted() {\\n        window.addEventListener(\'keydown\', e => {\\n            if (e.key === \'Escape\') {\\n                this.$emit(\'input\', false);\\n            }\\n        })\\n    }\\n})\\n\\n","filename":"Simple-Vue-Tricks-2","namespace":"post"},{"title":"一些 Vue 的常用技巧","filecontent":"date: 2022/06/08\\ndesc: 再做类型体操我就是\\ncate: 代码\\n一些 Vue 的常用技巧\\n\\n在长期使用 Vue 的过程中，我并不清楚是否是因为自己对这些东西的实现逻辑太过于奇妙，才催生了这些技巧的产生。也许这些问题在 React 中压根也不会出现吧...？在这里浅记录一下以便以后查看，顺便水一下。\\n\\n不过，这些技巧很大部分都仅适用于在 TypeScript 加持的情况下。有的时候用 TS 甚至觉得整个过程变得更加复杂，网上的有些代码甚至是库都没办法好好直接使用。好在现在这种情况正在减少。总之 TS 对于大项目来说是绝对稳的！但是小项目就不一定值，甚至还有些舍近求远的意味；另外做类型体操真的很傻。\\n\\n下面以小标题的形式分开单独介绍。\\n\\n1. VueX 中对 Mutation、Action 的规范化调用\\n\\n介绍\\n\\n一直不是很能理解为什么 VueX 中的 Mutation、Action 的函数在定义以后却要用字符串这样一种形式来识别。我当然也想不出更好的模式啦。\\n\\n例如：\\n\\nmutations: {\\n    mutation(state, pay) {\\n        state.abc = pay;\\n    }\\n}\\n\\nstore.commit(\'mutation\', 123);\\n\\n这就使这个过程完全丢失了 IDE 的支持。对于 VueX 中数据存放很多关系很复杂的情况来说，并不是很优雅，不过具体体现在维护而不是编写上。所以我更倾向于使用一种常量字符串的模式来定义函数名，并也在 commit 和 dispatch 函数参数中使用。对此，实际上官方给了一个很完整的示例了。\\n\\n然而在这个示例中，到后期也会发展为这样的局面\\n\\nexport const MUTATION1 = \'MUTATION1\';\\nexport const MUTATION2 = \'MUTATION2\';\\n// ...\\nexport const MUTATIONn = \'MUTATIONn\';\\n\\nimport { MUTATION1, MUTATION2, ...} from \'./mutationTypes\'\\n\\n如果将它们整合到同一个 Object 中，效果会怎么样呢？\\n\\n当然这一切也只是从个人喜好出发的。正如官网所说：\\nWhether to use constants is largely a preference - it can be helpful in large projects with many developers, but it\'s totally optional if you don\'t like them.\\n\\n实现\\n\\n首先明确一点，常量字符串的内容就是 mutation 函数的名字。从这个角度出发，首先定义一个数组，里面包含了所有所需的 mutation。\\n\\nconst mutationTypes = [\'m1\', \'m2\', ..., \'mN\'] as const;\\n\\n特别注意末尾的 as const，用于将这个变量的类型限定得尽可能小。也就是说 mutationTypes 总体上来说就是一个 string[]，但实际上也可以看成一个由它所有的值所构成的一个联合类型数组。as const 将其类型明确规定为后者。\\n\\n接下来将这个数组转换成一个联合类型，也就是 \'m1\' | \'m2\' | ... | \'mN\'。\\n\\ntype MutationTypes = typeof mutationTypes[number];\\n// 如果上一步没有 as const，这里得到的结果就是 string。\\n\\n然后考虑将这个数组拓展成一个键和值相同的键值对，也就是 {m1: \'m1\', ...}。这个键值对就是我们最终所要的结果。定义这个键值对的类型：\\n\\ntype Result = {\\n\\t[K in MutationTypes]: string\\n\\t// 这里也可以把值类型定为 MutationTypes，但是没有必要。\\n};\\n\\n接下来构建这个键值对：\\n\\nlet result: Partial = {};\\ntypes.forEach((k: MutationTypes) => {\\n\\tresult[k] = k;\\n});\\n\\nPartial 是为了让其初始值可以为空对象 {}。最后导出为 Result 类型即可。\\n\\nexport default result as Result;\\n\\n完整代码：\\n\\nconst mutationTypes = [\'m1\', \'m2\', ..., \'mN\'] as const;\\ntype MutationTypes = typeof mutationTypes[number]\\ntype Result = {\\n    [K in MutationTypes]: string\\n}\\nlet result: Partial = {};\\ntypes.forEach((k: MutationTypes) => {\\n    result[k] = k;\\n})\\nexport default result as Result;\\n\\n使用：\\n\\nimport mt from \'./mutationTypes\';\\n\\nstore.commit(mt.) //\\n\\nimport Component from \'./Component.vue\';\\n\\nexport default Vue.extend({\\n\\tcomponents: {\\n\\t\\tComponent\\n\\t},\\n\\tcomputed: {\\n\\t\\tmyElement(): HTMLDivElement {\\n\\t\\t\\treturn this.$refs.myElement as any;\\n\\t\\t},\\n\\t\\tmyComponent(): InstanceType {\\n\\t\\t\\treturn this.$refs.myComponent as any;\\n\\t\\t}\\n\\t}\\n});\\n\\n这样的话直接访问 this.myElement 和 this.myComponent 就可以了，或者也可以将 computed 的内容换到 methods 里，使用 this.myElement().xxx 进行访问。但这里还会存在一些瑕疵，毕竟这一部分的类型操作不是由 TS 而是由你自行决定的。\\n\\n问题：计算属性无法获得值\\n\\n因为 refs 本身并不是响应式的，这里放到 computed 里属于是强行加上响应式。实际上只有在组件被渲染以后，this.$refs 才能获取到值，否则就是 undefined。这导致直接访问相应计算属性总会得到一个 undefined 的结果，可能造成崩溃。解决办法是识别组件 mount，在此之前不返回 refs 的值。\\n\\nmyComponent(): InstanceType | undefined {\\n    if (!isMounted) return;\\n    return this.$refs.myComponent as any;\\n}\\n\\nip\\nInstanceType 是很好用的一个类型推断，它可以用来直接识别出实例化以后的类型。将该类型作为返回值类型，可以让 IDE 中直接提示子组件所具有的方法和值等，十分方便。如果直接使用 typeof Component，得到的是未实例化的原始 class 类型。\\n:::\\n\\n然后在 mounted 钩子里加上 this.isMounted = true 即可。参考 StackOverflow - Using Refs in a Computed Property。\\n\\n另外还有一种特殊情况是这个组件并不会马上被使用，这就需要根据组件自身 mount 的情况来定了。解决思路是在组件内部的 mounted 钩子中触发事件，例如 this.$emit(\'mounted\')，然后父组件监听该事件改变自身相关变量，再加上类似于上面的 if (!isMounted) return; 结构。\\n\\n如果嫌麻烦，可以使用函数的方法，使用体验基本没差。\\n\\n问题：组件本身可能就是 undefined\\n\\n通常情况下这是不会的，但是如果存在相关的可能，就不能不考虑。此时应当将返回值定为相应类型与 undefined 的联合类型。\\n\\n3. 定义全局函数\\n\\n介绍\\n\\n不仅仅是全局函数，也可以是类实例或者简单的值。唯一的目的是调用方便。这参考了一些注入的全局变量，例如 this.$route、this.$store。开发早期如果不需要 VueX 而需要采用 event bus 的方案的话，也可以使用这种办法来定义全局量，从而可以在任何地方方便访问。\\n\\n实现\\n\\n要写入全局变量，只需要在 main.ts 中定义 Vue 的 prototype。\\n\\nimport Vue from \'vue\';\\nimport Hello from \'hello\';\\n\\nVue.prototype.$hello = new Hello();\\nVue.prototype.$bus = new Vue(); // event bus 实际上就是一个空的 Vue 实例\\n\\n但是这样还不够，TS 并不知道这是什么意思。要解决这一点，需要在项目编译路径（一般就是 src 里的任意一个位置）编写一个 .d.ts，内容如下：\\n\\nimport Vue from \'vue\';\\nimport Hello from \'hello\';\\n\\nlet h = new Hello();\\nlet v = new Vue();\\n\\ndeclare module \'vue/types/vue\' {\\n    interface Vue {\\n        $hello: typeof h;\\n        $bus: typeof v;\\n    }\\n}\\n\\n上面两者的类型写法等价于用 InstanceType 的写法。这样就可以在实际编写中随便用了。\\n\\n4. 融合样式代码\\n\\n介绍\\n\\n写 Less 的时候用到的一些变量如果想要起到全局的作用，仅仅在 main.ts 里 import 并不够，还需要在每个 CSS 代码中加入。使用这个插件可以让所有样式代码互通有无。这个插件由官方文档推荐，既可以通过 Vue CLI 使用，也可以自行配置到 Webpack 中。\\n\\n实现\\n\\n对于 Vue CLI，安装相应的插件并配置即可。\\n\\nvue add style-resources-loader\\n\\n参考配置（vue.config.js）：\\n\\nconst path = require(\'path\');\\n\\nmodule.exports = {\\n    pluginOptions: {\\n\\t\\t\'style-resources-loader\': {\\n\\t\\t\\tpreProcessor: \'less\',\\n\\t\\t\\tpatterns: [path.resolve(__dirname, \'./src/styles/*.less\')] // 这里填要融合的样式文件。\\n\\t\\t}\\n\\t},\\n}\\n\\n对于 Webpack 请查看仓库：yenshih/style-resources-loader。\\n\\n总结\\n\\n后期如果还有类似的想法或许会在这篇文章上更新，目前分享的也就这些了。如果你认为有些地方不太合理或者有更好的方法，亦或者有疑问，欢迎与我探讨。","filename":"Simple-Vue-Tricks","namespace":"post"},{"title":"短期锐评","filecontent":"date: 2022/03/18\\ncate: 思想\\ndesc: 衍生剧\\n短期锐评\\n\\n我从来没有想过，是否存在着这样一种虚伪，你活在之中，是那么的自然。所有人都向着你的时候，他们让你以为这是理所当然；而当你无法给予或者违背之时，那么就是忘恩负义、不知廉耻了。\\n\\n我从来没有想过，是否存在着这样一种偏见，你永远接受，是那么的自然。所有人都支持他们的时候，你以为这是人伦天性；而当你发现这一切竟是剥夺与残害、歧视与挖苦的时候，你却又发现自己无能为力了。\\n\\n我从来没有想过，是否存在着这样一种「被受益」，你屹立在其中，不知不觉而岿然不动。纵使你相信命运永不可被旁人所标定，他人却将你被捧在手心的事实演化得淋漓尽致。\\n\\n我想，若是顺从，也便成了帮凶，更何况这不能给我带来什么好处，所以我坚决不会做；若是反叛，也便成了混蛋，更何况他们对你有了那么多的施予，所以我不得不考虑。\\n\\n若把这份痛苦的纠结理解为恶毒，未免过于曲解人类的某些动物性本能，即使这份本能早在人类开化以后与对利益的追求和欲望完全混淆；若把这份痛苦的纠结理解为本分，当然是不大可能，因为这份思想不是什么好思想，这样的传统不是什么好传统，信奉它的人自然也不是什么好人了——从最根本地来说，我们为什么要损害别人的利益呢？人皆有不忍人之心。不过，这句话的提出者也许两面三刀，但我不是。\\n\\n想多了吗？我觉得没有。这是可以发生在每一个人身上的事情，让我感到别扭，是因为我厌恶这样一种眼前的物质条件虽已被我自己当成常态，但最终却发现这是他们牺牲了有些人的欢愉与兴致乃至人生看法专门换来的多余品。对此，我无法改变，无法弥补，无法适应缺失以后的身份活，更无法接受他人被伤害。\\n\\n至于一些只会谈世俗和眼前利益的肤浅之人，我的观点只能概括为多说无益，无可奉告。\\n","filename":"Smalltalk","namespace":"post"},{"title":"吐槽一下 Vercel 的大无语操作","filecontent":"date: 2023/12/13\\ncate: 代码\\ndesc: 好荒谬，就像经过精密数学计算以后算出来公交车上只有 1.5 个人那样荒谬💧\\n吐槽一下 Vercel 的大无语操作\\n\\nip\\n说是吐槽，发现不知不觉写成了流水账。看个乐呵就好 \\\\^_\\\\^\'...\\n:::\\n\\n\\n拱出去，拱得远远的\\n\\n如你所见，这个网站自 2023 年 7 月被搬迁到了 Vercel 上面，采用 GitHub 托管源代码+Vercel 持续集成自动部署的模式来呈现。考虑到使用 Vercel 的一大原因，是 对 Vue 的路由相关考虑（Wanna have ugly #Hashtag in URL or 404 on refresh???），这是在搭建这样的低成本静态网站时经常会遇到的一类焦灼。\\n\\n然后就在几天前，一位伙伴向我发来邮件请求添加友链。等我修改好 Blogroll.vue 以后，却发现 deploy 不上了，现象是 vue-cli-service build 了 45 分钟还没有部署好，超时被 kill。我真惊了，因为平时 deploy 基本上用不到 2 分钟（如果弥补了使用 puppeteer 的大坑，那么甚至不到 1 分钟），不清楚是啥情况。而且我尝试本地 build，一切正常。\\n\\n于是我就发现了 Node 引起的这个离谱的 Bug，以及 Vercel 无脑帮助用户做版本决定的荒谬机制。\\n\\n首先，我尝试 redeploy，发现每次的表现不一致。上面的那一种表现是卡死无反应，一直持续到超时，而另外还有两种表现：\\n\\n\\n你没事吧？\\n\\n\\n你没事吧？？\\n\\n一种是随机位置出现 Unexpected token [???random, mostly a blank] in JSON at position [???random] 的报错，???random 中三个问号表示我的极度疑惑和严厉批评。另一种是先给一个莫名其妙的 undefined:1，然后输出一大段莫名其妙的 JSON。\\n\\n我怀着侥幸心理，选择了这一大段莫名其妙的 JSON 在 Google 上搜索。也不知道是运气好还是咋地，还真搜到了有人在 Issue 上的反馈（后来我发现再随便选然后搜，也搜不到了😓）。\\n\\n\\n\\n这个 Discussion 反馈的问题和我的基本上是一样的（也是使用 vue-cli-service 来构建的时候出现的，虽然这个故事和 Vue 关系应该不太大？），他是这么描述的：\\nHello. Long story short 2 weeks ago everything worked fine with Github actions. Now we only commited a small style change (a new CSS rule for an ID) and the build for CI/CD failed. We are deploying to an Azure environment. npm install works just fine, no other modification were done and last build was successful.\\n............\\nWe tried everything from updating all packages to using the known working versions, checking the code etc. On our local machines it\'s working well. Any idea of how to solve this would be welcomed.\\n\\n然后这个帖子指向了这个 Issue\\n\\n\\n\\n其中说到的 Actual Behaviour 和我遇到的一模一样，基本上可以确定了：\\nActual Behavior\\nWebpack build either hangs indifinetely or fails with the following 2 errors:\\n- JSON Parse failed unexpected token at random, each time, positions\\n- Error EPIPE\\n\\n下面的评论中提到是 Node 18.18 中的 libuv 库升级导致的，可以通过提供一个环境变量来避免出现问题。这个解决方案还有些许人点赞。后来试了一下发现对我来说并不可以。\\n\\n\\n\\n有一个人回滚到 18.17 就可以避免这个问题。于是我终于知道为什么我可以在本地 build 而到 Vercel 上就会爆炸了。因为我本地版本就是 18.17，而 Vercel 上就是 18.18......于是我开始想办法，如何修改 Vercel 的 Node 版本。在翻看配置项的时候，发现了一个调整版本的地方，却只有可怜的三个选项：16.x、18.x 和 20.x，其中 16.x 选中了会提示你 deprecated，20.x 选中了会提示你 beta...已经开始有点别扭了。而这个 18.x，没有明确的版本号，而实际上 node -v 输出的就是 18.18 最新版。\\n\\n于是自然我把目标转向如何改为 18.17。官方提供了文档，是这么说的：\\nYou can define the specific node version in the engines section of the package.json to override the Project Settings. However, the value set in the Project Settings dictates the accepted values for the node property.\\nFor instance, when you set 20.x in the Project Settings you can specify a valid v20 range in package.json. But setting >16.0.0 with 16.x selected, will deploy with the latest v18.\\n\\n也就是说，在 Vercel 上你不能使用奇数版本的 Node，因为选项中根本没有，而只能手动指定大版本范围内的小版本。这......虽然对我没啥影响吧，但就是有点不爽。而根据这段话所说的，实际上是可以在 package.json 中 engines.node 指定具体的版本的，下面的表格中也列出了这一点，证实了我的猜想。\\n\\n\\n\\n于是我兴高采烈地去 package.json 中把 engines.node 设置成 18.17.0，以为这样问题就能得到解决时， Vercel 在部署的时候提供了这么一句话：\\n\\nWarning: Detected \\"engines\\": { \\"node\\": \\"18.17.0\\" } in your package.json with major.minor.patch, but only major Node.js Version can be selected. Learn More: http://vercel.link/node-version\\n\\n它竟然直接大胆地说 only major Node.js Version can be selected，也就是说我只能控制是不是 18 这一个大版本...那文档中说的这些，不就跟没说一样了。更何况表格中已经列出来了，结果实际上又不是这样。这真是让人无语到了极点了。去 GitHub 上找类似的问题，也只找到了这一篇：\\n\\n\\n\\n有位回答者刚开始是照搬文档中提到可以手动设置具体版本，结果发现并不是这样，于是就说只能设置 major 版本。同时引用了 Vercel 文档中出现的这样一段话：\\nOnly major versions are available. That\'s because Vercel will automatically roll out minor and patch updates if needed (for example in the case that a security issue needs to be fixed).\\n\\nDefining the node property inside engines of a package.json file will override the selection made in the Project Settings and print a Build Step warning if the version does not match.\\n\\n很好，还给出了只能设置 major 版本的理由，因为 Vercel 会自动打补丁。很想说一句，谁让你打了？像现在这种情况，18.18 导致问题而 18.17 就不会导致问题，那么这句话里所说的「因为会自动打补丁所以不让你手动设置 minor 和 patch 版本」就很不可靠了。\\n\\n下面这句话说了又感觉跟没说一样，有什么用呢...\\n\\n总结\\n\\n这一整趟下来呢，就是又疑惑又失望的感觉吧，就感觉很荒谬，不知道说什么的荒谬。那么，最后是怎么解决的呢？由于 Vercel 最终是将一个目录内的所有文件作为无后端应用的代码来跑，所以只要手动 build 到这个目录里面，然后跳过在 Vercel 上的 build 过程就好了。\\n\\n所以现在我的 build 指令长这样：\\n\\n\\n我tm直接 build success！\\n\\n其实感觉问题不大，就是可能每次 commit 之前都要花个一两分钟来 build 一下（目前实测：本地 build 45s，Vercel 部署 5s）。这样的操作估计得要持续到上面我想到的解决方法能实现的那一天了😅","filename":"Some-Gossip-on-Vercel","namespace":"post"},{"title":"对于疫情中我的电脑的一些感悟","filecontent":"desc: 浪费了我太多的时间，让我无事可干。\\ndate: 2020/03/06\\ncate: 思想\\n对于疫情中我的电脑的一些感悟\\n\\n可能与我有过接触的人在最近就已经听说过我的电脑发生了什么。其实发生了什么并不重要，重要的是这个时期不对劲，这个事情处理不对劲。\\n\\n不知为什么，总是觉得自己如果缺少了电脑，生活就好像空洞了一大部分。我的电脑卒于 2020 年 1 月 24 日，我 28 日下的单，至今快递未发货。旁观者的角度来看，这并没有什么大不了的。的确，我也在这样说服自己，没必要为这种必然的事情过于主观，毕竟各个行业都有他们自己的难处。\\n\\n而这段时间里，我的心情却一直无法平静下来。一天到晚总是去看京东，看物流。问客服，客服说“完全不能发”，或者是“正在陆续申请复工中”，我的希望彻底破灭了，于是看京东的次数减少了，渐渐越来越不接受现实。\\n\\n让我想想，我能用电脑干什么？\\n\\n写代码，体验高分辨率屏幕下 Fira Code 的连字效果；\\n看视频，屏幕大，相当于是小电视；\\n玩游戏，Steam 上应有尽有；\\n浏览一些网站；\\n还有更多我暂时没想到，但的确是很多。\\n\\n说实话我并不是一个非常喜欢手机的人，甚至对现在年轻人对手机的依赖远远大于对电脑的依赖感到很疑惑不解，对某位前辈发表的“电脑无用论”感到沮丧和悲哀。无论如何，手机是无法取代电脑的，这一点我坚信不宜。我认为手机只是一个“小屏体验上的升华，携带上的精神哲学，不可阻挡的发展潮流”。对于我的“主业”——代码来说，手机基本上就是一个完全荒废了的存在。\\n\\n因此我完全没有耐心相信京东写的 2 月 9 日到货，开始在家里寻找破旧的电脑。\\n\\narning\\n\\n可是后来，事情并没有这么简单。我分别收到了如下日期通知\\n\\n2/9\\n2/18\\n2/19\\n2/25\\n2/28\\n3/9（截止发布日期今天）\\n\\n:::\\n\\n我尝试过使用很久之前的一台台式组装机，CPU 是速龙，大概是 2006 年买的。我在组装它的配件时越来越绝望，觉得这样只是在自己欺负自己。但最终它打开了，却是黑屏。于是我想起了那台搁置许久不用的乞丐笔记本——一个普普通通的笔记本，曾经有它原来的辉煌。\\n\\n先前尝试使用过一两次，但都并不是很理想，因为装的是 Windows。于是我立马装上了 Linux，然后接上了我的显示屏，悲剧依然发生了。由于笔记本配置有限——四代 i5 降频 U，4GB RAM，无 SSD——我觉得使用起来非常之吃力与糟心。\\n\\n在这个时候我想到了某位 B 站 UP 主，他很年轻，关注了他数个月后突然发布了一个退坑声明，内容仅为“我实在是用不动我的电脑了。完全无法进行剪辑工作”。他的电脑现在仍然是往年的低端赛扬。或许是我记错了，但也只能比赛扬更 Low 了。我内心中发出了疑问，既然做了视频，就必定要确保自己有好的电脑。他的理由很简单——父母不想买新的电脑。当时我想想有多少个梦被这样残忍地扼杀在了摇篮里，内心觉得很激动而又无能为力。却又有一丝侥幸——因为我从小到大没用到过卡顿的电脑。\\n\\n可如今，我终于体验到了他的心情。\\n\\n在这个电脑上的体验，大致可以用如下一段文字来描述\\n在这个危机时期，我不得不使用一台非常卡顿的电脑。如果单凭这个电脑原本的显示器（1280*720）的分辨率，完全无法处理我所要做的事情。但连接到了我的显示屏上以后，带起来更加吃力了。无论执行什么操作，至少需要等待 5 秒以上才能够得到回应；Lauchpad 打开以后是一段令人难以忍受的掉帧动画。\\n\\n我现在除了在 GitHub 上直接用网页更改代码，打打指令，勉强小窗口运行一下 Minecraft 以外，什么也做不了。以往还可以在我的电脑上鼓捣一下系统，做做摸鱼视频，画画图什么的——多丰富啊。而现在我觉得我用 apt 安的任何一个软件都是没有必要的，总觉得我即将离开这台电脑。然而后来才发现日子还很长。\\n\\n这是一种与众不同的精神摧残\\n\\n没错。我认为这是一种与众不同的精神摧残。很多时候它并不仅限于那些“急性子”，甚至于和急性子一点关系也没有。它确实会让人感觉很不爽。很多时候我们会发现一台破旧的电脑有如下这些问题，且似乎在每个人的身上都出现过\\n\\n开机慢\\n莫名其妙就出现卡顿——哪怕你什么也没有做，只是移动了一下鼠标\\n对于某个操作反应迟钝，导致你不得不依照自己的大脑继续去重新做一遍，最终又导致电脑处理了多个相同的事情，一下子打开好多个窗口\\n关机慢\\n关闭软件慢\\n\\n我呼吁每一个认为自己电脑卡顿的人一定要尽快更换自己的电脑。因为目前这台电脑已经让我的工作效率至少降低到了原来的十分之一。为了自己的未来，不需要顾虑换台电脑的那些钱。\\n\\n打破以往的精神底线，我耐着性子忍到了今天。于是我写了这篇文章来发泄我的感情，但事实上新电脑还有很长的路要走，我会这样等着。我也不是很能理解某些人，某些组织，因为某些原因，和某些理由，进行的某些行为，导致了某些人的某些快递，因为某些某些人所声称的某些原因，而被困在某些地方，无法满足某些人的某些需求，从而导致某些人的某些方面出现某些程度上的某些差错。\\n\\n我认为我会因这台卡顿的电脑患上焦虑症。","filename":"Something-About-Something","namespace":"post"},{"title":"记一次手贱导致的电脑危机","filecontent":"desc: 无语无语无语无语无语无语奉劝各位集美不要手贱打开 HDR（设备明显支持除外）！我现在看到这个按钮就心有余悸。\\ndate: 2021/01/02\\ncate: 记录\\n记一次手贱导致的电脑危机\\n\\n对于那些不通过一些手段无法修复的问题，我一般统称为‌电脑危机。最近的几年里经历的电脑危机有点多，甚至还让我损失了一些昂贵的配件，而且它们产生的原因都是匪夷所思的，让我怀疑自己是不是真的运气不好。那么这一次就把它记录下来吧。\\n\\n起因\\n\\n起因很简单也很搞笑，我自己手贱把 Windows 设置里的 HDR 打开了。可能是因为 HDMI 线缆或者显卡等问题，电脑显示屏再起不能，然而依然有声音，代表只是显示不了。在这里我要疯狂抱怨一下 Windows 对这个的处理，分辨率调错了还可以自动回退（倒计时），HDR 这种东西就直接默认了！无语子。\\n\\n接下来就该想办法解决了，那么我究竟用了些什么办法呢？\\n\\n解决之路\\n\\n想办法把 HDR 关掉\\n\\n首先我在想办法进入安全模式。根据我模糊的记忆，安全模式应该不会有这些七七八八的设置的。然而我又想起来 Windows 10 也并没有古老的 F8 概念，于是开始 Google。结果发现，可以通过开机过程中多次长按电源键强制关机，让电脑意识到你有麻烦，自动进入修复界面，我试了一下是真的，心疼硬盘。\\n\\n那么我进入了安全模式，发现...HDR 居然是关的。然而我又进了一遍系统，还是黑屏，那么这就代表着 HDR 这玩意...对系统是独立的！而且也有可能因为安全模式并没有完全加载显卡驱动导致设置内容产生差异。这可怎么办？想到了用指令来关闭，然而看到了微软官方的回答，没有指令。这路可封得死死的了。\\n\\n想办法通过重装系统还原 HDR 有关设置\\n\\n于是这个时候只能想到一点，那就是重装系统。修复界面里的确是有重装系统的选项的，于是我毫不犹豫地点击了保留用户个人资料恢复。结果直接给我来了个恢复失败，自动回退，也是有够倒霉（或者说，一般在这种模式下恢复成功的概率很小？）。重启后直接默认进恢复页面，我想再次恢复，结果过一会直接给你又返回到选择页面去了。\\n\\n噢，天呐，活生生的系统就这么被折腾死了。我忽然又想起来之前安过一个 Ubuntu，结果发现是个坏的。还好，我的手边还有一个有着 Ubuntu 20 的 U 盘，如果没有它，就没有后面的故事了。\\n\\n想办法用 Ubuntu 尝试版制作 Windows 安装 U 盘\\n\\n安装 Ubuntu 的时候，有一个不安装直接尝试的选项（Try without installation），因为我也只是临时使用，所以就试了一下这个模式。用起来也挺顺的，就是表现有些奇怪。因为我蛮久之前下了一些 Windows 的 ISO 到数据盘里（不过 Windows 10 的只有 1809），所以想着能不能把这个 ISO 复制到当前装有 Ubuntu 的 U 盘里，再重启。\\n\\n结果，复制是复制成功了，就是选择 U 盘启动后仍然回到了 Ubuntu，就像我啥都没动一样。又打开了尝试，看了看这个 U 盘的内容，发现之前我复制的东西都消失了，全都恢复成了原样...这是甚么原理？\\n\\n那这么看来，用 Ubuntu 的尝试模式貌似会出现这种奇怪问题，虽然说不出原理，但是关系好像也蛮大的吧？于是我只好安了一份 Ubuntu 到 HDD 上。\\n\\n想办法用 Ubuntu 制作 Windows 安装 U 盘\\n\\n这下好了，Ubuntu 正常安装上了。然而这个时候又出现了一个问题，U 盘变成了 readonly。我很纳闷，但无处表达自己的想法。我本来想把 U 盘先格式化一遍的，结果发现是 readonly。接下来，我又尝试了很多种办法，包括但不仅限于\\n\\n1. 检查 ntfs-3g 等驱动程序是否正常安装\\n\\n因为我的 U 盘先前的格式是 NTFS，对于 Ubuntu 来说有一定的门槛，需要依赖这些玩意。结果经过检查发现这些东西 Ubuntu 都自带有。\\n\\n2. 重新 mount\\n\\n这一步分为几个版本，包括一些我在 StackOverflow 上面找到的。一个是先 umount 再 mount，提示 cannot mount /dev/sdc1 read-write，然后它就自动变成 readonly 了。一个是先 umount，然后通过 hdparm -r0 /dev/sdc1 把 /dev/sdc1 强行设置成 readonly = 0 也就是关掉 readonly 的状态，虽然输出的信息是对的，但是 mount 以后依然提示不行。还有一个，是通过 mount -o remount,rw /media/subilan/data 把挂载点重新挂载成 readwrite，结果很奇怪，那就是所有跟这个挂载点有关的操作都会卡死（比如 cd /media/subilan/data，或者是通过文件管理器进入这个目录，亦或者是用 GParted 打开 /dev/sdc）。\\n\\n显然行不通。\\n\\n最后我反思了一下，也有可能是安装系统安装失败被系统给锁了，这个好像是无解的...所以，U 盘相当于是废了，那我装 Ubuntu 的意义是？\\n\\n想办法用 Ubuntu 制作 Windows 安装介质\\n\\n现在的问题就是，我有系统的 ISO，但是不知道如何从这个 ISO 启动。不过，借助于万能的 Google，我似乎找到了我想要的东西，那就是 WoeUSB（刚开始搜的时候叫 WinUSB，后来发现改名了）。但是根据它的介绍，好像依然是需要 U 盘的哈？然而我是 Google install windows on ubuntu without usb，所以就试了一试。\\n\\n根据它给的介绍，有 device 和 partition 两种模式，我当然是选择后者，虽然不知道它们指的是不是同一样东西。于是我就\\n\\nsudo ./woeusb.bash --partition Windows10_1804.iso /dev/sdb4\\n/dev/sdb4 是我分出来的一个用来装 iso 内容的区\\n\\n然后它就开始进行一系列操作，最后告诉我成功了。挂上 /dev/sdb4，发现里面就是 ISO 的内容。真的能直接从它启动？重启了一下，BIOS 里出现了一个 UEFI OS 的选项，我惊了。打开后，果然是安装程序，于是就在电脑上成功安上了 Windows 10——1804，最后再用易升升级到了 20H2。\\n\\n事后\\n\\n这一切都有那么一点点像是滑坡谬误：无脑打开 HDR——电脑无法显示——无法关闭 HDR——重装系统失败——Ubuntu 里的一系列挫折——WoeUSB 解救——数据全然丢失（不过当时复制了一些重要数据，所以问题不大）。然而它能告诉我的是以后千万不要手贱动这种悬乎的玩意儿了！当然归根结底还是自己菜罢了。\\n\\nQQ截图20210102121937.png\\n\\n现在看到它就感觉是死神在向我招手👋💀","filename":"Terrible-Computer-Accident-Caused-by-HDR","namespace":"post"},{"title":"Vue 前后端分离的正确方式","filecontent":"date: 2021/04/04\\ndesc: 一直用着另一种方法。\\ncate: 路径\\nVue 前后端分离的正确方式\\n\\n在之前我一直在想 Vue 的前后端分离怎么那么麻烦，让人头大。后来才发现原来我是个小丑，实际上特别简单。本文只是用来记录方法，没有科普的意思，可能此刻的你已经知道了这一切。本文中的前后端分离指的是以 Vue 等框架作为前端技术栈，与后端形成分离，通过 XHR 进行交流的粗略概念，并没有深究的必要。\\n\\n先前的方式\\n\\n一般情况下，后端会位于一个单独的目录里面，里面就是各种各样的 .php、.py 等等。要开始使用，就要想办法让前端能够 post 到他们。然而对于 Vue 来说，打开的 dev server 是仅限于 Vue 的，所有的请求都会给 Vue 自己；而对于后端来说，比如 PHP 的 php -S、Python 的 python -m 或者 flask 的 python ./App.py 等，也都只是开的自己的 dev server，这就让开发过程很难访问到后端。每一个 dev server 会占用一个独立的端口，这就让它们彻底独立了。\\n\\n然后，这种确实是从一开始就有解决方式的，那就是借助前端一个叫做代理（这里的代理不是前文的 Proxy）的东西。比如 Vue 里面就是在 vue.config.js 里\\n\\n\\nmodule.exports = {\\n    // ...\\n    proxy: \\"http://127.0.0.1:8081\\"\\n}\\n\\n\\n设置好了以后，按照官方文档的说法，会把一切无法识别的请求（也就是那些跟前端没有关系的请求）代理到这个地址，而这个地址就可以直接指向后端服务器的地址，比如 http://127.0.0.1:5000 等。不过这个地方曾经让我无语过很多次，因为实际上你写成 http://localhost:XXXX、http://localhost:XXXX/、http://127.0.0.1:XXXX、http://127.0.0.1:XXXX/ 的结果，有的时候是不一样的，还会导致一些类似于 ECONNREFUSED 或者无法代理等迷惑问题。PHP 也是，当执行 php -S 时，后面如果跟的是 .（当前目录）也会引起一些莫名其妙的错误，对于 PHP 来说，localhost 和 127.0.0.1 的效果也并不完全相同。这实在是太坑了，可我也没有时间去了解原理，麻烦懂的大佬给我发个邮件讲讲！\\n\\nOK，这是开发阶段，我们解决了，使用起来没有任何问题。然而遇到生产环境就怂了。那么接下来就是一种很 low 的解决方式——子域名。\\n\\n很多时候我觉得没必要这么大费周章开个子域名出来挂给后端，然而我又这样做了，想想都后悔。因为这样首先会再费一张 SSL 证书，其次还会多一个配置文件，然后让整个主机配置都变得臃肿（虽然实际上没有这么严重但让我很不爽）。在解决了司马 CORS 以后就能正常使用了，而这跟直接去 post 另一个属于你自己的网站无异。\\n\\n现在的方式\\n\\n现在我终于知道 .htaccess 能够把我的请求从 Vue 手中解离出来。因为实际上，用子域名就是为了彻底逃脱当前网站里 Vue 对请求的劫持，因为只要开了一个新的站点，那么它就是个全新的根目录，里面的环境也都是全新的了。\\n\\n那么该如何解离呢，请看\\n\\n\\n  RewriteEngine On\\n  RewriteBase /\\n  RewriteCond %{REQUEST_URI} !/api/\\n  RewriteRule ^index\\\\.html$ - [L]\\n  RewriteCond %{REQUEST_FILENAME} !-f\\n  RewriteCond %{REQUEST_FILENAME} !-d\\n  RewriteRule . /index.html [L]\\n\\n\\n哦，原来可以直接在 .htaccess 里面指定一个 RewriteCond 来限制它的重写操作。而且实际上，Vue 对链接的劫持是由 Apache 或 Nginx 帮助完成的，我怎么这么久都没想到呢（啪）！那么在这个地方我们加上的一行 RewriteCond %{REQUEST_URI} !/api/ 意思是不让对 /api 目录的请求进行重写。那么这个时候对我们来说唯一的要求就是要让所有的后端请求都发往这个地址。当然处理方法不止这一种，而这一种是最简洁的。其实也有想过把 *.php 取消重写，但是不知道怎么写，这里的正则都太迷惑了，动不动就是个 500。\\n\\n接下来就只需要把所有的后端文件都装在这个文件夹里，然后在 build 的时候一起放到 dist 里面（因为 dist 是网站根目录，.htaccess 也在里面）就完了。而这也很简单，在 package.json 里面加上这样一句就可。\\n\\n{\\n    //...\\n    \\"scripts\\": {\\n        // ...\\n        \\"build\\": \\"... && cp -r /path/to/api dist\\"\\n    }\\n}\\n`","filename":"The-Clown-Is-Myself","namespace":"post"},{"title":"过去的一切","filecontent":"desc: 如何才能真正掌控自己。\\ndate: 2021/11/27\\ncate: 思想\\n过去的一切\\n\\n不知许久，我失去了对自我情绪的掌控。也许是发自对自己周边环境的厌恶罢，总是感到百无聊赖，做着让自己不能获得任何成就感却又颇有着「前途」的事情。这似乎是我一直以来的心结，是我自熟悉这个世界以后就存在的心结。怎么说呢？是不是因为现实世界的浮躁与对视听的混淆，以至于我渐渐淡忘了对于解开它的强烈需求，直到最后它把我压到喘不过气来。\\n\\n我一直不想要去承认自己比别人独特，比别人高大，这也不是什么三言两语能说的清楚的事情。我也许会说\\n我讨厌这个世界上对个人的价值评定标准：在宏观上，这个人有钱、有权，他就是优越的；放微观来说，这个人踏实、奋斗且有所成就，他就是优越的；等等。\\n\\n然而某个个体是否优秀，对于我来说重要吗？一个人做了什么伟大的事情，就能说明他对我有价值吗？这个社会进步了，就能代表我进步了吗？\\n\\n上面的话，很多人可能看不惯，但这就是我的真实想法。诚然，它不能改变什么，甚至是一种愤世嫉俗的典型表现，但我认为它反映了一定意义上自我的本质。人是群居动物，但绝不能作为人不能孤独的论据。\\n\\n该怎样去定义自私呢？我不懂。但我一直想要为自己的利益而活，而不是为他人的利益而活，同时我不认为我是自私的。说这句话，不代表着我看到了他人受难就不予以关注，因为「怜悯乃是人类的天性」；不代表我不会参加任何公益事业，因为我不是在排斥奉献；不代表我会损害别人的利益来达到自己的利益，因为我是善良的。但是，在生活轨迹上，我却会将其作为生活的主动轮。这样有什么错吗？\\n\\n我不敢说我这种情况不是麻木不仁的，毕竟我在看到非我所在的或所偏爱的任何集体得到广泛关注、取得成功以后并不会发自内心地感到高兴。也许我这样的人放到旧中国里很危险，在现在的舆论场上，也就是我认为我国所特有的长期充斥着一种好比在国家蒙受巨大且真实的苦难之后的积极对抗、积极发展的心理的大众圈里，也是被批驳的对象，但我认为在十分严格（代表着很精准）的逻辑框架下，我的思维逻辑是没有本质性的错误的。\\n\\n对事物的见解，我不想因为许多人认为它是对的而认为它就是对的；不想因为它顺从大多数人的价值取向就认为它是正当的、高尚的，是值得我的崇拜的；不想因为大多数都会走这条路就去走这条路，并且否定其它的道路；更不愿意相信由某些教条式的因素或者不明不白的逻辑所得出的 supposed。总之我渴望自由，我渴望在有些事情上能由自己做决定、说了算——而这决定也绝不是某些人嘴边常挂的所谓「你所奋斗而来的权力」，而是我生而为人本所能掌控，却被这个社会的浮躁所蒙蔽、排斥的权利。\\n\\n焦虑让我伤感，让我感到无比迷茫。让我即使在少有的能够欣赏这个世界上我所喜爱的部分的时候，也能在一瞬间降落到「我什么时候死」、「我会不会猝死」、「癌症潜伏期多久」一类在外界人看来十分夸张和病态的低谷里。对于那些我日常所处的环境中，更是会有干扰我的思绪，例如「我说的话对他有什么样的影响，对我有什么样的影响？」，后来我发现这其实是一种另类的自恋。焦虑让我担心我现在的所有奋斗是否会在将来的某一刻彻底落空，让自己变成完全没有价值的人。\\n\\n这显然是病态的，显然不是正常人所能想出来的东西。在过去的一段时间里，我也因此而饱受烦恼。直到后来我的调整，我才发现，这些担忧的对象其实都是真实存在的（没有人会去担忧不存在或者公认不可能发生的事情），焦虑只是让这一切放大化了。对于明天是否会死这个问题，正常人所想的应该是：寿命还没到那一节，除非被车撞，过马路小心一点就行。哪怕真的死了，也只是一瞬间的事情。而焦虑的人所想的却是：明天被车撞也不是没有可能，自己得癌症也不是没有可能，明天死也不是没有可能——对于「不是没有可能」感到异常的敏感，对事物的思考过于理想化，总是想要让事物能够对外呈现一个绝对化的结果，只要不绝对就会感到不安，是这种思维模式的本质特征。\\n\\n而大多数风凉人所常唠叨的那几句不痛不痒的所谓安慰：「想这么多干什么？这么矫情干什么？你这样会很累的不知道吗？」这与大多数对心理疾病患者所抱有偏见的人的典型表现如出一辙。如果这是你，希望你能够认清这些话语对于长期处于这样心理状态下的人实际上是一种残忍。\\n\\n进行了 D 测试以后，我发现自己在自恋方面的得分比其它方面要高出很多。在查找了相关资料（自恋的表现等，包括维基百科、百度百科和知乎上相关我所认为还算正规的文章）以后发现，自己也挺符合注1。\\n\\n\\n\\n我属于那种不太会在外界刻意表现自己的自恋者，因为也许我先前受到的这方面的负面反馈比较多。我坚信如果我这样会非常不受欢迎，同时我也认可不应该这样做，而应该踏实稳妥，遇到不好的笑笑，遇到好的闭嘴惊艳即可。自恋是自卑的一种表现，因为我长期以来都是沉浸于自己的世界里，导致与现实世界中的人的共同语言很少，甚至思想不处于同一个层级（在这里，我不说是高了还是低了，我也不敢评判；但总之，并不是一个层级的）。孤独的恶性循环，先开始我认为这样很好，但后来不知是因为周围人浮躁注2的影响，还是个人的本性作祟，越来越觉得失落。\\n\\n既然外界并没有太多对我的负面评价，我也很克制自己输出负面情绪（我在外界的表现其实还是很乐观的），我究竟在追求什么呢？这个问题一下子问倒了我。也许就是自恋吧：总是觉得别人做的事情（在我能力范围内的）换自己来做会更好；总是觉得自己在别人心中处于一个偏向于焦点的地位以至于在意别人对自己的评价——但也许自己只是别人心中的路人而已；害怕被看淡，被忽视。我很胆怯，在某种意义上来说是一个好事。我不会去主动这样表达，而往往是自己内部消化。因而，这带来的至少只是我自身的不好感受，而非外界的形象折损。\\n\\n有的时候，我告诉自己这样想没什么问题。譬如，他们写文章，都会写成这个样子：\\n\\n这篇文章是用markdown写的，也就是md。有少部分latex公式的渲染也许会有问题，如果影响观感可以联系christophersubilan@gmail.com（双休日）。\\n\\nip\\n效果\\n\\n这篇文章是用markdown写的，也就是md。有少部分latex公式的渲染也许会有问题，如果影响观感可以联系christophersubilan@gmail.com（双休日）。\\n:::\\n\\n而我只要不是在赶时间或者追求效率的情况下，会写成这个样子\\n\\n这篇文章是用 Markdown 写的。部分 $\\\\mathrm{\\\\LaTeX}$ 公式的渲染也许会有问题，若影响观感可联系 christophersubilan@gmail.com，双休日可答复。\\n\\nip\\n效果\\n\\n这篇文章是用 Markdown 写的。部分 $\\\\mathrm{\\\\LaTeX}$ 公式的渲染也许会有问题，若影响观感可联系 christophersubilan@gmail.com，双休日可答复。\\n:::\\n\\n这也许也是一种强迫症？\\n\\n可以说，我的情绪一直是波动的。就好比是朴树的专辑《我去 2000 年》里的两首歌，一首《妈妈，我...》里的愤世嫉俗，\\n我恶心，在他们的世界，生活是这么旧，让我总不快乐。我活的不耐烦，但是又不想死，他们是真这么硬，就让我撞它，撞得头破血流吧。\\n\\n以及《在希望的田野上》中的宽慰，\\n你的生命它不长，不能用它来悲伤。让该来的来，我们在这里等待。我们就这样唱······\\n\\n我发觉了自己的矛盾：哪怕是在要贬低一个人的时候，似乎存在的另一个人格也在告诉我没有必要，但我的愤怒却又是真真切切发生了的。等等。\\n\\n总之我想要改变，想要摆脱这么久以来自己的纠结。不说多了，就从今天开始吧。\\n\\n注释\\n\\n注 1\\n进行了 D 测试以后，我发现自己在自恋方面的得分比其它方面要高出很多。在查找了相关资料（自恋的表现等，包括维基百科、百度百科和知乎上相关我所认为还算正规的文章）以后发现，自己也挺符合。\\n\\n我对于心理、人格测试的观点，其实还算比较中立。一些乱七八糟的测试我不会做。这个测试的设计有现存 PhD 的参与，我还是随性参与了，并且认为它的结果具有一定的参考价值。\\n我没有那么喜欢给自己贴标签，即没有那么喜欢去刻意搜索一些心理疾病、心境的症状然后往自己身上靠从而获得一种身份的认同。我对自己是否自恋的认定是经过了对资料的参考和深思熟虑的。\\n\\n注 2\\n···孤独的恶性循环，先开始我认为这样很好，但后来不知是因为周围人浮躁的影响，还是个人的本性作祟，越来越觉得失落。\\n\\n不是因为我很喜欢评价他人，而是他们的表现确实过火。例如对于一个很厉害的人所做出的厉害的功绩，他们并没有思考自己的实际能力、情况和生活目标，而是一味的吹捧并传播，我不是很能理解这样做的意义。例如他们对价值的认定过于单一，让我很烦恼，很难从现实生活中获得乐趣，而只能或自给自足，或在网上找事做、找人聊。这些想法也都只产生于心中，从来没有直接或间接地表达给现实中的任何人。\\n","filename":"The-Depression","namespace":"post"},{"title":"体制外的人","filecontent":"date: 2021/12/19\\ndesc: 是孤独也是勇敢的。\\ncate: 思想\\n体制外的人\\nThese walls are kind of funny like that. First you hate them, then you get used to them. Enough time passed, you get so you depend on them. That\'s institutionalizing．\\n\\n这是出自《肖申克的救赎》的很著名的一段话，译文是\\n这些墙很奇怪，起初你讨厌它，然后你开始适应它；时候够了，你就变得十分依赖于它了。这就叫做 「体制化」。\\n\\n要理解这个体制化的含义，首先要明白什么是体制，以及体制化对于我们而言的意义是什么，给我们带来的是好处还是坏处。在这篇文章里，我会结合我的现实感触和思考来解答这些问题。\\n\\n首先，体制本意是规则（还有其它含义，与本文无关），一套规范。从体制化（institutionalizing）这个词语来理解，其相较于一般的规则化（normalization）多了一种人为的组织和结构，也正因此它指的是一种人为的、固有的规则。\\n\\n回到上面那段话中。那段话描述的实际上是在监狱里生活从生疏到适应的过程。监狱的生活与外界的生活很不一致，于是在你进入这个环境的时候你会本能地产生排斥。然而由于在监狱里生活是不可改变的事实，所以随着时间的推移你被迫适应于这样一种环境。直到最后彻底依赖于这种环境并不愿意离开，因为你会认为离开这个环境以后自己就没了存在的意义，这个时候就可以说被体制化了。也正因此，在《肖申克的救赎》末尾，从监狱释放出来的人放弃了自由地活着而选择了自杀。\\n\\n你不能理解他的行为也没关系，毕竟你（大概率）没有坐过牢，我也没有。这是电影对体制化效果的合理阐释，仅此而已。\\n\\n在上面的论述中也不难发现，这个体制化的概念其实不仅限于对监狱生活或者其他「新生活」的适应，而可以适用于任何环境对我们的意识习惯造成的影响。\\n\\n体制化与被环境影响的区别\\n\\n体制化究竟给我们带来了什么？我们必须清楚它与一般的环境影响人有什么区别。\\n\\n环境对人的影响，体现在人在面对环境时，结合自己的主观判断和经验所作出的反应和新的经验的积累。例如你读了一本书，那么这本书带给你的不仅仅是它原本的、朴素的文字内容，而且还有你结合自己过往学识和经历所得来的对自己而言有用处的思考。你对环境的反馈，很明显，思考和行为的主动权在你自己的手上。你既可以不反应，也可以做出自己认为合理，对自己有利的反应。\\n\\n而体制化实际上是一种固化的思维或行动模式的传递，是经由多数人（注意，一定是多数人，否则它的影响力就不至于造成体制化）的认可以后直接传递给你，思考和决定的主动权并不在你的身上。为什么在这里还要强调主动权呢？因为往往体制性的东西在进入你的思想的时候是很难引起你的质疑的（即很多人认为这样的东西是应该无条件接受的），除非你是一个有着强烈批判性思维的人。这也是为什么说批判性思维以及唯物地看待世间万物很重要。\\n\\n所以如果你没有批判性思维，或者持续地处于一种「觉得自己无知，应该被浇灌」而随意接受的状态下，就很容易被这些「群体信仰」所俘获，成为他们的一员，即体制化。\\n\\n我们对体制化的概念可以总结为，体制化是个体的空白思想被原有的、固化的思维或行动模式置换。 在这里，固化是指长期保持不变的。固化的事物往往都有其固化的原因。个人认为，在唯物领域内，唯有客观真理具有固化的合理性，而思想范畴内的固化大抵都是体制化。任何经过严格证明和检验的科学知识、客观定律的传递都不能叫做体制化。\\n\\n体制化会给我们带来坏处吗？\\n\\n不一定。因为被体制化（institutionalized）是一种十分普遍的现象，许多人一生所信奉的观点也都是体制性的，但这丝毫不影响他们的生活，只是面对有些话题和选择显得无知了点，寂寞了点，以至于莽撞了点，暴力了点。\\n\\n体制化所带来的最为轻微的影响，是人与人思想的不相容。一个具有强烈批判性思维的人，能够接受哪怕最为荒诞不经、经不起推敲的理论进入他的脑海，被他的逻辑一步步推敲，只是路径长短的区别。而它的逻辑都是基于客观世界的。被体制化的一个很大的特点便是它存在着一种无形的束缚，将人的思想和行为约束在一定的范围内。这一范围可大可小，但是很难跳脱。有些人的所谓底线也是从这里来的，但实际上这并不是真正的「底线」所应有的概念，而更像是一种由体制化信息和自我认知所杂糅、发酵的动态产物。\\n\\n如何判断自己是否被体制化？你可以思考以下几个问题：\\n你是否认为某些问题不需要有答案，某些行为不需要理由？\\n你是否经常排斥其它的观念？在这里，经常不指时间，而是「见一次排斥一次」的意思。\\n你是否经常将不是自己思考的结果作为对重要结论的唯一或者权威论据？\\n等等。\\n\\n其实是否被体制化很好判断，只要理解了概念。比如，通过概念和推理可以知道，被高度体制化的人会满口空话（这是因为大多数不是经过自己思考的内容）、盲目自大（这是因为自认为自己的认知体系十分丰富与满足），总是有着某种怪异的信仰与执着（与前一个原因类似，自己该做的与不该做的事情之间的界限不是由自己划定的）和飘忽不定的底线（见上文），等等。\\n\\narning\\n注意\\n\\n我们在当今社会能够正常地、自由地活动的前提是遵循法律和社会规则与道德，这在某种程度上而言也算是一种体制化，然而它并不是本文的叙述对象，因为法律、规则等实际上是一种人为规定的、与上文提到的客观真理等具有类似的性质的存在。\\n:::\\n\\n体制外的人\\n\\n这里的体制不指任何政治含义。\\n\\n要想要以最理性的方式看待这个世界，就需要成为体制外的人（不是规则外的人）。对于这样做的意义，对不同人也不尽相同。你可能认为自己当前的思想观念和意识形态具有足够的完备性，没有必要对其进行批判或者质疑，那么顺其自然其实也是一个不错的选择。只是理性地看待这个世界能够便于我们以更长远的眼光和更大的深度来看待事物和对事物发表评价，也就是能把事看得更透，更懂，而不是吹吹牛唠唠嗑就结束。这样做，又有利于我们长期的自我学习和完善。\\n\\n正如上文所说，体制内的人往往意识不到自己内心的真实状态，有的时候甚至不知道自己究竟想要做什么。所以，体制外与体制内的人很容易产生冲突，比如指点对方故作清高，有时牵涉到与文化传统或者民族信仰等内容的话题时，也会引出一系列与思想正确性和历史有关的「有关痛痒」的议题。究竟谁对谁错，孰优孰劣？想必这并不是一个有价值的问题，因为前文已经说过，是否被体制化对于不同人的意义不一样，自然不能对其进行这样的对比。\\n\\n要知道，我们存活在这个世界上，本质上是为了自己。你无法反驳这一点，因为这是生物的本能。如果你十分坚定地认为，自己一定要为了他人而去死，而去牺牲自己的利益，这也与「为了自己」不冲突，因为你只是在做自己想做的事情，并且你会一直努力去达到这一点。「为了自己」与「为了自己的利益」不能一概而论。\\n\\n那么既然是为了自己，对自己价值和思想境界理应达到的高度的衡量，自然也要以对自己有利为准绳，而不是日夜操持着「观念不正」云云，借由自己对自己脑海中存在的体制性思想的不完全认知去批判那些自己根本一点也不了解的人。\\n\\n体制外的人总是能够接受与它截然不同的观点的。经常有一句话会说，一个人在知识和思想并不成熟之时往往会很狭隘，因为没见过世面，没见过与其相反的观点。在这里我们可以说，这个所谓的「知识和思想的成熟」，其实就是跳脱于自己当前所在的体制，而去做一个体制外的人。\\n","filename":"The-Institutionalization","namespace":"post"},{"title":"过度解读","filecontent":"date: 2021/07/30\\ndesc: 即使是这样，观点也应该被尊重。\\ncate: 思想\\n过度解读\\n\\n过度解读也许是人间最为普遍的演绎形式，许多人愿意用感性的视野来看待自己与自己周遭的事物。也许并不是所有人都认同解构主义之言「诠释无边界」，但过度解读却依然普遍地存在着，丝毫不受任何思想的干扰。而这样的一种存在，虽普遍认同，但依然有可能矛盾重重。\\n\\n王国维在《人间词话》中讲「以我观物，物皆著我色彩」，体现了感性认知的基本特征。很多人在不断成长的过程中都能够领悟到，自己心情好的时候，几乎什么都是好的；心情不好的时候，几乎什么都是不好的。唯独绝对的事物能够在不同的情绪空间中保持其本身的绝对性，但我们的生活中，恐怕除了某些教条和法律，没有什么是绝对的，因而感性认知是普遍存在的。\\n\\n但，上述只是一种普遍情况。其实，我们在无论什么心情下，都会解读出只发源于自己所认为正确的一方面的观点，这也是感性认知的特点。并不是说，因为我的心态平和，或者心态暴躁，就会解读出截然相反的结论。人在不同情况下对事物的理解方式不一样，这是因为人在思考时不仅要考虑事物本身，还要考虑与事物牵涉到的人和其它事情。因而，感情不同，态度不一样，解读出的东西就不一样，也并不是绝对的。\\n\\n但是事实就是事实，对于一个确定的事实，如果解读出了不同于其本身的结论，就会被认定为是错误的（incorrect）。错误这个词语是完全否定的意思，否定了你的观点和你的思想，是不可以被他人所接受的。但是在这个错误认定途中，却有很多人放弃了感性背后的理性，开始了诡辩。例如，$1+1=2$，这是 100% 的真理。\\n\\n有的人会说：「也许，在另一个计算系统中，这个式子并不成立，你怎么可以说它是 100% 真理呢？」\\n有的人会说：「你如何证明它？任何不能被证明的，都不可以被认为是真理。」\\n\\n等等。你甚至有可能此时此刻就觉得它们有道理，这也更加说明了我们在写议论文时为自己假想一个论敌的重要性。其实有很多人都不喜欢去肯定别人的观点，认为自己的肯定是十分值钱的东西，认为自己肯定太多会显得「太过于随意」，但实际上自己根本没有达到这个水准。\\n\\n第一条只是为了证明自己是对的而证明，很明显属于诡辩的范畴。 说话者本身有可能根本不了解「另一个计算系统」到底意味着什么，但就是不愿意承认这是 100% 真理。这句话严格说来并没有错误，我们可以定义「$1+1=?$」，但是他忽略了本次对话的一个前提：我们承认了 $1+1=2$。我们为什么要承认它？因为这是当今世界上的最普遍的公理。难道因为它最普遍就认为是 100% 对的吗？是的。首先要明确我们承认一样东西是正确的（correct） 的原因是什么。\\n\\n为什么 $1+1\\\\neq3$？因为人类没有让他等于 $3$ 的需求。人类创造出当今的四则运算，就是为了去解决一些实际的问题。为什么一个苹果和一个苹果放到一起就变成三个苹果了？为什么要规定 $1+1=3$？当这样做显得十分多余而没有必要时，我们就把唯一满足我们需求的情况称为是正确的、标准的。因而这个「计算系统」，本质上只是一个被捏造出来看似有力的论证手段而已。\\n\\n第二条则属于自我封闭类型。Amish 不愿意接受科学，本质原因也有可能是这样的。如果一个人坚决抵抗被说服，那么实际上你是说服不了它的。《谏太宗十思书》中道：「虽董之以严刑，振之以威怒，终苟免而不怀仁，貌恭而不心服」。人的内心不服气实际上是无法解决的，因而这样的人几乎是无法被说服的。是啊，$1+1=2$ 怎么被证明？你只能说，这是规定。在这之后，他们大概依然会选择不相信，或者转变为第一种人。\\n\\n沟通\\n\\n沟通的根本目的是传达，传达的过程中必定有信息的折损。沟通分为沟通者、沟通对象以及沟通信息。\\n\\n沟通者与沟通对象\\n\\n初中物理知识告诉我们，如果要阻止声音的传播，可以从三个地方下手——声源、传播途径、接收方。放到人身上就是嘴、耳、脑。也许这个传播途径的概念对应到「耳」上有些奇怪，但实际上是有理由的。\\n\\n闭上嘴是最为简单的防止沟通的方式，因为沟通已经被终结，信息不存在，声音不存在。耳实际上是传播途径，因为声音需要先进入耳朵，才能被大脑解读。如果我们堵上耳朵（由于受迫振动其实根本没用），那么就听不见声音。信息依然存在，但是我们对其一无所知。\\n\\n而对于接收方的脑，我们是没有办法采取任何行动的。这就说明，如果不能在信息的产生和传递这两个环节中进行处理，那么信息一定会被我们解读。至于观点是否会形成，这是解读以后的事情了。这与初中物理知识不一样，初中物理知识认为，要排除噪声，可以避免噪声出现（禁止鸣笛）、防止噪声传播（隔音墙）、防止噪声被接收（堵住耳朵）——这是因为噪声是不存在信息的，堵塞噪声仅以「传不到耳朵里」为目标。\\n\\n有的人既闭上了嘴，又堵上了耳朵，信息无法从他这里发出，也无法进入他的脑子里。他既不发生信息，也不接受信息，属于信息绝对绝缘体。日常生活中这样的人其实特别少见，许多人看似是闭塞，但依然能够在某些方面表现出兴致，他们对自己不感兴趣的事情保持高度的不闻不问，对感兴趣的事情却可以发表很多观点和见解。也许对于他们来说，「不感兴趣的事情就是（至少对自己来说）没有意义的事情」？\\n\\n有的人有的时候闭嘴，有的时候堵上耳朵，信息既可以发出，又可以进入，但是有的时候却不可以。这样的人很容易输出一些错误观点或者片面认知，却在当今互联网上十分常见。例如 Siri 播报奥运会金牌数目时，只播了日本前面一个国家的金牌数，然后跳过了日本，进入到了下一个——这个信息无法进入；播报中国前面一个国家的金牌数，然后跳过了中国，进入到了下一个——这个信息可以进入——「苹果怎么这副德行」？\\n\\n有的人随时随地都是闭嘴的，很难听他说出一句观点，但是他又好像都听进去了。他只吸入信息，而不发出信息。一般和这样的人对话是比较费劲的，很有可能得到你预想不到的结果。例如，如果你说「今天发生了一件很 awful 的事情，我来说说......」，他的回复是「那也是没办法」。\\n\\n有的人随时随地都是堵上耳朵的，但是依然可以表达出很多观点。他只发出信息，而不接收信息。一般和这样的人对话，如果他并不厉害，那么是没有意义的，因为他的所有的话都是由他自己所创造。而那些厉害的人闭塞双耳所创造的信息，依然在许多人的眼中有很大的价值，在这里不能全部否定。\\n\\n以上归纳了几种对待信息有着不同态度的人，它们所参与的沟通中，往往会产生不一样的效果。请注意：尽管有些类型是不好的，但没有贬低的意思。在这些人之间有无数个过渡态，基本上所有的人都可以对应到某一个过渡态上。\\n\\n沟通信息\\n\\n声音只要传播，就一定存在声源、传播途径。在沟通中，信息也是如此。如果信息在这两个过程中出现了问题，那么信息将会发生折损，但永远不会消失。而折损是误解的根本来源，因此折损是有必要被避免的。对于任何信息的传达，信息的折损 是影响准确性的最大因素。\\n\\n信息源是发出信息的对象，信息的折损从这里就已经开始。对于人来说，信息最初形成于大脑，大脑需要控制手用键盘/笔把信息打/写出来，或者控制嘴说出来，本质上是将信息转化为人类语言的过程。在这个转化的过程中，会出现不同程度的折损，这取决于\\n\\n大脑信息表达的能力。** 如果信息表达能力太差，可能导致写出来的句子完全无法被正确理解。\\n大脑对信息的解读方式。* 如果信息被大脑错误解读，即使在大脑中形成时是正确的，写出来就有可能出现人为的偏差。正如开头所说，情绪是会影响解读的。例如，如果我想表达「这个问题好棘手」，如果解读方式发生改变，就有可能变成「真是操了这个问题真他妈棘手捂嘴笑*」。解读方式不会导致大意的改变，却可以导致传达的改变。\\n语言的本身特性或者大脑对语言的习性。** 如果语言本身无法准确表达事物，那么信息将会受到严重折损。因为人类沟通的前提就是语言，如果没有语言或者语言不匹配，那么沟通不存在。例如，如果你想要表达「我很热」，用英语会说出「I\'m hot」的句子，这固然没有什么问题。但是对于大脑对语言习性偏弱的人来说，这句话就有可能被他解读为不合适，因为你这是在说自己很骚。其实并不是，热天里不会有人对一个不是伴侣的人凭空这样以为。\\n\\n这三个因素因人而异，因此会出现不同样程度的折损。但是一般情况下，在这一环节发生的折损很小。当然，愤怒的时候除外。因而我们会认为「冲动是魔鬼」，或者说「不要把发火的人的话太当真」，因为在这种情况下，我们在信息产生的时候产生的折损就非常的大。\\n\\n传播途径是信息传播的介质，但并不仅仅是介质，还有沟通对象的解读方式。这就是「双方理解」的概念所在。解读方式大致的影响因素有\\n\\n大脑对信息的接收程度。* 如果接收程度太低，就会发生对牛弹琴的情况。而接收程度与一个人的性格有关（常量），同样也与当时的心情有关（变量）。太过于自大的人，对信息接收程度很低，如果太低，就会变成信息源头*；十分在意他人感受的人，对信息接收程度很高，在这里的折损就会被降得很低。\\n大脑对信息的固有理解。** 固有理解是大脑可以利用的现成的针对当前信息的其它信息，例如恐同的人在遇到同性恋话题的时候一般会选择忽略观点，直接发表自己的观点，在这个时候对信息的接收率为 0。需要注意的是，如果固有理解是错误的，会大大降低大脑对正确信息的辨析能力，导致得出一些不应该得出的结论。这是信息折损程度最大的情况，信息有可能根本无法被深刻理解就被拒绝。但是固有理解却是十分重要的，有助于我们针对一些日常可见的事物做出正确且快速的反应。\\n大脑对信息的接受程度。** 这是因人而异的，不同人的喜好不同，就会产生不一样的接受程度，从而对一些触及阈值的事物产生不同于他人的解读。该接受程度会直接影响固有理解的形成。\\n大脑对语言的解读。** 如果语言出现了一些触及阈值的内容，或者表达不准确，或者接收者本身对语言的掌握程度有限，都会直接导致折损。\\n\\n以上因素并不完整，还有很多会影响到折损的因素没有列出。折损会导致信息变得不准确。但是对于一些普遍认知的公理以及日常的聊天，折损并不会非常大。但是对于一些触及观点的议题，折损将会出现比较深刻的影响。如果一个人无法降低自己的折损，那么他的话久而久之会从准确变为不准确，他对事物的理解方式也会越来越偏向主观。\\n\\n过度解读\\n\\n过度解读是否有意义，是存在争议的。但我认为，只要解读本身的论证逻辑没有出现问题，那么这个解读就是可以接受的。除开那些很准确的传达，一些并不那么准确的传达在不同的人眼中就会出现明显的差异。同时，如果隐晦的传达变得普遍了起来，那么几乎所有的句子都可以被过度解读，因而谜语人会让人感到疑惑，因为合理的解读太多了。\\n\\n过度解读之所以过度，是因为其脱离了句子想要直接传达的「本意」，而去引申出其它的意思。这个引申的过程如果合乎逻辑，那么这个引申出的其它意思一般也并不会有太多存在性的问题，也就是说，如果对于一种传达有多个不一样的解读，这些解读的引出逻辑也并没有太大的问题，那么这些解读都是可以共同存在的，即使它并不是作者本身或者说话人本身想要表达的意思。为了避免自己说话产生多义性，就需要注意措辞，这看起来很麻烦，但是实际上作为沟通的艺术，许多人在踏入社会以后都会慢慢掌握。\\n\\n过度解读存在如此之普遍，为什么还会有人被因此冠以「过度解读狂」的罪名呢？因为许多人认为「自己的话」只属于自己，解释权也仅仅在于自己；如果他人的理解不正确，自己有权利纠正并驳斥这种理解。事实并非如此，每个人都有权利对一样事物根据自己的认知作出不一样的评判，尤其体现在艺术和文学作品上，日常对话也是这样。对于这些情况，我们习惯称其为「误解」，我们需要耐心地去解释，而不是认为对方是纯粹无知——至少对方并没有抱着讽刺的态度，或者说攻击性的态度来，因而如果不耐心地对待，就显得是自己不够厚道了。在朋友之间，经过几次纠正以后，这样的默契会很快形成，但是如果环境过于多变，也许也会出现一些特殊的情况，这就需要从自己的身上改变。\\n\\n如果自己不愿意改变，他人也学不会正确理解你的观点，你的观点没有正确地传达，他人无法理解你令你不爽，他人感到疑惑不解，甚至对你产生责备——这就是过度解读的危害。","filename":"The-Overinterpretation","namespace":"post"},{"title":"对 Minecraft 服务器的一些想法","filecontent":"desc: 回顾虚无缥缈的从前。\\ndate: 2021/02/17\\ncate: 思想\\n对 Minecraft 服务器的一些想法\\n\\n这是一篇略带有回忆性的文章。我想要整理一下从自己开始接触 Minecraft 的时候，自己身边的一切的变化。以及当今我对 Minecraft 服务器的一些想法。这只是一篇随笔文章，用来记叙我一瞬而过的简单想法，也许对于未来的我来说，会略显幼稚。\\n\\n回忆\\n\\n初识\\n\\n想起自己最初接触 Minecraft，是在 2013 年的新年。我的侄子（没错）向我推荐了这款游戏。他当时向我转述的时候，把它叫做「我的世界」，最初的我对这个名字感到诧异，后来也觉得挺符合这个游戏的设定的。最初我玩的是 Minecraft PE 0.8.1。\\n\\n那么，究竟是什么让我对这个游戏产生了非常深的印象呢？当时的 MCPE 生成的世界是有限的。我随便输了一个种子，就是 -1，然后创建了一个世界。连我自己都没想到自己会像着了魔一样在这个世界里面玩了一整年，把整个世界都给建满了。建的都是一些我觉得莫名其妙的建筑，因为当时根本不知道这个东西是可以搭出真正美丽的建筑的。甚至连一些方块也不会用：比如，我凭直觉认为地板需要用木板，但是我翻创造模式背包看到的第一个不是 plank，而是书架（说实话我当时可能根本都不知道那是个书架，因为这一切对于那个时候的我来说还是太过于抽象了点）。我觉得书架的顶部也是木质的，于是就把它当地板在铺。由于后来我才意识到应该用 plank，所以对这个的印象特别的深。\\n\\n后来接触到了电脑上的 Minecraft 1.6.4，发现其实世界也可以是无限的，其实物品也有很多（当时 PE 比电脑版的内容要少很多）。我依稀还记得第一次进入游戏连方块都不会放（因为没想到除了左键还有右键操作🤣），还是用百度查的。\\n\\n探索与第一次接触到服务器\\n\\n因为在这之前我根本就不会用网络上的论坛之类的东西，所以基本上算是一个网络萌新。后来才想着可以在贴吧上看看，在百度上某某地方看看。于是接触到了材质包和模组。不过模组并没有很玩，因为实际上我不爱研究游戏里面的这些东西，就算玩也只会粗略的玩。材质包，我记得当时每次安装一次 MC 都要安装上一个叫做「矢量风」blabla 的材质包。后来我仔细查才发现它叫做 Inklination，已经在 1.8 停更了。它有 CurseForge。这大概是 2014 年前后。然后有的时候也会去下一些地图，都是在百度上打开的我现在特别看不起的下载站里面下载的。\\n\\n这也告诉我其实没必要总是看不起这看不起那，因为我至少有一部分是它们所造就的，人生本来就是一个不断提升自己的过程，刻意去鄙视那些自己也接触过的东西就好比是在鄙视自己的过去，很没必要。\\n\\n第一次接触到服务器，也是随着上面的过程而推进的（感觉每一个 Minecraft 玩家都有这么一个经典的过程，一次次蜕变？当然只有小学生一直被困在了某一个阶段）。以前玩过一个叫做「宇恒」的服务器，它有好多条线路，还有一个叫「地球都市」 ，以及现在依然存在的「云隙」。其实在我现在看来它们基本上全是一些恰烂钱的盗版服。以及，我的好不容易圈了地的房子也的确没有保住。\\n\\n直到最后，我滋生了一个想法，自己开服务器怎么样呢？\\n\\n最初是在百度上疯狂找教程，很搞笑对吧。由于我每次抓的关键词就是「如何在家里用自己的电脑开服务器？」在当时并没有很清晰的服务器概念...于是就走了很多歪路，各种鼓捣路由器的设置。现在我还记得两个名词：「端口映射」和「DMZ 主机」。当时一步步照着百度上做，最后依然行不通，屡次绝望过后，终于能进去，欣喜若狂地把 192.168 开头的 IP 发给朋友，朋友连不上。\\n\\n后来看到了一些文章，虽然令我很绝望，但是我终于认清了开服是个怎样的东西。它需要一台时刻不停运转的电脑，当然，这可以是我的电脑，只要我的家里人愿意的话😅。当时上网淘宝上搜，居然也有很多主机商。但最后由于钱实在是不够，都没好意思下单。直到 2016 年，我遇到了一个叫做 NextCraft 的东西（不是打广告，它现在已经停止服务了😔）。\\n\\nNextCraft 时期\\n\\n简单来说，NextCraft 是一个按量计费的 Minecraft 服务器商，提供的是面板服。它有一个虚拟货币，叫做「能量星」。你充钱进去，就可以按照一定的汇率变成能量星。然后你可以自己开一个面板出来，自己定义服务器的 RAM（我现在回想起来一样觉得很棒，它和传统的面板服并不一样，但是后面我们就知道这样做虽然很受欢迎但是却也很悲催），按量计费，当能量星花完了，服务器也停了。\\n\\n当时我加入了 NextCraft 的一些群里，进行了一系列无脑&逗比（哇，最近几年第一次用这个词）发言，瞬间被群管理 Maplex 怒怼。顺便一提，也是他启发我去看《日常》这部番剧的，也正是因为我看了这部剧，很喜欢里面的那只 Sakamoto 于是把它长期用作自己的头像，甚至还用 Procreate 重新描线并上色了一番以示独特性。\\n\\n\\n\\n然后聊着聊着见到了很多「高冷」网友（其实是因为我当时发言过于 low 没有人愿意理罢了，如果我现在面对以前的我我也不想理...），里面就有小邱。还有一些单方面认识的比如思琪姐姐 Angelic47BTW Angelic47 就是 NextCraft 的主要运营者（按照我的理解）。\\n\\n不过后来由于 NextCraft 亏本经营，有一天它就彻底 down 了。官方写了一封声明，然后让用户联系退款，就消失了。我确实觉得这挺悲催，也挺可惜的。\\n\\n可能是出于跟风吧，我看到这些网友们都有自己的博客，我却从来没有想象过这样的东西，于是我也开始写博客。但由于最开始都是一些不痛不痒、莫名其妙的文章，所以它们也没有存在很久。2016 年 10 月 23 日，subilan.win 域名注册，博客开始运行，写些不明所以的文章，然后重置，再写，再重置...最开始用的是 WordPress，到后来换成了他们都在用的 Typecho，和 Markdown 结下了孽缘，再后来又换成 WordPress，再后来又换成 Typecho，直到最后一次换成 Typecho 后的一次服务商的数据丢失（2019 年），我换成了 VuePress，定下了博客的永久样貌。\\n\\n开服的念头依然没有停止\\n\\n使用 NextCraft 期间，其实自己也没有开过什么正经的服务器。无非就是叫上几个网友，鼓捣鼓捣自己也不怎么懂的插件，然后开服，玩个几个小时，彻底没人，关服。这对于当时的我来说，还是有那么一点意思的。\\n\\n后来，NextCraft 关闭，我也不再愿意去找其它的开服方式了，因为真的很累。不过由于 NextCraft 群里关系依然存在，我和一个叫做晨风的网友运营着一个服务器（Landlife），不过到最后依然是因为资金紧缺，几近失败。直到 2018 年的时候，一封邮件发到了我的 Gmail 里，是一声问候。他说他是通过我的博客（当时的博客，真的跟现在的不大一样...）看到我的，他是某服的 OP，想要和我的网站和 Landlife 的网站（用 Dw 做的，嘻嘻）交换友链。我当时就在想，自己这么 low，开着这么 low 的服务器，居然还有人看得上...瞬间感觉到特别的满意和开心，一下子答应了。这个人，叫 Sapherise。不过因为他的博客已经 down 了，无法与我们继续互动，所以我这里就不链接他了😅。他一直声称会重启博客，虽然但是，到现在也没有重启。\\n\\n他当时所在的服务器叫做 S\\\\\\\\\\\\\\\\\\\\*e，是一个很高大上的国际服务器，他恰好是中国区域的 OP，并且负责着服务器官网内容的编写。说来也是奇幻，我到现在都没有了解到这个服务器内部的一丝一毫，可这是我刚刚与他沟通时的最大谜题。\\n\\n某一天，SoTap 出现了\\n\\nSapherise 在当时正在经历奇妙高考，边高考边当着 SEATiDE 的 OP。等了一年以后，2019 年的某一天，他告诉我要开一个新服 SoTap。于是我加入了，后面的故事，不多谈！\\n\\n转眼间，SoTap 已经快要两个年头了，我却突然开始质疑起 Minecraft 服务器的意义。下面是正文部分。\\n\\n对 Minecraft 服务器的一些想法\\n\\n自我问答\\n\\n说实话，我到现在都没有弄清楚自己最初是为什么要开 Minecraft 服务器。曾经问过自己两个问题：\\n\\n难道这是为了满足自己的 XX 欲，比如，「控制玩家的欲望」？享受当 OP 的感觉？ 我认为并不是的。如果这样认为，难免过于幼稚。我可以说我过去的确是有过这样想，但后来发现，其实 OP 要做的事情有很多，并不是天天耍指令玩，也不是在别的玩家好好生存的时候自己一个人玩创造走来走去，因为这样其实也很无聊。\\n\\n难道这是为了让自己能够有一个奋斗的目标，更有成就感？ 如果这样说，这其实就是无中生有的成就感。本身服务器这个东西是不存在的，偏要「自己找事做」，到头来累得不行，成就感也就那么一丝丝。果真如此吗？我看不见得。我认为，最初应当是因为兴趣而起身的，到后来越来越离不开这个东西了——因为有那么一种无形的责任，认为自己要打造一个良好的社区，要让玩家有一个良好的环境，也许这才是我们目前成就感的真正来源吧。\\n\\n倘若我连自己干这件事情的目的都不知道，我却依然在津津有味地干，是不是显得有些莫名其妙？最终，我终于给了自己一个勉强的答案：我热爱这个游戏，是这份热爱让我有开服务器的热情和勇气。 没错，每天那么努力，完全就是因为这份热爱。至于每次被玩家给予高度评价时候的成就感，只是在这个「迷恋」的过程中，顺便获得的一个东西罢了。\\n\\nMinecraft 服务器，一个萦绕我心田接近 6 年时间的东西，让我如此的着迷，以至于要让自己现实的工作慢下来，主动去消耗时间在这上面，这不是热爱，就是有病。我当然只能选择前者。\\n\\n对大服的一些思考\\n\\n那些所谓大服，初期都是怎么做大的？他们要么有过硬的本领，要么有优秀的运营团队，要么有无脑的大股东，要么有数不清的主播，要么有执着的玩家。而这些，SoTap 都没有，我也没有。这些东西从何处而来？也许是机遇，也许是人脉，反正不是什么努力能得到的东西，这也是我目前所坚信的观点之一。\\n\\nMinecraft 圈子早已没有我曾经想象中的那么狭小：随意开一个服务器，投入点心血进去，很快便能收到回报。这是一个服务器市场极度膨胀的时代，成本高昂，玩家稀少，回报更是让人愁得不得了，没有一点靠山，实际上很难存活下来。说到底，这便是弱肉强食——我有钱，我有人，我便可以秒杀你，我便可以锤爆你。所有的主播都会看上我，都会来我这里玩；所有的玩家都会崇拜我们，都想要成为我们的一员。而没有钱，没有人，就永远没有钱，没有人。良性循环和恶性循环，已经因为两极分化而界定得非常之清楚了。\\n\\n至于这两者之间怎样变换，我认为，就是钱。有钱可以\\n请来主播，请来流量，请来玩家\\n请来 i9-9900KS，请来 Ryzen 9 3950X，高枕无忧\\n请来管理，请来运营，请来安逸\\n\\n基本上，Minecraft 服务器，是一个发展起来只要有钱就来钱特别快的产业，因为无论怎么说，它只是一个简单的游戏。恰烂钱也好，总之就是收获了他人的财物，自己也收获了喜悦。\\n\\n但是我们通常都不愿意这么做，这就需要我们稍稍正规一点。但按照正规的路子，如果我们又没有人脉，那事情也会变得很难办。为什么有的人能够天天不嫌事多地在这群那群里炫耀自己服务器「70 人，TPS 20」，而有的人，服务器月付一千八，却在线 10 人 TPS 跌到 5？卷，疯狂地卷。\\n\\n普通的兴趣爱好者，很少有概率会单纯因为自己的努力而将服务器完全做好；多多少少都应该掺有水分，或不自量力，以至于勾当。Minecraft 圈已经不像想象中的那样单纯和简单，而是成熟且复杂。不少人开始唱衰，说这个游戏迟早是要完蛋的，这是不可否认的，因为它已经走过了快 12 个年头了，比某些玩家的年龄还要大。可，它真的在走下坡路吗？不见得。\\n\\n未来的路\\n\\n我的爱好，当然是不可放弃，更不可抛弃的。但我认为，并没有必要再这样子拼命，以至于把自己的现实也几近搭上了。Minecraft 是款好游戏，承载着我这么多年的努力和艰辛，懵懂之间的探索与欢乐，以及近些年的快乐且丰富的经历，我当然不可能忘记；但是我认为，确实应当为连目的都不知道是什么的事情画上一个句号了，继续下去只会让自己更加迷茫和不知所措。\\n\\n服务器依然可以开，但不会再那么倾入心力，或大胆想象，认为「啥都可以干」。不，有些事情，没有几把刷子，干不了。我只能慢慢地提高自己，让自己变得更优秀，这样才能够避免被「卷」入僵局，不是吗？","filename":"Thoughts-About-Minecraft-Server","namespace":"post"},{"title":"常用 CRUD 前后端架构","filecontent":"date: 2023/01/26\\ncate: 代码\\ndesc: C！R！U！D！\\n常用 CRUD 前后端架构\\n\\n在写一些自用的小程序（not wechat mini-programs）或者搭建一个简易的前后台关系时，通常都要进行以下几点的设计\\n\\n前后端请求—返回数据的约定\\n数据库的调用\\n登录认证\\n分页\\n\\n显然这些设计可以被模式化和模板化，从而提高创建它们的效率。\\n\\n而不将它们完全作为模板，是因为在这之间还存在着相当大的需求变量；代码层面上，在此基础上可以进行其它扩充。例如对于即使更新的需求，可以加入 websocket 等模块（虽然大多数情况下为了省事，我选择 CRUD 轮询）；以及为了安全性可以进行更多修改和优化，等等。\\n\\n下面以 TypeScript 和 Python 举例，其它语言同理。\\n\\n请求—返回数据的约定\\n\\n首先，我们在后端使用统一的函数进行返回。例如\\n\\ndef response(status, data, msg):\\n    return {\\n        \'data\': data,\\n        \'status\': status,\\n        \'msg\': msg\\n    }\\n\\ndata = { ... }\\nmessage = \'An error occurred.\'\\n\\nresponse(status=\'ok\', data=data)\\nresponse(status=\'error\', msg=message)\\n\\n利用 axios，可以方便地处理返回数据的类型。\\n\\n// axios 默认返回中，data 才是后端来的数据。\\naxios.interceptors.response.use(\\n    response => {\\n        return response.data\\n    },\\n    err => Promise.reject(err)\\n)\\n\\n// ...\\n\\ninterface ReponseType = {\\n    data: any, // 可调整\\n    status: string,\\n    msg: string\\n}\\n\\nexport function post(url: string, data: any) {\\n    return axios.post(url, data, {\\n        headers: {\\n            // 可用于添加 Authorization\\n        }\\n    })\\n}\\n\\nResponseType 即为返回值的骨架类型，可以放在 axios.post 和 axios.get 两个函数的第二个泛型参数上指定返回值（即在 interceptor 里拦截到的 response.data）的类型。\\n\\n这样在请求时大致就是如下的情形了：\\n\\npost(\'/abc\', {\\n    abc: \'def\'\\n}).then(r => {\\n    if (r.status === \'ok\') {\\n        // ...\\n    }\\n})\\n\\n数据库的调用\\n\\n数据的调用，在 Python 里通常使用 pymysql 库。\\n\\nfrom pymysql import connect, cursors\\n\\ndef connect():\\n    return connect(host=\'localhost\', user=\'abc\', password=\'def\', database=\'target_db\', cursorclass=cursors.DictCursor)\\n\\n注意到 cursorclass 在这里是一个很重要的参数。在 PHP 的 mysqli 中，通常是通过指定 mysqli::fetch_all 的第一个参数 int $mode 来实现的。这里的 cursors.DictCursor 对应 MYSQLI_ASSOC。\\n\\n$mysqli = new mysqli(\'localhost\', \'abc\', \'def\', \'target_db\')\\n\\n$result = $mysqli->query(\\"SELECT ...\\")\\n\\n$rows = $result->fetch_all(MYSQLI_ASSOC)\\n\\n然后对于内容的取得就是如同上面 php 代码里所示的司空见惯的逻辑。\\n\\nwith connect() as conn:\\n    with conn.cursor() as cur:\\n        cur.execute(conn.escape_string(\'SELECT ...\'))\\n        return cur.fetchall()\\n或者\\n    conn.commit()\\n\\n登录认证\\n\\n登录认证的设计流程已经在这里有概述。本文所展示的是使用 jwt 库所实现的 Python 版本。\\n\\nfrom jwt import encode, decode, DecodeError\\n\\ndef getToken(argument1, argument2):\\n    payload = {\\n        \'iat\': datetime.now(),\\n        \'exp\': datetime.now() + timedelta(days=5.0), # 可调整\\n        \'argument1\': argument1,\\n        \'argument2\': argument2\\n    }\\n    return encode(payload, \'secret\', \'HS256\')\\n\\ndef verifyToken(jwt):\\n    if jwt == None:\\n        return False\\n    try:\\n        decoded = decode(jwt, \'secret\', [\'HS256\'])\\n    except DecodeError as e:\\n        return False\\n    if decoded[\'exp\'] > int(datetime.now().timestamp()):\\n        return True\\n    return False\\n\\ndef decodeToken(jwt):\\n    if not verify(jwt):\\n        return None\\n    assert jwt != None # verify 函数确保 jwt 不是 None\\n    return decode(jwt, \'secret\', [\'HS256\'])\\n\\n然后在前端以一种安全的方式提交给后端即可，例如使用 Authorization Header。\\n\\nexport function post(/* ...*/token: string) {\\n    axios.post(/* ... */, {\\n        headers: {\\n            Authorization: JWT ${token}\\n        }\\n    })\\n}\\n\\n后端在验证时，可以使用函数包装，将目标函数添加相应的检测流程。\\n\\nfrom functools import wraps\\nfrom flask import request\\n\\ndef protected(func):\\n    @wraps(func) # 必须\\n    def decorated():\\n        auth = request.headers.get(\\"Authorization\\")\\n        if auth == None:\\n            return response(status=\'invalid\')\\n        token = auth.split(\\"JWT \\")\\n        if len(token != 2):\\n            return response(status=\'invalid\')\\n        tokenStr = token[1]\\n        if verifyToken(tokenStr):\\n            return func()\\n        else:\\n            return response(status=\'invalid\')\\n    return decorated\\n\\n@app.route(...)\\n@protected\\ndef api():\\n...\\n    return # ...\\n\\n分页\\n\\n要完成分页，首先需要给数据增添数字标识，从而使得数据有序且顺序可比。这一点通常通过一个名为 id 的 key column 实现。\\n\\nCREATE TABLE example (\\n    id INT UNSIGNED KEY NOT NULL AUTO_INCREMENT\\n)\\n\\n分页时，需要考虑到\\n\\n每页数据的数目 — 对应 SQL 中的 LIMIT\\n数据的排列顺序 — 对应 SQL 中的 ORDER BY\\n\\n且前端分页通常需要后端对下一页数据的预测数据的辅助。\\n\\n例如我们简单地选取表中最开始的 10 个升序排列的行。\\n\\nSELECT * FROM table WHERE id >= 1 ORDER BY id ASC LIMIT 10;\\n或者\\nSELECT * FROM table WHERE id > 0 ORDER BY id ASC LIMIT 10;\\n\\n这可以作为第一页的内容。此时符合条件的行应当是 id 从 1 到 10 的所有行（没有 id 缺省的情况下）。接下来选择第二页的内容，即为\\n\\nSELECT * FROM table WHERE id >= 11 ORDER BY id ASC LIMIT 10;\\n或者\\nSELECT * FROM table WHERE id > 10 ORDER BY id ASC LIMIT 10;\\n\\n然而在这里，大于号后面所跟的内容并不一定是 10 或者 11，因为可能中途有 id 的缺省。所以，这时候需要前端指定当前页面的最后一个数据的 id 提交给后端。我们将其称为 indicatorId。\\n\\n于是更加准确的 SQL 应当写作\\n\\nSELECT * FROM table WHERE id > indicatorId ORDER BY id ASC LIMIT 10;\\n\\nPython 语句示例：\\n\\nindicatorId = request.args.get(\'indicator\', 0)\\npageSize = request.args.get(\'pageSize\', 10)\\nsql = \\"SELECT * FROM table WHERE id > {0} ORDER BY id ASC LIMIT {1}\\".format(indicatorId, pageSize)\\n\\n注意这里应当使用 > 而不是 >=。若要使用后者，则需要多一个 +1 的步骤。\\n\\n同时，后端需要返回前端一个「是否有下一页」的信息，可让前端判断是否需要展示「下一页」的按钮。这一点在下滑加载（即滑到数据底部后，在底部添加上新的数据）的场景中比较适用。\\n\\n判断是否有下一页，在升序中，只需要判断 indicatorId 是否就是表最后一行数据的 id；在降序中，只需要判断 indicatorId 是否就是表第一行数据的 id。\\n\\nhasNext = indicator != lastRowId if order == \'asc\' else indicator != firstRowId\\n\\n如果要采用不同页加载（即每一页展示固定数量的数据，以页码标记页面）的场景，则可以返回一个总的页码数据。\\n\\nrowAmount = count(\'table\') # count 函数返回一个表的（指定条件的）总行数\\npageAmount = math.ceil(rowAmount / pageSize)\\nhasNext = currentPage < pageAmount\\n","filename":"Typical-CRUD","namespace":"post"},{"title":"记一次奇怪的 MySQL 错误解决","filecontent":"desc: 不知道原理，在线等解释。\\ndate: 2021/08/06\\ncate: 记录\\n记一次奇怪的 MySQL 错误解决\\n\\n今天部署一个 PHP 后端的时候，发现在本地（Windows）测试可以连上数据库，而在生产环境（Ubuntu 20.04）上却报 Permission denied 错误，密码都是正确的，看来还是 Ubuntu 的安全弄得好哟😅，随便去 Google 了一下发现如果要用 root 登录必须得加上 sudo？太奇妙了，于是一秒想到去创建一个新的用户。\\n\\n错误大概是这样的，一个很平凡的 Access denied。\\n\\n(HY000/1698): Access denied for user \'root\'@\'localhost\'\\n\\n然后我就去创建新的用户了，具体流程老生常谈了\\n\\nCREATE USER \'rootp\'@\'localhost\' IDENTIFIED BY \'...\'; -- 不是 root 就可以，嘻嘻\\nGRANT ALL PRIVILEGES ON . TO \'rootp\'@\'localhost\';\\nFLUSH PRIVILEGES;\\n\\n然后就离开了数据库。就在这个时候我突然不知道怎么想的想要重启一下数据库，虽然这种情况下不重启是完全可以的。重启就重启吧，反正不是甚么高危操作，可这一重启可给爷整麻了啊，出现了我从来没有见过的错误，甚至觉得 MariaDB 在逗我。报错信息大概是这样的：\\n\\nAug 06 01:35:42 server systemd[1]: Starting MariaDB 10.1.47 database server...\\n-- Subject: Unit mariadb.service has begun start-up\\n-- Defined-By: systemd\\n-- Support: http://www.ubuntu.com/support\\nUnit mariadb.service has begun starting up.\\nAug 06 01:35:43 server mysqld[4431]: 2021-08-06  1:35:43 140103940127872 [Note] /usr/sbin/mysqld (mysqld 10.1.47-MariaDB-0ubuntu0.18.04.1) starting as process 4431 ...\\nAug 06 01:35:46 server systemd[1]: mariadb.service: Main process exited, code=exited, status=7/NOTRUNNING\\nAug 06 01:35:46 server systemd[1]: mariadb.service: Failed with result \'exit-code\'.\\nAug 06 01:35:46 server systemd[1]: Failed to start MariaDB 10.1.47 database server.\\n-- Subject: Unit mariadb.service has failed\\n-- Defined-By: systemd\\n-- Support: http://www.ubuntu.com/support\\nUnit mariadb.service has failed.\\nThe result is RESULT.\\n\\n看看高亮的行，说的是 SQL 话吗？啥叫作 Failed with result \'exit-code\'、The result is RESULT？笑死，听君一席话，如听一席话！无论怎么去查，得到的结果都不是完全符合，但是它们都有一个共性就是——你要重装你的 MySQL。确实，重装是一个完美的办法，我也很喜欢，干脆利落不用费事费力想办法，可是——我的数据！MySQL 死了，所以 mysqldump 也用不了...这是个悖论，我的数据可能取不回来了，那真是够恐怖。但是我忽然又想到，MySQL 一定是通过文件来存储数据的，于是我搜到了下面这段话。\\nWhat you should do is image your drive, copy it to something else, in preparation for your reinstall. I\'d recommend copying everything as authentically as you can, even if that takes a while. That feeling you get when you realize you forgot to salvage something important that is now gone forever is not good.\\n\\nMySQL generally stores data in the data directory. It may take some work to get your MySQL back into the same configuration as before, so be sure to grab the appropriate my.cnf file.\\n\\nIt can be really difficult to extract data from a bunch of MySQL data files without the MySQL process actually running. This is why tools like mysqldump exist. If you can get it running, even limping along, that\'ll be good enough to snapshot it.\\n\\n*来自 *\\n\\n这段话告诉我，将来的路会很坎坷...啊这，我只是想要重启个 MySQL，用得着这样对我吗。束手无策的时候，我突然想到，既然要重装，要不把数据都换个位置试试？也就是说把整个 MySQL 用来存放数据的文件夹换到另外一个地方，嗯，换个新的环境，没准就可以了。就是这个奇妙的脑回路拯救了我。\\n\\n首先，遇到了一个很坑的地方，那就是不确定数据在哪里。网上说的默认在 /var/lib/mysql，虽然我也发现那里有很多文件，也是不敢确定。然后又有的说可以在配置文件 /etc/mysql/mysql.conf.d/mysqld.cnf 里面看，结果并没有这个文件，也许是因为我是 MariaDB，所以应该在 /etc/mysql/my.cnf 里面。确实有这个文件，但是里面并没有 datadir 这个参数，真是醉了。到后来我鼓起勇气把 datadir 设置成了 /mysql-db，开始了迁移之路。\\n\\nmkdir /mysql-db\\nrsync -av /var/lib/mysql/ /mysql-db\\nchmod 755 /mysql-db\\n\\n盘点一下这里的坑，首先 rsync 的第二个参数 /var/lib/mysql/ 的最后带不带 / 是有区别的。带上了就代表 /var/lib/mysql/*，不带上就代表这个目录本身。刚开始没有带，复制了以后也没有去 ls /mysql-db 导致启动的时候刷了一大堆 not found 报错...然后就是权限问题，应该是 755。\\n\\nip\\n为啥不用 mv *？因为当时想不到 mv，别骂了\\n:::\\n\\n然后还有一个点就是要去 apparmor 里面创建一个别名。\\n\\nvim /etc/apparmor.d/tunables/alias\\n\\n添加 alias /var/lib/mysql -> /mysql-db，然后 systemctl restart apparmor。接下来就可以准备启动 MySQL 了。\\n\\nsystemctl start mysql\\n\\n让我震惊的是这次启动没有报错了。原理还待解释，不过我一秒就去全量备份了一下，因为有了备份就可以直接重装就没有这么多破事了😅\\n\\nmysqldump -u root --all-databases > /alldb.sql\\n\\n然后还可以在 cron 里面加一个定时的备份，为了避免输入密码，可以创建一个 ~/my.cnf 然后写入内容\\n\\n[mysqldump]\\nuser=root\\npassword=...\\n\\n然后在 crontab -e 里面加入\\n\\n10 * * * * mysqldump -u root --all-databases > /alldb.sql\\n\\n就可以了。","filename":"Unknown-MySQL-Issue","namespace":"post"},{"title":"关于","filecontent":"关于\\n\\n这里是关于页面，你可以在这里了解到关于我和关于这个博客的相关内容。\\n\\n我\\n\\n关于我，大概有这么一些事情\\n\\n目标全栈 —— 学点前端，学点后端，再学点底层硬件和代码，人生结束了~🎉\\n排版强迫 —— 对排版具有一定的敏感性和强迫症。\\n切图大师 —— 会使用 Illustrator 和 Photoshop 进行简单的图片处理和图形设计。\\n质感设计 —— 十分欣赏谷歌的 Material Design 设计体系。\\n虚假果粉 —— 我的评价是：除了贵都挺好的。\\n不会听歌 —— 其实就算是喜欢听的歌，听多了我也会不爱听。流派大部分为 Alternative，但有渐渐转向 Indie Rock 的趋势~\\n  认识的第一位歌手：Lady Gaga\\n  比较欣赏的歌手：St. Vincent\\n  喜欢的乐队：Arctic Monkeys, The Black Keys, Broken Bells, Glass Animals, Saint Motel\\n  平时听的其它歌手/乐队：Penelope Scott, Arcade Fire, The Score, Skott, Soler（粤语）, Stealing Sheep, 陈靖霏\\n  我扮演一个路人粉的角色：Taylor Swift, Lana Del Ray, 朴树, 草东没有派对, 美秀集团\\n是方块人 —— Minecraft 10 年玩家。\\n伪二次元 —— 可能会看那么几部番。\\n超敏星座 —— 在十六星座中，我是\\n  INFP-T（2019、2021、2023 年测试结果）。\\nあいうえ —— 日语初级兴趣爱好者。\\n酒精过敏 —— 喝酒脸红没感觉，大概就是不能喝酒吧。\\n\\n此博客\\n\\n本博客始创于 2019 年 8 月 16 日，使用 VuePress 搭建，免费运行在 GitHub Pages 上，运行成本只有域名的成本。起初是手动 build+push 部署，后来使用 GitHub Actions 自动部署。\\n\\n2023 年 7 月 15 日停止使用 VuePress，并仿照原有的构建模式，使用 Vue 3 对博客进行了重写。目前博客自动部署在 Vercel 上。\\n\\n我大概从 2016 年的 12 月份开始写博客，其实一开始的动机就是跟风。当初并不会这些东西，或者说完全没有概念，但是在摸索之下还是把博客搭起来了。一开始的时候没有什么构思，所以并没有写出什么有价值的内容，大多数是一些流水账，比如看过的电影的感受（但现在内容已完全丢失），或者是对博客本身维护的记录等等。\\n\\n这几年里先后换用了 WordPress、Typecho、Hugo、Hexo 等博客程序，经历了反复删库。由于内容并没有太多价值，所以一直不是很放在心上。直到有一天，廉价服务商的不可靠导致数据的永久丢失，然而那时却已经产出了一些我比较珍惜的内容。以此为契机，又为了追求简洁，我萌生了利用纯静态博客程序的想法。\\n\\n博客的主题参考了 VuePress 默认主题。本博客域名 subilan.win 长期不变，你也可以通过 subilan.vercel.app 来访问。\\n\\n为了便于查看，加入了字数统计和阅读时间的估算，具体算法如下。\\n\\nfunction countWords(text) {\\n    return (text.match(/[\\\\u00ff-\\\\uffff]|\\\\S+/g) || []).length;\\n}\\n\\n以 $250$ 字/分为基准值，各个分类所对应的单位时间阅读字数比例如下：\\n\\n|  分类   | 对应比例（$\\\\frac{字/分}{字/分}$） |\\n|:-----:|:-----------------------:|\\n|  其它   |           $1$           |\\n|  记录   |         $0.85$          |\\n| 代码/路径 |          $0.7$          |\\n|   诗   |         $0.75$          |\\n|  思想   |          $0.6$          |\\n\\n: 依据：维基百科\\n","filename":"About","namespace":"page"},{"title":"友链","filecontent":"友链\\n友链（blogroll）是一种将互联网上的一个个孤岛似的个人网站联系起来的一种高效方式。这使得各个网站可以彼此串通，使访问者有更多的机会光顾每一个相连接的网站。\\n\\n这里是友链页面。本页面中呈现的友链，都是按一定标准（见下文）筛选的个人博客。\\n\\n本站的友链信息\\n\\n如有意添加本站友链，可参考以下信息。\\n网站名称：Subilan\'s Blog\\n网站介绍：Satellite yourself.\\n网站代表色：#009688\\n网站地址：\\n头像（圆）：\\n头像（方）：\\n\\n如何在本站上添加友链？\\n\\n请确保你的网站满足以下要求：\\n\\n至少有一篇计算机领域的原创博文**\\n博客在 2 年内至少发布过两篇博文**（最近两篇博文发布日期应该在  之后）\\n全站开启 HTTPS\\n域名为本人所有或者系有影响力的二级域名\\n  你的个人域名，例如 subilan.win\\n  有影响力的二级域名，例如 .github.io、.js.org\\n个人博客性质，不含大规模宣传内容\\n\\n若已确定满足以上需求，则可以从下面三个方式中选择一个申请友链。\\n\\n直接联系我** — 使用联系页面里的联系方式联系我，并提供相关信息\\nPull Request** — 如果你有 GitHub 账号和使用经验，则可以自己手动向 Subilan/subilan.github.io 提交 pull request。具体地，请依照项目中 src/components/blogrolls.json 内的写法继续在该文件中添加内容。\\n提交 Issue** — 如果你有 GitHub 账号，则可以在 Subilan/subilan.github.io 项目中提交 Issue，注明友链申请和提供相关信息即可。\\n\\n申请时需要提供的信息的模板为：\\n网站名称：（必填）\\n网站介绍：（必填）\\n网站代表色：（选填，若不填则为黑色）\\n网站地址：（必填）\\n头像（圆形、方形皆可）：（必填）\\n\\n你的友链将最终呈现为下面这样，具体宽度视友链添加情况自动调整。\\n\\n\\n\\n一般我会在 48 小时内答复。若超时间没有答复，可以通过联系方式再次联系我以示提醒。","filename":"Blogroll","namespace":"page"},{"title":"联系","filecontent":"联系\\n\\n一般会在 24 小时内回复（如有必要）。\\n\\nGitHub Issue\\nGmail christophersubilan@gmail.com\\nQQ 邮箱 1843917482@qq.com\\nTelegram\\nGitHub\\n知乎\\nBilibili\\nPGP","filename":"Contact","namespace":"page"}]');function s(){return i}function l(){return o.Z}function c(){return r}function u(n){if(!n)return"";const e={"思想":"circle-opacity","路径":"arrow-right-top-bold","记录":"fountain-pen-tip","代码":"code-tags","诗":"flower-tulip"};return e[n]?`mdi-${e[n]}`:""}function d(){return window.innerWidth>700}function p(){document.body.style.overflow="hidden",document.body.style.height="100%"}function m(){document.body.style.overflow="",document.body.style.height=""}function f(n){window.open(n)}}},e={};function t(a){var i=e[a];if(void 0!==i)return i.exports;var o=e[a]={exports:{}};return n[a].call(o.exports,o,o.exports,t),o.exports}t.m=n,function(){var n=[];t.O=function(e,a,i,o){if(!a){var r=1/0;for(u=0;u<n.length;u++){a=n[u][0],i=n[u][1],o=n[u][2];for(var s=!0,l=0;l<a.length;l++)(!1&o||r>=o)&&Object.keys(t.O).every((function(n){return t.O[n](a[l])}))?a.splice(l--,1):(s=!1,o<r&&(r=o));if(s){n.splice(u--,1);var c=i();void 0!==c&&(e=c)}}return e}o=o||0;for(var u=n.length;u>0&&n[u-1][2]>o;u--)n[u]=n[u-1];n[u]=[a,i,o]}}(),function(){t.n=function(n){var e=n&&n.__esModule?function(){return n["default"]}:function(){return n};return t.d(e,{a:e}),e}}(),function(){t.d=function(n,e){for(var a in e)t.o(e,a)&&!t.o(n,a)&&Object.defineProperty(n,a,{enumerable:!0,get:e[a]})}}(),function(){t.f={},t.e=function(n){return Promise.all(Object.keys(t.f).reduce((function(e,a){return t.f[a](n,e),e}),[]))}}(),function(){t.u=function(n){return"js/"+n+"."+{16:"84721c9d",39:"759b5629",45:"65fbcd1d",55:"b40114bb",61:"b60c506f",63:"dfd9bbdd",90:"05756e92",108:"f1368184",127:"713b7aa9",138:"37cb3b22",164:"62a79aef",228:"2548b0ac",262:"5a0bf685",268:"e872d740",271:"fdc92d77",292:"5328bf45",311:"0d3a3786",317:"160da86f",325:"3e03e23d",326:"11ac9ade",370:"38b9fa31",390:"4eda1e18",406:"f73a7ae7",469:"e59e7b5e",514:"36427b8a",515:"fdb8a405",534:"45a98921",572:"72510071",594:"e9382479",596:"b630643a",613:"9f173b0c",708:"41d610af",743:"e78e516a",785:"27aa29ed",815:"f57f63ce",816:"63453a9c",847:"3205d606",848:"4cca004d",849:"ee8e21bc",875:"2e466394",912:"a34e286e",915:"70b08ca8",982:"d1c247e4",983:"a24360f9"}[n]+".js"}}(),function(){t.miniCssF=function(n){return"css/"+n+"."+{127:"413bccc4",983:"faf05265"}[n]+".css"}}(),function(){t.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"===typeof window)return window}}()}(),function(){t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)}}(),function(){var n={},e="blog:";t.l=function(a,i,o,r){if(n[a])n[a].push(i);else{var s,l;if(void 0!==o)for(var c=document.getElementsByTagName("script"),u=0;u<c.length;u++){var d=c[u];if(d.getAttribute("src")==a||d.getAttribute("data-webpack")==e+o){s=d;break}}s||(l=!0,s=document.createElement("script"),s.charset="utf-8",s.timeout=120,t.nc&&s.setAttribute("nonce",t.nc),s.setAttribute("data-webpack",e+o),s.src=a),n[a]=[i];var p=function(e,t){s.onerror=s.onload=null,clearTimeout(m);var i=n[a];if(delete n[a],s.parentNode&&s.parentNode.removeChild(s),i&&i.forEach((function(n){return n(t)})),e)return e(t)},m=setTimeout(p.bind(null,void 0,{type:"timeout",target:s}),12e4);s.onerror=p.bind(null,s.onerror),s.onload=p.bind(null,s.onload),l&&document.head.appendChild(s)}}}(),function(){t.r=function(n){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})}}(),function(){t.p="/"}(),function(){if("undefined"!==typeof document){var n=function(n,e,t,a,i){var o=document.createElement("link");o.rel="stylesheet",o.type="text/css";var r=function(t){if(o.onerror=o.onload=null,"load"===t.type)a();else{var r=t&&("load"===t.type?"missing":t.type),s=t&&t.target&&t.target.href||e,l=new Error("Loading CSS chunk "+n+" failed.\n("+s+")");l.code="CSS_CHUNK_LOAD_FAILED",l.type=r,l.request=s,o.parentNode&&o.parentNode.removeChild(o),i(l)}};return o.onerror=o.onload=r,o.href=e,t?t.parentNode.insertBefore(o,t.nextSibling):document.head.appendChild(o),o},e=function(n,e){for(var t=document.getElementsByTagName("link"),a=0;a<t.length;a++){var i=t[a],o=i.getAttribute("data-href")||i.getAttribute("href");if("stylesheet"===i.rel&&(o===n||o===e))return i}var r=document.getElementsByTagName("style");for(a=0;a<r.length;a++){i=r[a],o=i.getAttribute("data-href");if(o===n||o===e)return i}},a=function(a){return new Promise((function(i,o){var r=t.miniCssF(a),s=t.p+r;if(e(r,s))return i();n(a,s,null,i,o)}))},i={143:0};t.f.miniCss=function(n,e){var t={127:1,983:1};i[n]?e.push(i[n]):0!==i[n]&&t[n]&&e.push(i[n]=a(n).then((function(){i[n]=0}),(function(e){throw delete i[n],e})))}}}(),function(){var n={143:0};t.f.j=function(e,a){var i=t.o(n,e)?n[e]:void 0;if(0!==i)if(i)a.push(i[2]);else{var o=new Promise((function(t,a){i=n[e]=[t,a]}));a.push(i[2]=o);var r=t.p+t.u(e),s=new Error,l=function(a){if(t.o(n,e)&&(i=n[e],0!==i&&(n[e]=void 0),i)){var o=a&&("load"===a.type?"missing":a.type),r=a&&a.target&&a.target.src;s.message="Loading chunk "+e+" failed.\n("+o+": "+r+")",s.name="ChunkLoadError",s.type=o,s.request=r,i[1](s)}};t.l(r,l,"chunk-"+e,e)}},t.O.j=function(e){return 0===n[e]};var e=function(e,a){var i,o,r=a[0],s=a[1],l=a[2],c=0;if(r.some((function(e){return 0!==n[e]}))){for(i in s)t.o(s,i)&&(t.m[i]=s[i]);if(l)var u=l(t)}for(e&&e(a);c<r.length;c++)o=r[c],t.o(n,o)&&n[o]&&n[o][0](),n[o]=0;return t.O(u)},a=self["webpackChunkblog"]=self["webpackChunkblog"]||[];a.forEach(e.bind(null,0)),a.push=e.bind(null,a.push.bind(a))}();var a=t.O(void 0,[998],(function(){return t(343)}));a=t.O(a)})();
//# sourceMappingURL=app.d79c9c76.js.map